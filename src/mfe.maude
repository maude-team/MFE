----                                          The Maude Formal Environment 1.0g
----                                                 To be run on Maude 3.5.1++
----                                                   authors: Francisco Duran

set print attribute off .

set show loop stats off .
set show loop timing off .

load FM/full-maude351.maude
----load GLOT/glot.maude
----load ITP/itp.maude
load CRChC/crchc3u.maude
load MTT/mtt.maude
load SCC/scc.maude
----load EqE/eqe.maude
----load ERTP/ertp.maude
sload file 
sload process
sload time 

***
*** Maude Formal Environment
***

--- Global variables
mod MFE-GLOBAL-VARS is
  ---- inc TERMINATION-CHECKER .
  pr CC .
  ---- set constant ceta-hook to true if CETA library is avaiable from Maude
  ---- via the test-emptiness hook. CETA is only available on Linux.
  op ceta-hook : -> Bool .
  eq ceta-hook = test-emptiness(upModule('TRUTH-VALUE, false)) :: EmptinessResult .
  ---- set constant mtt-hook to true if MTTs back end tools are available
  ---- from Maude via the corresponding hook. The writeToFile and termCheck
  ---- hooks are supposed to go together
----  op mtt-hook : -> Bool .
----  ----eq mtt-hook = true == true . ---- FOR DEBUGGING
----  eq mtt-hook = writeToFile(".hook-check", "", true) :: String .
----  ---- We could check on the availability of specific termination tools as well,
----  ---- but since they depend on the mfe.config file it is not possible a generic check.
----  ---- eq mtt-hook = termCheck("muterm", "", 30) :: String .
endm


fmod MFE-BANNER is
  pr STRING .
  op mfe-banner : -> String .
  eq mfe-banner = "The Maude Formal Environment 3.0" .
endfm


fmod MFE-HELP is
  pr LEXICAL .
  pr MFE-BANNER .
  ops mfe-help mfe-tools : -> QidList .
  eq mfe-help =
      tokenize("Commands available in the Maude Formal Environment:") '\n
      tokenize(" - select tool <tool-name> .") '\n 
      '\t tokenize("Sets <tool-name> as current tool.") '\n
      tokenize(" - show global state .") '\n 
      '\t tokenize("Shows the current state of the framework.") '\n
      tokenize(" - show tools .") '\n 
      '\t tokenize("Shows the tools available in the framework.") '\n
      tokenize(" - which tool .") '\n 
      '\t tokenize("Shows the name of the current tool.") '\n 
      tokenize(" - MFE help .") '\n 
      '\t tokenize("Shows this help information.") '\n
      tokenize(" - <tool-name> help .") '\n 
      '\t tokenize("After selecting a tool, this command shows help information on the corresponding tool.") '\n .
  eq mfe-tools =
      tokenize("Tools available in the Maude Formal Environment:") '\n
      tokenize(" - ChC - Coherence Checker") '\n
      tokenize(" - CRC - Church Rosser Checker") '\n
      ---- '\t '\! 'ITP '\o '\t 'Inductive 'Theorem 'Prover '\n
      ---- '\t '\! 'MFE '\o '\t 'Maude 'Formal 'Environment '`( 'MFE '`) '\n
      ---- '\t '\! 'MTT '\o '\t 'Maude 'Termination 'Tool '\n
      tokenize(" - SCC - Sufficient Completeness Checker") '\n
      ---- '\t '\! 'EqE '\o '\t 'Equality 'Enrichment 'Tool '\n 
      .
endfm


fmod MFE-TEXT-STYLE is
  pr TEXT-STYLE .

  var QL : QidList .

  op mfe-success : QidList -> QidList .
  eq mfe-success(QL) = bold(green('Success:)) QL .

  op mfe-warning : QidList -> QidList .
  eq mfe-warning(QL) = bold(yellow('Warning:)) QL .

  op mfe-failure : QidList -> QidList .
  eq mfe-failure(QL) = bold(red('Failure:)) QL .

  op mfe-error : QidList -> QidList .
  eq mfe-error(QL) = red('Error:) QL .
endfm


fmod MFE-NAME is
  pr QID .

  sort ToolName .
  subsort String < ToolName . --- Tool names are strings

  var St : String .
  var QI : Qid .

  op name2qid : ToolName -> Qid .
  eq name2qid(St) = qid(St) .

  op qid2name : Qid -> ToolName .
  eq qid2name(QI) = string(QI) .
endfm


fmod MFE-SIGN is
  including FULL-MAUDE-SIGN .
  protecting MFE-NAME .

  op MFE help . : -> @Command@ .
  op select tool_. : @Token@ -> @Command@ .
  op show global state . : -> @Command@ .
  op show tools . : -> @Command@ .
  op which tool . : -> @Command@ .
endfm


fmod META-MFE-SIGN is
  inc META-LEVEL .
  pr META-FULL-MAUDE-SIGN .
  pr FM-UNIT .

  ---- The grammar of the MFE extends the grammar of Full Maude.
  op MFE-GRAMMAR : -> FModule [memo] .
  eq MFE-GRAMMAR = addImports((including 'MFE-SIGN .), GRAMMAR) .
endfm

*** Syntax for shared messages between the different tools
*** interacting in the MFE

omod MFE-PUBLIC-MESSAGES is
  pr META-LEVEL .
  pr MOD-NAME .
  pr SET{Oid} .
  pr MTT-PRELIMINARIES .

  sort MFEPublicMsgBody .
  op to_from_:_ : Oid Oid MFEPublicMsgBody -> Msg [ctor] .
  op to_from_:_ : Set{Oid} Oid MFEPublicMsgBody -> Msg [ctor] .
  op to_from_:_ : Oid Oid Term -> Msg [ctor] .

  vars O O' O'' : Oid .
  var  OS : Set{Oid} .
  var  MB : MFEPublicMsgBody .

  eq to O, O', OS from O'' : MB
    = (to O from O'' : MB)
      (to O', OS from O'' : MB) .
  eq to empty from O : MB = none .

  ---- ITP messages
  op add-goal_:_|-_=_if_ : String Module Term Term Condition -> MFEPublicMsgBody .
  op add-goal_:_|-_:_if_ : String Module Term Sort Condition -> MFEPublicMsgBody .
  --- TODO Implement logic for joinability
  op add-goal_:_|-_v_if_ : String Module Term Term Condition -> MFEPublicMsgBody .
  --- TODO Implement logic for rewriting
  op add-goal_:_|-_=>_if_ : String Module Term Term Condition -> MFEPublicMsgBody .
  op goal_registered-as_ : String String -> MFEPublicMsgBody .
  op goal_proved : String -> MFEPublicMsgBody .
  op unregister-goal_ : String -> MFEPublicMsgBody .
  op failure-registering-goal_ : String -> MFEPublicMsgBody .
  op failure-registering-goal_because_ : String QidList -> MFEPublicMsgBody .
  op output-state : -> MFEPublicMsgBody .

  ---- ChC messages
  op check coherence_ground:_ : Module Bool -> MFEPublicMsgBody .
  op module_is coherent : ModuleName -> MFEPublicMsgBody .
  op module_is ground-coherent : ModuleName -> MFEPublicMsgBody .

  ---- MTT messages
  op check termination_functional part_ : Module Bool -> MFEPublicMsgBody .
  op check termination_using_functional part_ : Module Path Bool -> MFEPublicMsgBody .
  op module_is terminating functional part_ : ModuleName Bool -> MFEPublicMsgBody .
  op module_is non-terminating functional part_ : ModuleName Bool -> MFEPublicMsgBody .
  ---- the proof of termination may refer to the functional part of the module, which is specified by the Bool arg.
  op check termination : -> MFEPublicMsgBody .
----  op termination check response for module_is_ : ModuleName String -> MFEPublicMsgBody .

  ---- CRC messages
  op check Church-Rosser_ : Module -> MFEPublicMsgBody .
  op check confluence_ : Module -> MFEPublicMsgBody .
  op check sort-decreasingness_ : Module -> MFEPublicMsgBody .
  op check ground-sort-decreasingness_ : Module -> MFEPublicMsgBody .
  op module_is Church-Rosser : ModuleName -> MFEPublicMsgBody .
  op module_is ground-Church-Rosser : ModuleName -> MFEPublicMsgBody .
  op module_is confluent : ModuleName -> MFEPublicMsgBody .
  op module_is ground-confluent : ModuleName -> MFEPublicMsgBody .
  op module_is locally ground-confluent : ModuleName -> MFEPublicMsgBody .
  op module_is locally-confluent : ModuleName -> MFEPublicMsgBody .
  op module_is sort-decreasing : ModuleName -> MFEPublicMsgBody .
  op module_is ground-sort-decreasing : ModuleName -> MFEPublicMsgBody .

  ---- SCC messages
  op check sc_ : Module -> MFEPublicMsgBody .
  op check free_ : Module -> MFEPublicMsgBody .
  op module_is sufficiently complete : ModuleName -> MFEPublicMsgBody .
  op module_has free equational constructors : ModuleName -> MFEPublicMsgBody .

  ---- Equality enrichment messages
  op enrich_          : Module -> MFEPublicMsgBody .
  op enrich patching_ : Module -> MFEPublicMsgBody .
  op module_is an equality enrichment of_ : ModuleName ModuleName -> MFEPublicMsgBody .

  ---- ERTP messages
  sort ERTPGoal .
  op prove_in_        : ERTPGoal Module -> MFEPublicMsgBody .

  ---- Common messages
  op printState : -> MFEPublicMsgBody [ctor] .
  op printState : String -> MFEPublicMsgBody [ctor] .
  op state : QidList -> MFEPublicMsgBody [ctor] .
  op input : QidList -> MFEPublicMsgBody . ---- the controller sends the entered qid list to the current tool
  op input-parsed : QidList Bool -> MFEPublicMsgBody . ---- the current tool answers to the controller on the parsing
  op output : QidList -> MFEPublicMsgBody . ---- output message to be handled by the controller
  op toolError : QidList -> MFEPublicMsgBody [ctor] .
endom


view ToolName from TRIV to MFE-NAME is
  sort Elt to ToolName .
endv

--------------------------------------------------------------------------------
--- MFE-GOAL
--------------------------------------------------------------------------------
omod MFE-GOAL is
  inc FM-DATABASE-HANDLING .
  pr SET{Oid} .

  class Goal |
    requester : Set{Oid}, 
      ---- in some tools, such as the ChC, it is important to maintain the original module
      ---- to submit it to the CRC or MTT, and use a possibly transformed version of the
      ---- module for the use of the tool.
    original-module : Module,
    module : Module .
endom

--------------------------------------------------------------------------------
---  MFE-TOOL
---- This module includes the basic common infrastructure provided by the MFE to
---- all the tools in the environment.
--------------------------------------------------------------------------------
omod MFE-TOOL is
  inc FM-DATABASE-HANDLING .
  inc MFE-PUBLIC-MESSAGES .
  inc MFE-GOAL .
  pr MAP{ModuleName, Oid} .
  pr MAP{ToolName, Oid} .

  class Tool | tools : Map{ToolName, Oid},  ---- The oid of each tool is associated to its name, e.g., "CRC" |-> crc
               grammar : Module,            ---- grammar of the tool
               current : Oid,               ---- oid of the current tool
               index : Nat,                 ---- index to generate ids of new instances
               reg : Map{ModuleName, Oid} . ---- maps module names to instances
                                            ---- used to check whether modules have been previously checked, and by what instance .

  op null-oid : -> Oid [ctor] .
  op wait : Msg -> Msg [ctor] .

  vars O O' O'' O''' : Oid .
  var  G : Module .
  vars QIL QIL' : QidList .
  var  MN : ModuleName .
  var  MNReg : Map{ModuleName, Oid} .
  var  T : Term .
  var  TN : ToolName .

  op _in domain of_ : ModuleName Map{ModuleName, Oid} -> Bool .
  eq MN in domain of (MN |-> O, MNReg) = true .
  eq MN in domain of MNReg = false [owise] .

  op _in codomain of_ : Oid Map{ModuleName, Oid} -> Bool .
  eq O in codomain of ((MN |-> O), MNReg)  = true .
  eq O in codomain of MNReg = false [owise] .

  ---- The inputs from the user are attempted to parse in the grammar of MFE,
  ---- if it fails the input is submitted to the current tool. The tool is expected to
  ---- return an input-parsed message indicating whether it was able to parse it or not.
 crl [input] :
    < O : Tool | grammar : G >
    (to O from O' : input(QIL))
    => < O : Tool | grammar : G >
       (to O from O' : getTerm(metaParse(G, QIL, '@Input@))) ---- if parsed, the tool re-sends the message with the term resulting from the parsing
       (to O' from O : input-parsed(QIL, true))
    if RP:ResultPair := metaParse(G, QIL, '@Input@) .
 crl [input] :
    < O : Tool | grammar : G >
    (to O from O' : input(QIL))
    => < O : Tool | grammar : G >
       (to O' from O : input-parsed(QIL, false))
    if not metaParse(G, QIL, '@Input@) :: ResultPair .

  ---- show state
  op prettyPrintToolState : Oid Oid Map{ModuleName, Oid} QidList -> Msg [ctor] .
  ---- This prettyPrintToolState message is responsible of adding succesively the
  ---- states of each of the goals associated to the tool. The Tool sends a
  ---- printState message to each of its registered goals and waits for its
  ---- state. The wait operator is used to block until a response is obtained.

  rl [show-state] :
    < O : Tool | reg : MNReg >
    (to O from O' : 'show`state`..@Command@)
    => < O : Tool | reg : MNReg >
       (to O from O' : printState) .

  rl [show-state] :
    < O : Tool | reg : MNReg >
    (to O from O' : printState(TN))
    => < O : Tool | reg : MNReg >
       if MNReg == empty
       then (to O' from O : output('The 'state 'of 'the name2qid(TN) 'is 'empty. '\n))
       else prettyPrintToolState(O', O, MNReg, 'State 'of 'the name2qid(TN) 'tool: '\n)
       fi .
  rl [show-state] :
    < O : Tool | reg : MNReg >
    (to O from O' : printState)
    => < O : Tool | reg : MNReg >
       if MNReg == empty
       then (to O' from O : output('The 'state 'is 'empty. '\n))
       else prettyPrintToolState(O', O, MNReg, 'State 'of 'the 'tool: '\n)
       fi .

  rl [show-state] :
    < O : Tool | none >
    prettyPrintToolState(O', O, (MN |-> O'', MNReg), QIL)
    => < O : Tool | none >
       (to O'' from O : printState)
       wait(prettyPrintToolState(O', O, MNReg, QIL)) .
  rl [show-state] :
    < O : Tool | none >
    (to O from O'' : state(QIL'))
    wait(prettyPrintToolState(O', O, MNReg, QIL))
    => < O : Tool | none >
       prettyPrintToolState(O', O, MNReg, QIL QIL') .
  rl [show-state] :
    < O : Tool | none >
    prettyPrintToolState(O', O, empty, QIL)
    => < O : Tool | none >
       (to O' from O : output(QIL)) .

  ---- select current goal
  crl [select] :
    < O : Tool | current : O', reg : (MN |-> O'', MNReg) >
    (to O from O''' : 'select`goal_.[T])
    => < O : Tool | current : O'', reg : (MN |-> O'', MNReg) >
       (to O''' from O : output(eMetaPrettyPrint(parseModExp(T)) 'is 'now 'the 'current 'goal. '\n))
    if MN = parseModExp(T) .
  crl [select] :
    < O : Tool | reg : MNReg >
    (to O from O''' : 'select`goal_.[T])
    => < O : Tool | reg : MNReg >
       (to O''' from O : output(eMetaPrettyPrint(parseModExp(T)) 'cannot 'be 'set 'as 'current 'goal. '\n))
    if not parseModExp(T) in domain of MNReg .
endom


omod MFE-CONTROLLER is
  inc LOOP-MODE .
  inc MFE-PUBLIC-MESSAGES .
  inc FM-DATABASE-HANDLING .
  inc MFE-HELP .
  inc MFE-TOOL .
  pr META-MFE-SIGN .
  pr MFE-TEXT-STYLE .
  inc STD-STREAM .
  pr LEXICAL .
  pr STRING-OPS .

  ---- The MFE control class is declared as a subclass of Full Maude (Database)
  class MFE | current-tool : Oid .
  subclass MFE < FM .

  ---- Oids for the MFE
  op mfe : -> Oid .

  var  Conf : Configuration .
  vars DB DB' : Database .
  vars ME ME' : ModuleExpression .
  vars O O' : Oid .
  var  QI : Qid .
  var  TL : TermList .
  vars QIL QIL' QIL'' QIL''' : QidList .
  var  TS : Map{ToolName, Oid} .
  var  Ct : Constant .
  var  TN : ToolName .
  var  MN : ModuleName .
  var  B : Bool .
  vars TEXT PROMPT IIPROMPT : String .
  var  N : Nat .

  ---- INPUT PARSING
  op wait-answer : QidList QidList -> Msg [ctor] .
  op processLine : Oid QidList ResultPair -> Msg [ctor] .

  rl [in] :
    < O : MFE | partial-input : QIL, incomplete-input-prompt : IIPROMPT >
    gotLine(O, stdin, TEXT)
    =>  if TEXT == "\n" or startsWith(TEXT, "----") then 
          < O : MFE | none >
          getLine(stdin, O, IIPROMPT) 
        else 
          < O : MFE | partial-input : nil >
          processLine(O, QIL tokenize(TEXT), metaParse(MFE-GRAMMAR, QIL tokenize(TEXT), '@Input@))
        fi .
  
  rl [in] :  
    ---- If the input parses in the grammar of FM extended with the general MFE commands,
    ---- the input is directly handled by Full Maude (and the MFE object).
    < O : MFE | prompt : PROMPT >
    processLine(O, QIL, RP:ResultPair)
    => < O : MFE | input : getTerm(RP:ResultPair) > .
    
  rl [in] :
    < O : MFE | partial-input : nil, current-tool : O', prompt : PROMPT, incomplete-input-prompt : IIPROMPT >
    processLine(O, QIL, noParse(N))
    =>  if size(QIL) == N then
          ---- If the input is incomplete (e.g., a module definition not yet finished), then save it and go on reading.
          < O : MFE | partial-input : QIL >
          getLine(stdin, O, IIPROMPT)
        else 
          ---- If it cannot be handled by the MFE object, the input is passed
          ---- to the current tool. If no current tool an error message is generated.
          ---- To avoid reparsing, the result of the parsing is saved, and if the
          ---- current tool cannot handle the input either the saved message is printed out.
          ---- The wait-answer message keeps the input and the corresponding error message.
          ---- A to O' from O : input(QI QIL) message is sent to the current tool.
          ---- And a input-parsed(QI QIL, B) message is expected from the current tool.
          ---- B == true means that the tool was able to parse it. A false means that it wasn't.
          < O : MFE | none > 
          if O' == null-oid or O' == O then
            (to O from O : input-parsed(QIL, false))
          else 
            to O' from O : input(QIL)
          fi
          wait-answer(QIL,
            ('\r 'Warning: printSyntaxError(noParse(N), QIL) '\n 
              '\r 'Error: '\o 'No 'parse 'for 'input. '\n))
        fi .

  rl [in] :
    < O : MFE | none >
    (to O from O' : input-parsed(QIL, true))
    wait-answer(QIL, QIL')
    => < O : MFE | none > .
  rl [in] :
    < O : MFE | output : nil >
    (to O from O' : input-parsed(QIL, false))
    wait-answer(QIL, QIL''')
    => < O : MFE | output : QIL''' > .

  rl [select-tool] :
    < O : MFE |
        input : ('select`tool_.['token[Ct]]),
        output : QIL,
        current-tool : O',
        tools : TS >
    => < O : MFE |
           input : nilTermList,
           output : (if TS[qid2name(getName(downQid(Ct)))] == undefined
                     then QIL 'Incorrect 'tool. '\n
                     else QIL 'The getName(downQid(Ct)) 'has 'been 'set 'as 'current 'tool. '\n
                     fi),
           current-tool : (if TS[qid2name(getName(downQid(Ct)))] == undefined
                           then O'
                           else TS[qid2name(getName(downQid(Ct)))]
                           fi),
           tools : TS > .

  rl [help] :
    < O : MFE | input : ('MFE`help`..@Command@), output : QIL >
    => < O : MFE | input : nilTermList, output : (QIL mfe-help) > .

  rl [show-tools] :
    < O : MFE | input : ('show`tools`..@Command@), output : QIL >
    => < O : MFE | input : nilTermList, output : (QIL mfe-tools) > .

  rl [which-tool] :
    < O : MFE | input : ('which`tool`..@Command@), output : QIL, current-tool : O', tools : (TN |-> O', TS) >
    => < O : MFE | input : nilTermList, output : (QIL 'Current 'tool 'is name2qid(TN) '\n), current-tool : O', tools : (TN |-> O', TS) > .

  ---- show global state
  op pretty-print-global-state : Oid Map{ToolName, Oid} QidList -> Msg [ctor] .

  rl [show-global-state] :
    < mfe : MFE | input : ('show`global`state`..@Command@), tools : ("MFE" |-> mfe, TS) >
    => < mfe : MFE | input : nilTermList, tools : ("MFE" |-> mfe, TS) >
       pretty-print-global-state(mfe, TS, 'Global 'state: '\n) .

  rl [show-global-state] :
    < O : MFE | none >
    pretty-print-global-state(O, (TN |-> O', TS), QIL)
    => < O : MFE | none >
       (to O' from O : printState(TN))
       pretty-print-global-state(O, TS, QIL) .
  rl [show-global-state] :
    < O : MFE | output : QIL >
    pretty-print-global-state(O, empty, QIL')
    => < O : MFE | output : (QIL QIL') > .

  rl [out] :
    < O : MFE | none >
    (to O from O' : toolError(QIL'))
    => < O : MFE | none >
       (to O from O' : output(QIL')) .

  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is terminating functional part B)
    => < O : MFE | none >
       if B ---- functional part
       then (to O from O' : output(mfe-success('The 'functional 'part 'of 'module eMetaPrettyPrint(MN) 'is 'terminating. '\n)))
       else (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'terminating. '\n)))
       fi .
  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is non-terminating functional part B)
    => < O : MFE | none >
       if B ---- functional part
       then (to O from O' : output(mfe-success('The 'functional 'part 'of 'module eMetaPrettyPrint(MN) 'is 'non-terminating. '\n)))
       else (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'non-terminating. '\n)))
       fi .
  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is sufficiently complete)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('Module eMetaPrettyPrint(MN) 'is 'sufficiently 'complete. '\n))) .
  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN has free equational constructors)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('Module eMetaPrettyPrint(MN) 'has 'free 'equational 'constructors. '\n))) .

  rl [out] :
    < O : MFE | db : DB, input : TL, output : (QI QIL'), default : ME >
    => < O : MFE | db : DB, input : TL, output : nil, default : ME >
       write(stdout, O, printTokens(QI QIL')) .
  rl [out] :
    < O : MFE | none >
    (to O from O' : output(QIL'))
    => < O : MFE | none > 
       write(stdout, O, printTokens(QIL')) .
endom


--------------------------------------------------------------------------------
--- 3BOOL
--------------------------------------------------------------------------------

fmod 3BOOL is
  pr TRUTH .
  sort 3Bool .
  subsort Bool < 3Bool .
  op maybe : -> 3Bool [ctor] .
---(
  op _and_ : 3Bool 3Bool -> 3Bool [ditto] .
  op _or_ : 3Bool 3Bool -> 3Bool [ditto] .
  op _xor_ : 3Bool 3Bool -> 3Bool [ditto] .
  op not_ : 3Bool -> 3Bool [ditto] .
  op _implies_ : 3Bool 3Bool -> 3Bool [ditto] .
  vars A B C : 3Bool .
  eq maybe and false = false .
  eq maybe and maybe = maybe .
  eq maybe and true = maybe .
  eq maybe xor true = maybe .
  eq maybe xor false = maybe .
  eq maybe xor maybe = maybe .
  eq not maybe = maybe .
  eq maybe or true = true .
  eq maybe or false = maybe .
  eq maybe or maybe = maybe .
  eq maybe implies true = true .
  eq maybe implies false = false .
  eq maybe implies maybe = maybe .
  eq true implies maybe = maybe .
  eq false implies maybe = maybe .
  op if_then_else_fi : 3Bool Configuration Configuration -> Configuration .
  eq if maybe then U1:Configuration else U2:Configuration fi = U2:Configuration .
---)
endfm

--------------------------------------------------------------------------------
--- MFE-CRC
--------------------------------------------------------------------------------

omod MFE-CRC is
  inc MFE-TOOL .
  inc MFE-CONTROLLER .
  inc CRChC-TOOLS .
  inc CRC-BANNER .
  pr 3BOOL .

  ---- Classes CRCBroker and CRC
  ---- A CRCBroker object receives the messages to the Church-Rosser checker.
  ---- A new check makes the CRCBroker to do:
  ---- - If on a module for which no check has been done before, a new CRC object
  ----   is created for it, which keeps the cps and mas generated, and their state
  ----   during the check. After the checks accomplished by the CRC, proof obligations
  ----   can be submitted to the ITP, which answers once the proofs are completed.
  ---- - If the check is repeated for a module for which the check was done before,
  ----   the check is recomputed, and the proofs for the previous check are reset.
  ----   The module may be the same one or a new module (e.g., equations added).
  ----   The state of the previous check is removed, and all proof obligations submitted
  ----   to the ITP are reset.
  ---- - A check for a module can also be removed with the remove CRC check.
  class CRCBroker .
  class CRC |
    confluence-requester : Set{Oid}, 
    sort-decreasingness-requester : Set{Oid}, 
    cps : CritPairSet, 
    mas : MembAssertSet, 
    cp-reg : Map{String, String},
    ma-reg : Map{String, String},  ---- maps ids in the CRC to ids in the ITP
    terminating : 3Bool,           ---- true if the (functional part of the) module has been proved terminating
    locally-confluent : 3Bool,     ---- true if the (functional part of the) module has been proved locally-confluent
    sort-decreasing : 3Bool,       ---- true if the (functional part of the) module has been proved sort-decreasing
    coherent : 3Bool .             ---- true if the (functional part of the) module has been proved coherent
  subclass CRCBroker < Tool .
  subclass CRC < Goal .

  op CRC : Nat -> Oid .

  op init-crc : Map{ToolName, Oid} -> Configuration [ctor] .

  vars O O' O'' O''' O4 O5 OMFE OCRC OChC OITP OSCC OMTT : Oid .
  vars OS OS' OS'' : Set{Oid} .
  var  TS : Map{ToolName, Oid} .
  var  MN : ModuleName .
  var  MNReg : Map{ModuleName, Oid} .
  var  N : Nat .
  vars QIL QIL' : QidList .
  vars T T' : Term .
  vars DB DB' : Database .
  vars ME ME' : ModuleExpression .
  vars M M' : Module .
  var  CP : CritPair .
  var  MA : MembAssert .
  var  CPS : CritPairSet .
  var  MAS : MembAssertSet .
  vars Reg CPReg MAReg : Map{String, String} .
  vars B B' : Bool .
  vars 3B 3B' 3B'' : 3Bool .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPS : OpDeclSet .
  var  MbS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars Id Id' : String .
  vars QI L L' : Qid .
  var  Cd : Condition .
  var  S : Sort .
  var  CPStat : CPStatus .
  var  MAStat : MAStatus .
  var  CRCCT : CRCcheckType .
  var  Obj : Object .
  var  St : String .

  op CRC-GRAMMAR : -> FModule .
  eq CRC-GRAMMAR = addImports((including 'CRC-SIGN .), BUBBLES) .

  eq (to O from O' : ('ccr`..@Command@))
    = (to O from O' : ('check`Church-Rosser`..@Command@)) .
  eq (to O from O' : ('ccr_.[T]))
    = (to O from O' : ('check`Church-Rosser_.[T])) .
  eq (to O from O' : ('show`cps`..@Command@))
    = (to O from O' : ('show`critical`pairs`..@Command@)) .
  eq (to O from O' : ('show`all`cps`..@Command@))
    = (to O from O' : ('show`all`critical`pairs`..@Command@)) .
  eq (to O from O' : ('show`mas`..@Command@))
    = (to O from O' : ('show`membership`assertions`..@Command@)) .
  eq (to O from O' : ('show`all`mas`..@Command@))
    = (to O from O' : ('show`all`membership`assertions`..@Command@)) .

  ---- initialization
  rl init-crc(TS)
    => < TS["CRC"] : CRCBroker |
             grammar : CRC-GRAMMAR,
             tools : TS,
             current : null-oid,
             index : 0,
             reg : empty > .

---(
  ---- output forwarding
  rl [output] :
     (to O from O' : crchc-output(QIL))
     => (to O from O' : output(QIL)) .
---)

  ---- help
  rl [crc-help] :
     < O : CRCBroker | none >
     (to O from O' : 'CRC`help`..@Command@)
     => < O : CRCBroker | none >
        (to O' from O : output(crc-help)) .

  ---- show critical pairs
  rl [showCRCCPs] :
    < O : CRCBroker | current : O' >
    (to O from O'' : ('show`critical`pairs`..@Command@))
    => < O : CRCBroker | current : O' >
       if O' == null-oid
       then (to O'' from O : output('No 'critical 'pairs 'to 'show.
                                    'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n))
       else (to O' from O'' : ('show`critical`pairs`..@Command@))
       fi .
  rl [showCRCCPs] :
    < O : CRCBroker | current : O' >
    (to O from O'' : ('show`all`critical`pairs`..@Command@))
    => < O : CRCBroker | current : O' >
       if O' == null-oid
       then (to O'' from O : output('No 'critical 'pairs 'to 'show.
                                    'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n))
       else (to O' from O'' : ('show`all`critical`pairs`..@Command@))
       fi .

  rl [showCRCCPs] :
    < O : CRC | module : M, cps : CPS >
    (to O from O' : ('show`critical`pairs`..@Command@))
    => < O : CRC | module : M, cps : CPS >
       genShowCPsMsg(O', O, M, CPS, '=, false) .
  rl [showCRCCPs] :
    < O : CRC | module : M, cps : CPS >
    (to O from O' : ('show`all`critical`pairs`..@Command@))
    => < O : CRC | module : M, cps : CPS >
       genShowCPsMsg(O', O, M, CPS, '=, true) .

  op genShowCPsMsg : Oid Oid Module CritPairSet Qid Bool -> Msg .
  ---- Oid to
  ---- Oid from
  ---- Module module for which the cps were generated
  ---- CritPairSet (all) cps to show
  ---- Qid '= or '=> depending on whether the cps are from the CRC or from the ChC
  ---- Bool true means only pending cps are to be consider; false means all
  eq genShowCPsMsg(O''', O', M, CPS, QI, B)
    = to O''' from O' :
        output(
          if CPS == none or ((not B) and pendingCPs(CPS) == none)
          then 'There 'are 'no 'critical 'pairs. '\n
          else (if B
                then 'These 'are 'all 'the 'critical 'pairs: '\o '\n
                else 'The 'following 'critical 'pairs 'cannot 'be 'joined: '\o '\n
                fi
                eMetaPrettyPrint(M, QI, CPS, B))
          fi) .

  ---- show membership assertions
  rl [showCRCMAs] :
    < O : CRCBroker | current : O' >
    (to O from O'' : ('show`membership`assertions`..@Command@))
    => < O : CRCBroker | current : O' >
       (to O' from O'' : ('show`membership`assertions`..@Command@)) .
  rl [showCRCMAs] :
    < O : CRCBroker | current : null-oid >
    (to O from O' : ('show`membership`assertions`..@Command@))
    => < O : CRCBroker | current : null-oid >
       (to O' from O : output('No 'membership 'assertions 'to 'show.
                              'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n)) .
  rl [showCRCMAs] :
    < O : CRCBroker | current : O' >
    (to O from O'' : ('show`all`membership`assertions`..@Command@))
    => < O : CRCBroker | current : O' >
       (to O' from O'' : ('show`all`membership`assertions`..@Command@)) .
  rl [showCRCMAs] :
    < O : CRCBroker | current : null-oid >
    (to O from O' : ('show`all`membership`assertions`..@Command@))
    => < O : CRCBroker | current : null-oid >
       (to O' from O : output('No 'membership 'assertions 'to 'show.
                              'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n)) .

  rl [showCRCMAs] :
    < O : CRC | module : M, mas : MAS >
    (to O from O' : ('show`membership`assertions`..@Command@))
    => < O : CRC | module : M, mas : MAS >
       genShowMAsMsg(O', O, M, MAS, false) .
  rl [showCRCMAs] :
    < O : CRC | module : M, mas : MAS >
    (to O from O' : ('show`all`membership`assertions`..@Command@))
    => < O : CRC | module : M, mas : MAS >
       genShowMAsMsg(O', O, M, MAS, true) .

  op genShowMAsMsg : Oid Oid Module MembAssertSet Bool -> Msg .
  ---- Oid to
  ---- Oid from
  ---- Module module for which the mas were generated
  ---- MembAssertSet (all) mas to show
  ---- Bool true means only pending mas are to be consider; false means all
  eq genShowMAsMsg(O''', O', M, MAS, B)
    = to O''' from O' :
        output(
          if MAS == none or ((not B) and pendingMAs(MAS) == none)
          then 'There 'are 'no 'membership 'assertions. '\n
          else ('The 'following 'membership 'assertions 'must 'be 'proved: '\o '\n
                eMetaPrettyPrint(M, MAS, B))
          fi) .

  rl [crc-show-state] :
    < O : CRC | module : M >
    to O from O' : printState
    => < O : CRC | module : M >
       to O' from O : state(
         '- 'Church-Rosser 'check 'for eMetaPrettyPrint(getName(M)) ': '\n
           makeCRCmessage(< O : CRC | module : M >, Church-Rosser)) .

  sort CRCcheckType .
  ops confluence sort-decreasingness Church-Rosser : -> CRCcheckType .

  op makeCRCmessage : Object CRCcheckType -> QidList .
  eq makeCRCmessage(< O : CRC | module : M, cps : CPS, cp-reg : CPReg, requester : OS,
                       terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >, Church-Rosser)
    = makeCRCmessage(< O : CRC | module : M, cps : CPS, cp-reg : CPReg, requester : OS,
                       terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >, confluence)
      makeCRCmessage(< O : CRC | module : M, cps : CPS, cp-reg : CPReg, requester : OS,
                       terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >, sort-decreasingness)
      if (CPS == none or (3B' == true and 3B == true)) and 3B'' == true
      then if CPReg == empty
           then mfe-success('The 'module 'is 'therefore 'Church-Rosser.) '\n
                ---- (to OS \ TS["MFE"] from O : module M is Church-Rosser)
           else mfe-success('The 'module 'is 'therefore 'ground-Church-Rosser.) '\n
                ---- (to OS \ TS["MFE"] from O : module M is ground-Church-Rosser)
           fi
      else nil
      fi .
  eq makeCRCmessage(< O : CRC | module : M, cps : CPS, terminating : 3B, locally-confluent : 3B' >, confluence) ---- confluence-requester : OS,
    = if CPS == none
      then 'There 'are 'no 'critical 'pairs. '\n
           '\b 'The 'specification 'is 'confluent. '\o '\n
      else if 3B' == true
           then 'All 'critical 'pairs 'have 'been 'joined. '\n
                '\b 'The 'specification 'is 'locally-confluent. '\o '\n
                if 3B == true
                then 'The 'specification 'is 'terminating '`, '\s 'and 'therefore 'confluent. '\o '\n
                     ---- (to OS \ TS["MFE"] from O : module M is confluent)
                else nil
                fi
           else '\b 'The 'following 'critical 'pairs 'must 'be 'proved 'joinable: '\o '\n
                eMetaPrettyPrint(M, '=, pendingCPs(CPS), false)
           fi
      fi .
  eq makeCRCmessage(< O : CRC | module : M, mas : MAS, sort-decreasing : 3B'' >, sort-decreasingness) ---- , sort-decreasingness-requester : OS
    = if 3B'' == true
      then 'The 'module 'is 'sort-decreasing. '\n
           ---- (to OS \ TS["MFE"] from O : module M is sort-decreasing)
      else if 3B'' == false
           then 'The 'module 'has 'been 'shown 'non-sort-decreasing. '\n
           else '\n 'The 'following 'proof 'obligations 'must 'be 'checked 'for 'sort-decreasingness: '\n
                    eMetaPrettyPrint(M, MAS, false)
           fi
      fi .

  op makeCRCmessage : Set{Oid} Object CRCcheckType -> Configuration .
  eq makeCRCmessage(OS, < O : CRC | module : M, cps : CPS, cp-reg : CPReg,
                       terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >, Church-Rosser)
    = if (CPS == none or (3B' == true and 3B == true)) and 3B'' == true
      then if CPReg == empty
           then (to OS from O : module getName(M) is Church-Rosser)
           else (to OS from O : module getName(M) is ground-Church-Rosser)
           fi
      else none
      fi .
  eq makeCRCmessage(OS, < O : CRC | module : M, cps : CPS, terminating : 3B, locally-confluent : 3B' >, confluence)
    = if CPS == none
      then (to OS from O : module getName(M) is confluent)
      else if 3B' == true
           then if 3B == true
                then (to OS from O : module getName(M) is confluent)
                else (to OS from O : module getName(M) is locally-confluent)
                fi
           else none
           fi
      fi .
  eq makeCRCmessage(OS, < O : CRC | module : M, mas : MAS, sort-decreasing : 3B'' >, sort-decreasingness)
    = if 3B'' == true
      then (to OS from O : module getName(M) is sort-decreasing)
      else none
      fi .

  ---- These rules take the messages with the terms resulting from the parsing
  ---- and send messages with teh common syntax.
  ---- TODO: Once the controler get into the game the messages will contain qid lists to be parsed.
  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`Church-Rosser`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O' from O'' : check Church-Rosser M)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`Church-Rosser`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`Church-Rosser_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O' from O'' : check Church-Rosser M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`Church-Rosser_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`sort-decreasingness`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O' from O'' : check sort-decreasingness M)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`sort-decreasingness`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`sort-decreasingness_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O' from O'' : check sort-decreasingness M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`sort-decreasingness_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`confluence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O' from O'' : check confluence M)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`confluence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`confluence_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O' from O'' : check confluence M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : CRCBroker | none >
    (to O' from O'' : ('check`confluence_.[T]))
    => < O : MFE | db : DB >
       < O' : CRCBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  ---- Depending on whether a module with the name of the module has previously been
  ---- checked or not the module is directly checked or it is checked after
  ---- deleting proofs or pending goals on this module.
  ---- To support checks for confluence and sort-decreasingness, in addition of the
  ---- entire Church-Rosser check, without repeating code, we compute the complete
  ---- check in any of the three cases, but answer to the specific check. The rest
  ---- of the check is stored in a CRC for later consults.

  op crc : Module CRCcheckType -> MFEPublicMsgBody .

  eq < O : CRCBroker | none >
     (to O from O' : check Church-Rosser M)
    = < O : CRCBroker | none >
      (to O from O' : crc(M, Church-Rosser)) .
  eq < O : CRCBroker | none >
     (to O from O' : check confluence M)
    = < O : CRCBroker | none >
      (to O from O' : crc(M, confluence)) .
  eq < O : CRCBroker | none >
     (to O from O' : check sort-decreasingness M)
    = < O : CRCBroker | none >
      (to O from O' : crc(M, sort-decreasingness)) .

  crl [crc-check] :
    ---- a module with the same name (perhaps the same module) was previously checked
    < OCRC : CRCBroker | tools : TS, reg : ((MN |-> O), MNReg) >
    < O : CRC | original-module : M',
                  requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                  cps : CPS, mas : MAS, cp-reg : CPReg, ma-reg : MAReg >
    (to OCRC from O' : crc(M, CRCCT))
    => if M == M'
       then < OCRC : CRCBroker | tools : TS, reg : ((MN |-> O), MNReg) >
            < O : CRC | original-module : M',
                if CRCCT == Church-Rosser
                then requester : (OS, O'), confluence-requester : OS', sort-decreasingness-requester : OS''
                else if CRCCT == confluence
                     then requester : OS,
                          confluence-requester : (OS', O'),
                          sort-decreasingness-requester : OS''
                     else requester : OS,
                          confluence-requester : OS',
                          sort-decreasingness-requester : (OS'', O')
                     fi
                fi,
                cps : CPS, mas : MAS, cp-reg : CPReg, ma-reg : MAReg >
            makeCRCmessage((OS, O') \ TS["MFE"],
              < O : CRC | original-module : M',
                  requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                  cps : CPS, mas : MAS, cp-reg : CPReg, ma-reg : MAReg >, CRCCT)
            to TS["MFE"] from O :
                   output(
                     'Church-Rosser 'check 'for eMetaPrettyPrint(getName(M)) '\n
                     makeCRCmessage(< O : CRC | module : M', requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'', cps : CPS, mas : MAS, cp-reg : CPReg, ma-reg : MAReg >,
                       CRCCT))
       else ---- The CRC object is removed
            (to TS["MFE"] from OCRC :
               output('The 'CRC 'for eMetaPrettyPrint(getName(M)) 'has 'been 'reset. '\n))
            ---- all the proofs in the ITP must be removed (open and not open proofs)
            unregisterProofs(TS["ITP"], OCRC, CPS, CPReg)
            unregisterProofs(TS["ITP"], OCRC, MAS, MAReg)
            ---- the association of module name in the reg map is removed, the applyCRCResult
            ---- will add it again if the check goes fine
            applyCRCResult(O',
              < OCRC : CRCBroker | tools : TS, reg : MNReg >,
              CRCCT,
              $processCRCcheck(M),
              M)
       fi
    if MN = getName(M) .
  crl [crc-check] :
    ---- no module with the same name was previously checked
    < OCRC : CRCBroker | reg : MNReg >
    (to OCRC from O : crc(M, CRCCT))
    => applyCRCResult(O, < OCRC : CRCBroker | reg : MNReg >, CRCCT, $processCRCcheck(M), M)
    if not getName(M) in domain of MNReg .

  op applyCRCResult : Oid Object CRCcheckType CRCProcessResult Module -> Configuration .
  ---- generates the same object, the only difference being the requester kind to which the requester is added
 ceq applyCRCResult(O,
       < O' : CRCBroker | index : N, current : O'', reg : MNReg, tools : TS >,
       CRCCT,
       (M, CPS, MAS),
       M')
    ---- the index is increased, the new CRC becomes the current one, and the module name is registered
    = < O' : CRCBroker |
        index : s N,
        current : CRC(N),
        reg : ((getName(M') |-> CRC(N)), MNReg),
        tools : TS >
      Obj
      if O =/= TS["MFE"]
      then makeCRCmessage(O, Obj, CRCCT)
      else to TS["MFE"] from CRC(N) :
             output(if CRCCT == Church-Rosser then 'Church-Rosser
                    else if CRCCT == confluence then 'Concluence
                         else if CRCCT == sort-decreasingness then 'Sort-decreasingness
                              else nil
                              fi
                         fi
                    fi
                    'check 'for eMetaPrettyPrint(getName(M')) '\n
               makeCRCmessage(Obj, CRCCT))
      fi
    if Obj := < CRC(N) : CRC |
                requester : if CRCCT == Church-Rosser then O else empty fi,
                confluence-requester : if CRCCT == confluence then O else empty fi,
                sort-decreasingness-requester : if CRCCT == sort-decreasingness then O else empty fi,
                original-module : M', module : M, cps : CPS, mas : MAS, cp-reg : empty, ma-reg : empty,
                terminating : maybe,
                locally-confluent : if pendingCPs(CPS) == none then true else maybe fi,
                sort-decreasing : if pendingMAs(MAS) == none then true else maybe fi > .
  eq applyCRCResult(O, < O' : CRCBroker | tools : TS >, CRCCT, unsupported(St), M')
    = < O' : CRCBroker | tools : TS >
      to O from O' : output(mfe-error(tokenize(St) '\n)) .

  ---- trust

  rl [trust] :
    < O : CRCBroker | current : O', tools : TS >
    < O' : CRC | module : M, requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                   locally-confluent : 3B, sort-decreasing : 3B', terminating : 3B'' >
    (to O from O'' : ('trust`..@Command@))
    => < O : CRCBroker | current : O', tools : TS >
       < O' : CRC | module : M, requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                      locally-confluent : true, sort-decreasing : true, terminating : 3B'' >
       if 3B =/= true then to TS["MFE"] from O' : output('The 'module eMetaPrettyPrint(getName(M)) 'is 'trusted 'to 'be 'locally-confluent) else none fi
       if 3B' =/= true then to TS["MFE"] from O' : output('The 'module eMetaPrettyPrint(getName(M)) 'is 'trusted 'to 'be 'sort-decreasing) else none fi
       if 3B'' == true
       then (to OS from O' : module getName(M) is Church-Rosser)
            (to OS' from O' : module getName(M) is confluent)
            (to OS'' from O' : module getName(M) is sort-decreasing)
       else (to OS' from O' : module getName(M) is locally-confluent)
            (to OS'' from O' : module getName(M) is sort-decreasing)
       fi .

  ---- handling of messages submitting goals to from the CRC to the ITP and MTT

  rl [submitCRCPOs] :
    < O : CRCBroker | current : O', tools : TS >
    < O' : CRC | original-module : M, module : M', cps : CPS, mas : MAS, terminating : 3B >
    (to O from O'' : ('submit`..@Command@))
    => < O : CRCBroker | current : O', tools : TS >
       < O' : CRC | original-module : M, module : M', cps : CPS, mas : MAS, terminating : 3B >
       genToITPMsg(TS["ITP"], O'', O', M', CPS, '=)
       genToITPMsg(TS["ITP"], O'', O', M', MAS)
       if 3B == maybe then genToMTTMsg(TS["MTT"], O'', O', M) else none fi .

  op genToMTTMsg : Oid Oid Oid FModule -> Configuration .
  eq genToMTTMsg(O, O', O'', M)
    = (to O from O'' : check termination M functional part true)
      (to O' from O'' : output('The 'termination 'goal 'for 'the 'functional 'part 'of eMetaPrettyPrint(getName(M)) 'has 'been 'submitted 'to 'MTT. '\n)) .

  op eq : Module -> FModule .
  eq eq(mod MN is nil sorts SS . SSDS OPS MbS EqS RlS endm)
    = fmod MN is nil sorts SS . SSDS OPS MbS EqS endfm .

  ---- generates messages for each of the cps for both the requester and the itp
  ---- the last qid distinguish between = and =>
  op genToITPMsg : Oid Oid Oid Module CritPairSet Qid -> Configuration .
  eq genToITPMsg(O, O', O'', M, cp(Id, L, L', T, T', pending) CPS, QI)
    = if QI == '=
      then (to O from O'' : add-goal Id : M |- T v T' if nil)
           (to O' from O'' : output('The 'goal 'for 'critical 'pair qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      else (to O from O'' : add-goal Id : M |- T => T' if nil)
           (to O' from O'' : output('The 'goal 'for 'critical 'pair qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      fi
      genToITPMsg(O, O', O'', M, CPS, QI) .
  eq genToITPMsg(O, O', O'', M, ccp(Id, L, L', T, T', Cd, pending) CPS, QI)
    = if QI == '=
      then (to O from O'' : add-goal Id : M |- T v T' if Cd)
           (to O' from O'' : output('The 'goal 'for 'critical 'pair qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      else (to O from O'' : add-goal Id : M |- T => T' if Cd)
           (to O' from O'' : output('The 'goal 'for 'critical 'pair qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      fi
      genToITPMsg(O, O', O'', M, CPS, QI) .
  eq genToITPMsg(O, O', O'', M, CPS, QI) = none [owise] .

  ---- generates messages for each of the mas for both the requester and the itp
  op genToITPMsg : Oid Oid Oid Module MembAssertSet -> Configuration .
  eq genToITPMsg(O, O', O'', M, ma(Id, L, T, S, pending) MAS)
    = (to O from O'' : add-goal Id : M |- T : S if nil)
      (to O' from O'' : output('The 'goal 'for 'membership 'assertion qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      genToITPMsg(O, O', O'', M, MAS) .
  eq genToITPMsg(O, O', O'', M, cma(Id, L, T, S, Cd, pending) MAS)
    = (to O from O'' : add-goal Id : M |- T : S if Cd)
      (to O' from O'' : output('The 'goal 'for 'membership 'assertion qid(Id) 'has 'been 'submitted 'to 'ITP. '\n))
      genToITPMsg(O, O', O'', M, MAS) .
  eq genToITPMsg(O, O', O'', M, MAS) = none [owise] .

  ---- As response to a add-goal message the ITP sends a goal registered as message,
  ---- since informing on the id that it is going to associate to the submitted goal.
  ---- We keep these associations in the map in the reg attribute of the corresponding
  ---- CRC object. Notice that the add-goal message was sent by a CRC object (not the
  ---- broker), and the asnwer is received by this object as well.
  ---- TODO registered-as messages could not correspond to .
  crl [registered] :
    < O : CRC | cp-reg : Reg, cps : (CP CPS) >
    (to O from O' : goal Id registered-as Id')
    => < O : CRC | cp-reg : insert(Id', Id, Reg), cps : (CP CPS) >
    if getId(CP) = Id .
  crl [registered] :
    < O : CRC | ma-reg : Reg, mas : (MA MAS) >
    (to O from O' : goal Id registered-as Id')
    => < O : CRC | ma-reg : insert(Id', Id, Reg), mas : (MA MAS) >
    if getId(MA) = Id .

  ---- Once a goal is proven in the ITP it sends a goal proved message.
  rl [cp-proved-joinable] :
    < O''' : CRCBroker | tools : TS >
    < O : CRC | requester : OS, confluence-requester : OS',
                  module : M, cp-reg : (Id |-> Id', Reg), cps : CPS,
                  terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >
    (to O from O' : goal Id proved)
    => < O''' : CRCBroker | tools : TS >
       (to TS["MFE"] from O : output('The 'critical 'pair qid(Id') 'has 'been 'discharged. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(mark(Id', CPS, proved)) == none
       then < O : CRC | requester : OS, confluence-requester : OS',
                          module : M, cp-reg : (Id |-> Id', Reg), cps : mark(Id', CPS, proved),
                          terminating : 3B, locally-confluent : true, sort-decreasing : 3B'' >
            if (3B == true)
            then if 3B'' == true
                 then (to OS from O''' : module getName(M) is ground-Church-Rosser)
                 else (to OS' from O''' : module getName(M) is ground-confluent)
                 fi
            else none
            fi
       else < O : CRC | requester : OS, confluence-requester : OS',
                          module : M, cp-reg : (Id |-> Id', Reg), cps : mark(Id', CPS, proved),
                          terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >
       fi .
  rl [ma-discharged] :
    < O''' : CRCBroker | tools : TS >
    < O : CRC | requester : OS, sort-decreasingness-requester : OS',
                  module : M, cps : CPS, ma-reg : (Id |-> Id', Reg), mas : MAS,
                  terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >
    (to O from O' : goal Id proved)
    => < O''' : CRCBroker | tools : TS >
       (to TS["MFE"] from O : output('The 'membership 'assertion qid(Id') 'has 'been 'discharged. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingMAs(mark(Id', MAS, proved)) == none
       then < O : CRC | requester : OS, sort-decreasingness-requester : OS',
                          module : M, cps : CPS, ma-reg : (Id |-> Id', Reg), mas : mark(Id', MAS, proved),
                          terminating : 3B, locally-confluent : 3B', sort-decreasing : true >
            (to OS' from O''' : module getName(M) is ground-sort-decreasing)
            if 3B == true and 3B' == true
            then (to OS from O''' : module getName(M) is ground-Church-Rosser)
            else none
            fi
       else < O : CRC | requester : OS, sort-decreasingness-requester : OS',
                          module : M, cps : CPS, ma-reg : (Id |-> Id', Reg), mas : mark(Id', MAS, proved),
                          terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >
       fi .

  ---- Once a module is proven terminating in the MTT it sends a module-is-terminating message.
  ---- A similar rule should be added for the compelte module
  rl [terminating] :
    < O : CRC | requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                  module : M, cps : CPS, cp-reg : CPReg, ma-reg : MAReg, mas : MAS,
                  terminating : 3B, locally-confluent : 3B', sort-decreasing : 3B'' >
    < O' : CRCBroker | tools : TS >
    (to O from O'' : module MN is terminating functional part true)
    => < O' : CRCBroker | tools : TS >
       < O : CRC | requester : OS, confluence-requester : OS', sort-decreasingness-requester : OS'',
                  module : M, cps : CPS, cp-reg : CPReg, ma-reg : MAReg, mas : MAS,
                  terminating : true, locally-confluent : 3B', sort-decreasing : 3B'' >
       (to TS["MFE"] from O' : output('The 'functional 'part 'of 'module eMetaPrettyPrint(MN) 'has 'been 'checked 'terminating. '\n))
       ---- if the proof has been completed it informs the requester
       if 3B' == true and 3B'' == true
       then if CPReg == empty and MAReg == empty
            then (to OS from O' : module getName(M) is Church-Rosser)
                 (to TS["MFE"] from O' : output(mfe-success('The 'module 'is 'therefore 'Church-Rosser. '\n)))
            else (to OS from O' : module getName(M) is ground-Church-Rosser)
                 (to TS["MFE"] from O' : output(mfe-success('The 'module 'is 'therefore 'ground-Church-Rosser. '\n)))
            fi
       else if 3B' == true
            then if CPReg == empty
                 then (to OS from O' : module getName(M) is confluent)
                 else (to OS from O' : module getName(M) is ground-confluent)
                 fi
            else none
            fi
       fi .

  --- Free constructors are not required by the CRC
  rl [free-constructors] :
    < O' : CRC | none >
    (to O' from O : module MN has free equational constructors)
    => < O' : CRC | none > .

  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is ground-Church-Rosser)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'ground 'Church-Rosser. '\n))) .
  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is Church-Rosser)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'Church-Rosser. '\n))) .

  ---- TODO The declaration of the unregisterdProofs in the crchc file.
  ---- TODO If a module was checked when a ccr command arrives the pending proofs
  ---- TODO must be unregistered. We wanted to keep the behavior of the CRC in the
  ---- TODO crchc file, but there we don't know the messages to be sent to the prover.
  ---- TODO We should either move all the rules here, or include the file with the
  ---- TODO messages there.
  eq unregisterProofs(O, O', cp(Id, L, L', T, T', CPStat) CPS, (Id' |-> Id, CPReg))
    = (to O from O' : unregister-goal Id')
      unregisterProofs(O, O', CPS, CPReg) .
  eq unregisterProofs(O, O', ccp(Id, L, L', T, T', Cd, CPStat) CPS, (Id' |-> Id, CPReg))
    = (to O from O' : unregister-goal Id')
      unregisterProofs(O, O', CPS, CPReg) .
  eq unregisterProofs(O, O', ma(Id, L, T, S, MAStat) MAS, (Id' |-> Id, MAReg))
    = (to O from O' : unregister-goal Id')
      unregisterProofs(O, O', MAS, MAReg) .
  eq unregisterProofs(O, O', cma(Id, L, T, S, Cd, MAStat) MAS, (Id' |-> Id, MAReg))
    = (to O from O' : unregister-goal Id')
      unregisterProofs(O, O', MAS, MAReg) .
  eq unregisterProofs(O, O', CPS, CPReg) = none [owise] .
  eq unregisterProofs(O, O', MAS, MAReg) = none [owise] .
endom

--------------------------------------------------------------------------------
--- MFE-ChC
--------------------------------------------------------------------------------
omod MFE-ChC is
  inc MFE-CRC .
  pr ChC-BANNER .

  class ChCBroker .
  subclass ChCBroker < Tool .

  class ChC | ground : Bool, Church-Rosser : 3Bool, sufficiently-complete : 3Bool .
  subclass ChC < Goal .

  op ChC : Nat -> Oid .

  op init-chc : Map{ToolName, Oid} -> Configuration [ctor] .

  vars O O' O'' O''' O4 O5 OMFE OCRC OChC OITP OSCC OMTT : Oid .
  var  OS : Set{Oid} .
  var  MNReg : Map{ModuleName, Oid} .
  var  N : Nat .
  var  MN : ModuleName .
  vars QIL QIL' : QidList .
  var  T : Term .
  vars DB DB' : Database .
  vars M M' : Module .
  vars ME ME' : ModuleExpression .
  vars B B' B'' : Bool .
  vars 3B 3B' 3B'' 3B'''  : 3Bool .
  var  CP : CritPair .
  var  CPS : CritPairSet .
  vars Reg CPReg : Map{String, String} .
  vars Id Id' St : String .
  var  TS : Map{ToolName, Oid} .
  var  IL : ImportList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .

  ---- initialization
  rl init-chc(TS)
    => < TS["ChC"] : ChCBroker | grammar : ChC-GRAMMAR, tools : TS, current : null-oid, index : 0, reg : empty > .

  op ChC-GRAMMAR : -> FModule .
  eq ChC-GRAMMAR = addImports((including 'ChC-SIGN .), BUBBLES) .

  ---- help
  rl [chc-help] :
     < O : ChCBroker | none >
     (to O from O' : 'ChC`help`..@Command@)
     => < O : ChCBroker | none >
        (to O' from O : output(chc-help)) .

  ---- show critical pairs
  rl [showChCCPs] :
    < O : ChCBroker | current : O' >
    (to O from O'' : ('show`critical`pairs`..@Command@))
    => < O : ChCBroker | current : O' >
       if O' == null-oid
       then (to O'' from O : output('No 'critical 'pairs 'to 'show.
                                    'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n))
       else (to O' from O'' : ('show`critical`pairs`..@Command@))
       fi .
  rl [showChCCPs] :
    < O : ChCBroker | current : O' >
    (to O from O'' : ('show`all`critical`pairs`..@Command@))
    => < O : ChCBroker | current : O' >
       if O' == null-oid
       then (to O'' from O : output('No 'critical 'pairs 'to 'show.
                                    'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n))
       else (to O' from O'' : ('show`all`critical`pairs`..@Command@))
       fi .

  rl [showChCCPs] :
    < O : ChC | module : M, cps : CPS >
    (to O from O' : ('show`critical`pairs`..@Command@))
    => < O : ChC | module : M, cps : CPS >
       genShowCPsMsg(O', O, M, CPS, '=>, false) .
  rl [showChCCPs] :
    < O : ChC | module : M, cps : CPS >
    (to O from O' : ('show`all`critical`pairs`..@Command@))
    => < O : ChC | module : M, cps : CPS >
       genShowCPsMsg(O', O, M, CPS, '=>, true) .

  rl [chc-show-state] :
    < O : ChC | module : M, cps : CPS, ground : B,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''' >
    to O from O' : printState
    => < O : ChC | module : M, cps : CPS, ground : B,
                     terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''' >
       to O' from O : state(
         '- 'Coherence 'check 'for eMetaPrettyPrint(getName(M)) ': '\n
           if 3B'' == true
           then if B
                then 'The 'specification 'is 'ground 'coherent. '\n
                else 'The 'specification 'is 'coherent. '\n
                fi
           else if 3B'' == false
                then if B
                     then 'The 'specification 'is 'not 'ground 'coherent. '\n
                     else 'The 'specification 'is 'not 'coherent. '\n
                     fi
                else 'There 'are qid(string(| pendingCPs(CPS) |, 10)) 'pending 'cps. '\n
                     if 3B == maybe
                     then 'The 'specification 'has 'not 'been 'proved 'terminating. '\n
                     else 'The 'specification 'is if 3B == true then nil else 'not fi 'terminating. '\n
                     fi
                     if 3B' == maybe
                     then 'The 'Church-Rosser 'property 'has 'not 'been 'proved. '\n
                     else 'The 'specification 'is if 3B' == true then nil else 'not fi 'Church-Rosser '\n
                     fi
                     if 3B''' == maybe
                     then 'Sufficient 'completeness 'has 'not 'been 'proved. '\n
                     else 'The 'specification 'is if 3B' == true then nil else 'not fi 'Sufficiently-Complete '\n
                     fi
                fi
           fi) .

  ---- check coherence and ground coherence
  eq (to O from O' : ('cch`..@Command@))
    = (to O from O' : ('check`coherence`..@Command@)) .
  eq (to O from O' : ('cch_.[T]))
    = (to O from O' : ('check`coherence_.[T])) .
  eq (to O from O' : ('cgch`..@Command@))
    = (to O from O' : ('check`ground`coherence`..@Command@)) .
  eq (to O from O' : ('cgch_.[T]))
    = (to O from O' : ('check`ground`coherence_.[T])) .

  crl
    < O : MFE | db : DB, default : MN >
    < O' : ChCBroker | none >
    (to O' from O'' : ('check`coherence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : ChCBroker | none >
       (to O' from O'' : check coherence M ground: false)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`coherence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : ChCBroker | none >
       (to O5 from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`coherence_.[T]))
    => < O : MFE | db : DB >
       < O' : ChCBroker | none >
       (to O' from O5 : check coherence M ground: false)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`coherence_.[T]))
    => < O : MFE | db : DB >
       < O' : ChCBroker | none >
       (to O5 from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  crl
    < O : MFE | db : DB, default : MN >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`ground`coherence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : ChCBroker | none >
       (to O' from O5 : check coherence M ground: true)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`ground`coherence`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : ChCBroker | none >
       (to O5 from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`ground`coherence_.[T]))
    => < O : MFE | db : DB >
       < O' : ChCBroker | none >
       (to O' from O5 : check coherence M ground: true)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : ChCBroker | none >
    (to O' from O5 : ('check`ground`coherence_.[T]))
    => < O : MFE | db : DB >
       < O' : ChCBroker | none >
       (to O5 from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

 crl [chc-check] :
    ---- a module with the same name (perhaps the same module) was previously checked
    < O : ChCBroker | tools : TS, reg : ((MN |-> O'), MNReg) >
    < O' : ChC | original-module : M', requester : OS, cps : CPS, cp-reg : CPReg, coherent : 3B, ground : B' >
    (to O from O'' : check coherence M ground: B)
    => if B == B' and-then M == M' ---- if the module is the same and the kind of proof is also the same we leave the proof as it was
       then < O : ChCBroker | tools : TS, reg : ((MN |-> O'), MNReg) >
            < O' : ChC | original-module : M', requester : (OS, O''), cps : CPS, cp-reg : CPReg, coherent : 3B, ground : B' >
            if 3B == true
            then if B
                 then (to O'' from O' : module getName(M) is ground-coherent)
                 else (to O'' from O' : module getName(M) is coherent)
                 fi
            else (to TS["MFE"] from O : output('The 'ChC 'proof 'for eMetaPrettyPrint(getName(M)) 'is 'still 'open. '\n))
            fi
       else ---- The ChC object is removed
            (to TS["MFE"] from O : output('The 'ChC 'for eMetaPrettyPrint(getName(M)) 'has 'been 'reset. '\n))
            ---- all the proofs in the ITP must be removed (open and not open proofs)
            unregisterProofs(TS["ITP"], O, CPS, CPReg)
            ---- the association of module name in the reg map is removed, the applyChCResult
            ---- will add it again if the check goes fine
            applyChCResult(O'', < O : ChCBroker | tools : TS, reg : MNReg >, $processChCcheck(M, B), M, B)
       fi
    if MN = getName(M) .
  crl [chc-check] :
    ---- no module with the same name was previously checked
    < O : ChCBroker | reg : MNReg >
    (to O from O' : check coherence M ground: B)
    => applyChCResult(O', < O : ChCBroker | reg : MNReg >, $processChCcheck(M, B), M, B)
    if not getName(M) in domain of MNReg .

  op applyChCResult : Oid Object ChCProcessResult Module Bool -> Configuration .
  eq applyChCResult(O, < O' : ChCBroker | index : N, current : O'', reg : MNReg, tools : TS >, (M, CPS), M', B)
    ---- the index is increased, the new ChC becomes the current one, and the module name is registered
    = < O' : ChCBroker | index : s N, current : ChC(N), reg : ((getName(M) |-> ChC(N)), MNReg), tools : TS >
      < ChC(N) : ChC | requester : O, original-module : M', module : M, cps : CPS, cp-reg : empty,
                       terminating : maybe, Church-Rosser : maybe, coherent : maybe, sufficiently-complete : maybe, ground : B >
      if TS["MFE"] == O
      then none
      else (to O from ChC(N) : if B then module getName(M) is ground-coherent else module getName(M) is coherent fi)
      fi
      to TS["MFE"] from ChC(N) :
        output(if B
               then '\b 'Ground 'coherence 'checking 'of '\o eMetaPrettyPrint(getName(M)) '\n
               else '\b 'Coherence 'checking 'of '\o eMetaPrettyPrint(getName(M)) '\n
               fi
               if pendingCPs(CPS) == none
               then 'All 'critical 'pairs 'have 'been 'rewritten 'and 'no 'rewrite 'with 'rules
                        'can 'happen 'at 'non-overlapping 'positions 'of 'equations 'left-hand 'sides. '\n
               else 'The 'following 'critical 'pairs 'cannot 'be 'rewritten: '\o '\n
                    eMetaPrettyPrint(M, '=>, pendingCPs(CPS), false)
               fi
               'The 'sufficient-completeness '`, ' 'termination 'and 'Church-Rosser 'properties 'must 'still 'be 'checked. '\n) .
  eq applyChCResult(O, < O' : ChCBroker | tools : TS >, unsupported(St), M, B)
    = < O' : ChCBroker | tools : TS >
      to O from O' : output(mfe-error(tokenize(St))) .
  eq applyChCResult(O, < O' : ChCBroker | index : N, current : O'', reg : MNReg, tools : TS >, noncoherent(M, QIL), M', B)
    = < O' : ChCBroker | index : s N, current : ChC(N), reg : ((getName(M) |-> ChC(N)), MNReg), tools : TS >
      < ChC(N) : ChC | requester : O, original-module : M', module : M, cps : none, cp-reg : empty, terminating : maybe, Church-Rosser : maybe, sufficiently-complete : maybe, coherent : false, ground : B >
      to O from O' : output(QIL) .

  rl [submitChCPOs] :
    < O : ChCBroker | current : O', tools : TS > ---- itp : O'', mtt : O''', crc : O4
    < O' : ChC | original-module : M, module : M', cps : CPS, terminating : 3B, Church-Rosser : 3B', sufficiently-complete : 3B''', coherent : 3B'' >
    (to O from O5 : ('submit`..@Command@))
    => < O : ChCBroker | current : O', tools : TS >
       < O' : ChC | original-module : M, module : M', cps : CPS, terminating : 3B, Church-Rosser : 3B', sufficiently-complete : 3B''', coherent : 3B'' >
       if 3B'' == maybe
       then genToITPMsg(TS["ITP"], O5, O', M', CPS, '=)
            if 3B == maybe then genToMTTMsg(TS["MTT"], O5, O', M) else none fi
            if 3B' == maybe then genToCRCMsg(TS["CRC"], O5, O', M) else none fi
            if 3B''' == maybe then genToSCCMsg(TS["SCC"], O5, O', M) else none fi
       else none
       fi .

  op genToCRCMsg : Oid Oid Oid Module -> Configuration .
  eq genToCRCMsg(O, O', O'', M)
    = (to O from O'' : check Church-Rosser M)
      (to O' from O'' : output('The 'Church-Rosser 'goal 'for eMetaPrettyPrint(getName(M)) 'has 'been 'submitted 'to 'CRC. '\n)) .

  op genToSCCMsg : Oid Oid Oid Module -> Configuration .
  eq genToSCCMsg(O, O', O'', M)
    = (to O from O'' : check sc M)
      (to O' from O'' : output('The 'Sufficient-Completeness 'goal 'for eMetaPrettyPrint(getName(M)) 'has 'been 'submitted 'to 'SCC. '\n)) .

  crl [registered] :
    < O : ChC | cp-reg : Reg, cps : (CP CPS) >
    (to O from O' : goal Id registered-as Id')
    => < O : ChC | cp-reg : insert(Id', Id, Reg), cps : (CP CPS) >
    if getId(CP) = Id .

  ---- Once a critical pair is proven joinable a message is sent.
  rl [proved] :
    < O : ChC | requester : OS, module : M, cp-reg : (Id |-> Id', Reg), cps : CPS,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
    < O'' : ChCBroker | tools : TS >
    (to O from O' : goal Id proved)
    => < O'' : ChCBroker | tools : TS >
       (to TS["MFE"] from O : output('The 'critical 'pair qid(Id') 'has 'been 'discharged. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(mark(Id', CPS, proved)) == none and 3B == true and 3B' == true and (3B''' == true or not B)
       then (to OS from O'' : module getName(M) is ground-coherent)
            < O : ChC | requester : OS, module : M, cp-reg : (Id |-> Id', Reg), cps : mark(Id', CPS, proved),
                          terminating : 3B, Church-Rosser : 3B', coherent : true, sufficiently-complete : 3B''', ground : true >
       else < O : ChC | requester : OS, module : M, cp-reg : (Id |-> Id', Reg), cps : mark(Id', CPS, proved),
                          terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : true >
       fi .

  ---- Once a module is proven either sufficiently-complete, terminating or Church-Rosser message is sent.
  rl [terminating] :
    < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
    < O' : ChCBroker | tools : TS >
    (to O from O'' : module MN is terminating functional part true)
    => < O' : ChCBroker | tools : TS >
       (to TS["MFE"] from O' : output('The 'functional 'part 'of 'module eMetaPrettyPrint(MN) 'has 'been 'checked 'terminating. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(CPS) == none and 3B' == true
       then if B
            then if 3B''' == true
                 then (to OS from O' : module getName(M) is ground-coherent)
                      < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : true, Church-Rosser : 3B', coherent : true, sufficiently-complete : 3B''', ground : B >
                 else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : true, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
                 fi
            else if Reg == empty
                 then (to OS from O' : module getName(M) is coherent)
                      < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : true, Church-Rosser : 3B', coherent : true, sufficiently-complete : 3B''', ground : B >
                 else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : true, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
                 fi
            fi

       else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : true, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
       fi .
  rl [Church-Rosser] :
    < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
    < O' : ChCBroker | tools : TS >
    (to O from O'' : module MN is Church-Rosser)
    => < O' : ChCBroker | tools : TS >
       (to TS["MFE"] from O' : output('The 'module eMetaPrettyPrint(MN) 'has 'been 'checked 'Church-Rosser. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(CPS) == none and 3B == true
       then if B
            then if 3B''' == true
                 then (to OS from O' : module getName(M) is ground-coherent)
                      < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : true, coherent : true, sufficiently-complete : 3B''', ground : B >
                 else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : true, coherent : 3B'', sufficiently-complete : 3B''', ground : B >
                 fi
            else if Reg == empty
                 then (to OS from O' : module getName(M) is coherent)
                      < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : true, coherent : true, sufficiently-complete : 3B''', ground : B >
                 else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : true, coherent : 3B'', sufficiently-complete : 3B''', ground : B >
                 fi
            fi
       else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : true, coherent : 3B'', sufficiently-complete : 3B''', ground : B >
       fi .
  rl [Church-Rosser] :
    < O : ChC | requester : OS, module : M, cps : CPS,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
    < O' : ChCBroker | tools : TS >
    (to O from O'' : module MN is ground-Church-Rosser)
    => < O' : ChCBroker | tools : TS >
       (to TS["MFE"] from O' : output('The 'module eMetaPrettyPrint(MN) 'has 'been 'checked 'ground-Church-Rosser. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(CPS) == none and 3B == true and 3B''' == true
       then (to OS from O' : module getName(M) is ground-coherent)
            < O : ChC | requester : OS, module : M, cps : CPS,
                          terminating : 3B, Church-Rosser : true, coherent : true, sufficiently-complete : 3B''', ground : true >
       else < O : ChC | requester : OS, module : M, cps : CPS,
                          terminating : 3B, Church-Rosser : true, coherent : 3B'', sufficiently-complete : 3B''', ground : true >
       fi .
  rl [sufficiently-complete] :
    < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                  terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : 3B''', ground : B >
    < O' : ChCBroker | tools : TS >
    (to O from O'' : module MN is sufficiently complete)
    => < O' : ChCBroker | tools : TS >
       (to TS["MFE"] from O' : output('The 'module eMetaPrettyPrint(MN) 'has 'been 'checked 'sufficiently-complete. '\n))
       ---- if the proof has been completed it informs the requester
       if pendingCPs(CPS) == none and 3B == true and 3B' == true
       then if B
            then (to OS from O' : module getName(M) is ground-coherent)
                  < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : 3B', coherent : true, sufficiently-complete : true, ground : B >
            else if Reg == empty
                 then (to OS from O' : module getName(M) is coherent)
                      < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : 3B', coherent : true, sufficiently-complete : true, ground : B >
                 else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : true, ground : B >
                 fi
            fi
       else < O : ChC | requester : OS, module : M, cps : CPS, cp-reg : Reg,
                          terminating : 3B, Church-Rosser : 3B', coherent : 3B'', sufficiently-complete : true, ground : B >
       fi .

  --- Free constructors are not required by the ChC
  rl [free-constructors] :
    < O' : ChC | none >
    (to O' from O : module MN has free equational constructors)
    => < O' : ChC | none > .

  --- Sort-decreasingness is not required by the ChC
  rl [sort-decreasingness] :
    < O' : ChC | none >
    (to O' from O : module MN is sort-decreasing)
    => < O' : ChC | none > .

  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is coherent)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'coherent. '\n))) .
  rl [out] :
    < O : MFE | none >
    (to O from O' : module MN is ground-coherent)
    => < O : MFE | none >
       (to O from O' : output(mfe-success('The 'module eMetaPrettyPrint(MN) 'is 'ground-coherent. '\n))) .
endom

---(
--------------------------------------------------------------------------------
--- MFE-ITP
--------------------------------------------------------------------------------
mod MFE-ITP is
  inc MFE-TOOL .
  inc MFE-CONTROLLER .
  pr ITP .
  inc ITP-EXTENDED-SYNTAX .
---  pr ITP-BANNER .

  op init-itp : Map{ToolName, Oid} -> Configuration [ctor] .

  vars O O' O'' OMFE OCRC OChC OITP OSCC OMTT : Oid .
  var  NeQIL : NeQidList .
  vars DB DB' : Database .
  var  Conf : Configuration .
  var  Cmd : Input .
  vars Name Name' Id Id' : String .
  var  M Mod Mod' : Module .
  vars T T' : Term .
  var  Cond : Condition .
  vars N N' : Nat .
  var  PS : ProofState .
  var  ITPMap : Map{Oid,String} .
  vars Msg QIL QIL' QIL'' : QidList .
  vars RP RP' : ResultPair .
  vars Sr S : Sort .
  var  Form : Formula .
  var  TS : Map{ToolName, Oid} .
  var  TN : ToolName .

  rl init-itp(TS)
    => < TS["ITP"] : ITPBroker | itp-count : 0, itp-default : null-itp, itp-map : empty > .

************************
*** ITP's Interface ****
*******************************************************
*** ITP's rules for incomming and outgoing messages ***
*******************************************************

-------------------------------------
---- Interaction with stdin input ---
-------------------------------------------------------------------------------
---- We add a rule so itp commands originating from the standard input --------
---- are compiled into messages and placed in the state for the itp broker ----
---- to interpret, with itp-stdin used as the originating user. ---------------
-------------------------------------------------------------------------------
 crl [itp-parse-cmd-stdin-null] :
   < OITP : ITPBroker | itp-default : null-itp >
   < O : MFE | db : DB >
   to OITP from O' : input(NeQIL)
   => < OITP : ITPBroker | itp-default : null-itp >
      < O : MFE | db : DB >
      (to OITP from O' : itp-cmd(Cmd))
      (to O' from OITP : input-parsed(NeQIL, true))
   if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
   /\ input(Cmd) := parse-cmd(itp-proof-def-atts, NeQIL, DB) .

 crl [itp-parse-cmd-stdin-non-null] :
   < OITP : ITPBroker | itp-default : O >
   < O : ITP | none >
   < O' : MFE | db : DB >
   to OITP from O' : input(NeQIL)
   => < OITP : ITPBroker | itp-default : O >
      < O : ITP | none >
      < O' : MFE | db : DB >
      (to OITP from O' : itp-cmd(Cmd))
      (to O' from OITP : input-parsed(NeQIL, true))
   if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
   ----/\ input(Cmd) := parse-cmd(Atts', NeQIL, DB) 
   .

 rl [itp-show-msg-stdin] :
   < O : ITPBroker | none >
   (to O' from O : itp-output(QIL))
   => < O : ITPBroker | none >
      to mfe from O : output(QIL) .

-----------------------------------------
---- Interaction with external tools ----
-----------------------------------------

---- successful add commands
---- BIGTODO Add support for system modules in the ITP

---- adds an equality goal
 crl [itp-add-goal-equality] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T = T' if Cond))
    => < O' : ITPBroker | none >
       (to O' from O : itp-cmd(new-goal Name : Mod' |- Form .))
    if M := toFModule(Mod)
    /\ module(Mod') := fixExternalModule(M)
    /\ Form := eqToFormula(ceq T = T' if Cond [none].) .

---- adds a membership goal
 crl [itp-add-goal-membership] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T : Sr if Cond))
    => < O' : ITPBroker | none >
       (to O' from O : itp-cmd(new-goal Name : Mod' |- Form .))
    if M := toFModule(Mod)
    /\ module(Mod') := fixExternalModule(M)
    /\ Form := mbToFormula(cmb T : Sr if Cond [none].) .

---- adds a joinability goal
 crl [itp-add-goal-joinability] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T v T' if Cond))
    => < O' : ITPBroker | none >
       (to O' from O : itp-cmd(new-goal Name : Mod' |- Form .))
    if M := toFModule(Mod)
    /\ module(Mod') := fixExternalModule(M)
    /\ Form := eqToFormula(ceq T = T' if Cond [none].) .

---- adds a rewrite goal
 crl [itp-add-goal-rewrite] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T => T' if Cond))
    => < O' : ITPBroker | none >
       (to O' from O : itp-cmd(new-goal Name : Mod' |- Form .))
    if M := toFModule(Mod)
    /\ module(Mod') := fixExternalModule(M)
    /\ Form := eqToFormula(ceq T = T' if Cond [none].) .

----
---- faulty commands
---- BIGTODO Add support for system modules in the ITP

---- the module is not handled by the ITP
 crl [itp-add-goal-equality-mod-parse-error] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T = T' if Cond))
    => < O' : ITPBroker | none >
       (to O from O' : failure-registering-goal Name because QIL')
    if M := toFModule(Mod)
    /\ parse-module-error(QIL') := fixExternalModule(M) .

---- the module is not handled by the ITP
 crl [itp-add-goal-membership-mod-parse-error] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T : Sr if Cond))
    => < O' : ITPBroker | none >
       (to O from O' : failure-registering-goal Name because QIL')
    if M := toFModule(Mod)
    /\ parse-module-error(QIL') := fixExternalModule(M) .

---- the module is not handled by the ITP
 crl [itp-add-goal-joinability-mod-parse-error] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T v T' if Cond))
    => < O' : ITPBroker | none >
       (to O from O' : failure-registering-goal Name because QIL')
    if M := toFModule(Mod)
    /\ parse-module-error(QIL') := fixExternalModule(M) .

---- the module is not handled by the ITP
 crl [itp-add-goal-rewrite-mod-parse-error] :
    < O' : ITPBroker | none >
    (to O' from O : (add-goal Name : Mod |- T => T' if Cond))
    => < O' : ITPBroker | none >
       (to O from O' : failure-registering-goal Name because QIL')
    if M := toFModule(Mod)
    /\ parse-module-error(QIL') := fixExternalModule(M) .

--------------------------------------------------------------------------
---- Conversion between internal ITP messages and public MFE messages ----
--------------------------------------------------------------------------
---- a goal has been registered successfully; if the requester of the goal
---- is itp-stdin, i.e., the standard input user the message is dropped;
---- otherwise it is converted into a public message for an external
---- tool to process.
  rl [itp-to-ext-goal-registered] :
    (to O from O' : itp-goal-registered(Name, Name'))
    => if O == itp-stdin
       then none
       else (to O from O' : goal Name registered-as Name')
       fi .

---- a goal has been prooved; if the requester of the goal
---- is itp-stdin, i.e., the standard input user the message is dropped;
---- otherwise it is converted into a public message for an external
---- tool to process.
  rl [itp-to-ext-goal-proved] :
    (to O from O' : itp-goal-proved(Name))
    => if O == itp-stdin
       then none
       else (to O from O' : goal Name proved)
       fi .

---- a goal has been requested to be unregistered by an external application;
  rl [itp-unregister-goal] :
    < O : ITPBroker | itp-default : itp(N), itp-map : (itp(N') |-> Id, ITPMap) >
    < itp(N') : ITP | none > (to O from O' : unregister-goal Id)
    => if N == N'
       then < O : ITPBroker | itp-default : null-itp, itp-map : ITPMap >
       else < O : ITPBroker | itp-default : itp(N), itp-map : ITPMap >
       fi .

---- outputs the current state of the ITP
  rl [itp-show-state] :
    < O : ITPBroker | none >
    (to O from O' : printState(TN))
    => < O : ITPBroker | none >
       (to O from O' : itp-show-state) .

  rl [itp-show-state] :
    < O : ITPBroker | itp-default : null-itp >
    (to O from O' : itp-show-state)
    => < O : ITPBroker | itp-default : null-itp >
       to O' from O : output('The 'state 'of 'the 'ITP 'is 'empty. '\n) .
 crl [itp-show-state] :
    < O : ITPBroker | itp-default : O' >
    < O' : ITP | none >
    (to O from O'' : itp-show-state)
    => < O : ITPBroker | itp-default : O' >
       < O' : ITP | none >
       to O'' from O : output(pretty-print-header '\n
                              pretty-print-itp-instance(< O' : ITP | none >, true)) ---- Camilo, what does the bool value mean?
                                                                                    ---- Paco, the bool value is used to activate/deactivate the use of bold face when printing the active/default/current goal
    if O =/= null-itp .

---- outputs the current goal of the ITP. This rule assumes that such goal
---- exists
 rl [itp-show-current-goal] :
    < OITP : ITPBroker | itp-default : O, tools : TS >
    < O : ITP | proofState : PS, defaultGoal : Name, mainGoal : Name' >
    (to itp-stdin from OITP : itp-show-current-goal)
    => < OITP : ITPBroker | itp-default : O, tools : TS >
       < O : ITP | proofState : PS, defaultGoal : Name, mainGoal : Name' >
       to TS["MFE"] from O : output(if PS == ps(nil)
                                     then 'Goal tokenize(Name') 'has 'been 'discharged 'already! '\n
                                     else meta-pretty-print(Name, PS)
                                     fi) .

  ---- in rules for the ITP
  ---- We try to maintain the existing rules just by checking that it is a
  ---- command for hte ITP, thus parsing twice. This should be changed.
  ---- [DEPRECATED] See rule 'itp-parse-cmd-stdin-null'

  rl [itp-exec-cmd] :
    [nil, < O : ITPBroker | none > Conf (to O from O' : itp-cmd(Cmd)) , QIL]
    => [nil, itp-exec(O', Cmd, < O : ITPBroker | none > Conf), QIL] .

  crl [itp-exec-error] :
    < OITP : ITPBroker | none >
    < O : MFE | db : DB >
    (to OITP from O' : input(NeQIL))
    => < OITP : ITPBroker | none >
       < O : MFE | db : DB >
       (to O' from OITP : output(Msg))
       (to O' from OITP : input-parsed(NeQIL, false))
    if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
    /\ input(Cmd) := parse-cmd(Atts, NeQIL, DB)
    /\ itp-error(Msg) := exec(Cmd) .
  crl [itp-exec-error-failure] :
    < OITP : ITPBroker | none >
    < O : MFE | db : DB >
    (to OITP from O' : input(NeQIL))
    => < OITP : ITPBroker | none >
       < O : MFE | db : DB >
       (to O' from OITP : output(
                             if getDefaultGoal(Atts) :: Goal
                             then 'Unable 'to 'interpret 'command. '\n
                             else 'The 'goal 'is 'not 'set.  'Please 'select 'a 'goal. '\n
                             fi))
       (to O' from OITP : input-parsed(NeQIL, false))
    if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
    /\ input(Cmd) := parse-cmd(Atts, NeQIL, DB)
    /\ exec(Cmd) :: ExecResult = false .

  crl [itp-parse-error] :
    < OITP : ITPBroker | none >
    < O : MFE | db : DB >
    (to OITP from O' : input(NeQIL))
    => < OITP : ITPBroker | none >
       < O : MFE | db : DB >
       (to O' from OITP : output(QIL'))
       (to O' from OITP : input-parsed(NeQIL, false))
    if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
    /\ parse-input-error(QIL') := parse-cmd(Atts, NeQIL, DB) .
  crl [itp-parse-error-null] :
    < OITP : ITPBroker | itp-default : null-itp >
    < O : MFE | db : DB >
    (to OITP from O' : input(NeQIL))
    => < OITP : ITPBroker | itp-default : null-itp >
       < O : MFE | db : DB >
       (to O' from OITP : output(QIL'))
       (to O' from OITP : input-parsed(NeQIL, false))
    if metaParse(itp-grammar, NeQIL, 'Input) : ResultPair
    /\ parse-input-error(QIL') := parse-cmd(itp-proof-def-atts, NeQIL, DB) .

   crl [itp-parse-error] :
     < OITP : ITPBroker | none >
     (to OITP from O' : input(NeQIL))
     => < OITP : ITPBroker | none >
        (to O' from OITP : input-parsed(NeQIL, false))
     if not metaParse(itp-grammar, NeQIL, 'Input) :: ResultPair .
endm
)
----------------------------
--- MFE-SCC ----------------
--- Completeness Checker ---
----------------------------
omod MFE-SCC is
----  pr BANNER .
  pr MFE-GLOBAL-VARS .
  inc MFE-TOOL .
  inc MFE-CONTROLLER .
  pr MFE-TEXT-STYLE .
  inc META-MODULE .
  pr CC .
  pr CC-BANNER .

  class SCCBroker .
  subclass SCCBroker < Tool .

  class SCC .
  subclass SCC < Goal .

  op init-scc : Map{ToolName, Oid} -> Configuration .

  vars O O' O'' O''' O4 O5 OMFE OCRC OChC OITP OSCC OMTT : Oid .
  vars OS OS' : Set{Oid} .
  vars DB DB' : Database .
  vars ME ME' : ModuleExpression .
  var  S : Sort .
  vars T T' : Term .
  var  TS : Map{ToolName, Oid} .
  vars QIL QIL' : QidList .
  vars M M' Mod Mod' : Module .
  var  Conf : Configuration .
  var  MNReg : Map{ModuleName, Oid} .
  var  CFCRes : CFCResult .
  var  SCCRes : SCCResult .
  vars isSound isComplete : Bool .
  vars B B' B'' : Bool .
  var  N : Nat .
  var  MN : ModuleName .

  op SCC-GRAMMAR : -> FModule .
  eq SCC-GRAMMAR
   = addImports((including 'CC-SIGN .), BUBBLES) .

  rl init-scc(TS)
    => < TS["SCC"] : SCCBroker |
         grammar : SCC-GRAMMAR,
         tools : TS,
         current : null-oid,
         index : 0,
         reg : empty > .

  -----------------------------------------------------------------
  --- Translation from user commands into MFE's public commands ---
  -----------------------------------------------------------------
  ---- help
  rl [scc-help] :
     < O : SCCBroker | none >
     (to O from O' : 'SCC`help`..@Command@)
     => < O : SCCBroker | none >
        (to O' from O : output(mfe-cc-help)) .

  op showStateSCC : Object -> QidList .
  eq showStateSCC( < O : SCC | module : M, sc-result : SCCRes, free-result : CFCRes,
                     eq-sound : isSound, eq-complete : isComplete, eq-terminating : B,
                     eq-sort-decreasing : B', trusted : B'' > )
   = auxShowStateSCC(M,SCCRes,CFCRes,isSound,isComplete,B,B',B'') .
  eq showStateSCC(OBJ:Object)
   = nil [owise] .
  op auxShowStateSCC : Module SCCResult CFCResult Bool Bool Bool Bool Bool -> QidList .
  eq auxShowStateSCC(M,SCCRes,CFCRes,isSound,isComplete,B,B',B'')
   = 'Sufficient 'completeness 'check 'for eMetaPrettyPrint(getName(M))
     if B''
     then 'trusted! '\n
     else '\n 'Completeness 'counter-examples:
          (if SCCRes == complete
           then 'none 'were 'found
           else if SCCRes == invalid-input
                then 'information 'not 'available
                else getCounterExampleTerm(M,SCCRes)
                fi
           fi)
          '\n 'Freeness 'counter-examples:
          (if CFCRes == free
           then 'none 'were 'found
           else if CFCRes == invalid-input
                then 'information 'not 'available
                else getCounterExampleTerm(M,CFCRes)
                fi
           fi)
          '\n 'Analysis:
          'it 'is (if isComplete then nil else 'not fi) 'complete 'and 'it 'is (if isSound then nil  else 'not fi) 'sound
          '\n 'Ground 'weak 'termination: (if B then nil else 'not fi) 'proved
          '\n 'Ground 'sort-decreasingness: (if B' then nil else 'not fi) 'proved '\n
    fi .

  op getCounterExampleTerm : Module SCCResult -> QidList .
  eq getCounterExampleTerm(M,counterexample(T,S))
   = '\m metaPrettyPrint(M, T, mixfix) '\o 'with 'sort '\m S '\o .
  op getCounterExampleTerm : Module CFCResult -> QidList .
  eq getCounterExampleTerm(M,cfc-counterexample(T,S))
   = '\m metaPrettyPrint(M, T, mixfix) '\o 'with 'sort '\m S '\o .

  ---- outputs the current state
  rl [scc-show-state] :
    < O : SCC | none >
    to O from O' : printState
    => < O : SCC | none >
       to O' from O : state(showStateSCC( < O : SCC | none > )) .

  crl [check-sc] :
    < O : MFE | db : DB >
    < O' : SCCBroker | none >
    (to O' from O5 : ('scc_.[T]))
    => < O : MFE | db : DB > < O' : SCCBroker | none >
       (to O' from O5 : check sc M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .

  crl [check-sc] :
    < O : MFE | db : DB > < O' : SCCBroker | none > (to O' from O5 : ('scc_.[T]))
    => < O : MFE | db : DB > < O' : SCCBroker | none >
       (to O5 from O' : output(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  crl [check-free] :
    < O : MFE | db : DB >
    < O' : SCCBroker | none >
    (to O' from O5 : ('free_.[T]))
    => < O : MFE | db : DB > < O' : SCCBroker | none > (to O' from O5 : check free M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .

  crl [check-free] :
    < O : MFE | db : DB > < O' : SCCBroker | none > (to O' from O5 : ('free_.[T]))
    => < O : MFE | db : DB > < O' : SCCBroker | none >
       (to O5 from O' : output(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  rl [submitSCCPOs] :
    < O : SCCBroker | current : O', tools : TS >
    < O' : SCC | module : M, eq-terminating : B, eq-sort-decreasing : B' >
    (to O from O'' : ('submit`..@Command@))
    => < O : SCCBroker | current : O', tools : TS >
       < O' : SCC | module : M, eq-terminating : B, eq-sort-decreasing : B' >
       if B then none else genToMTTMsg(TS["MTT"], O'', O', M) fi
       if B' then none else genToSDMsg(TS["CRC"], O'', O', M) fi .

 op genToMTTMsg : Oid Oid Oid Module -> Configuration .
 eq genToMTTMsg(O,O',O'',M)
  = (to O from O'' : check termination M functional part true)
    (to O' from O'' : output('The 'termination 'goal 'for 'the 'functional 'part 'of eMetaPrettyPrint(getName(M)) 'has 'been 'submitted 'to 'MTT. '\n)) .

 op genToSDMsg : Oid Oid Oid Module -> Configuration .
 eq genToSDMsg(O,O',O'',M)
  = (to O from O'' : check sort-decreasingness M)
    (to O' from O'' : output('The 'sort-decreasingness 'goal 'for eMetaPrettyPrint(getName(M)) 'has 'been 'submitted 'to 'CRC. '\n)) .

  -----------------------------------------
  --- Implementation of public commands ---
  -----------------------------------------
  crl [check-sc] :
    < O : SCCBroker | reg : MNReg >
    (to O from O' : check sc M)
    => if isParameterized?(M) or-else M :: STheory
       then < O : SCCBroker | reg : MNReg >
            (to O' from O : output(mfe-error('The 'SCC 'cannot 'check 'parameterized 'modules 'or 'theories. '\n)))
       else if ceta-hook
            then applyNewSCCResult(O', < O : SCCBroker | reg : MNReg >, processSCCheck(M))
            else applyNewSCCDummyResult(O', < O : SCCBroker | reg : MNReg >, M)
            fi
       fi
    if not getName(M) in domain of MNReg .
  crl [check-sc] :
    < O : SCCBroker | tools : TS, reg : ((MN |-> O''), MNReg) >
    < O'' : SCC |  module : M', requesters : OS >
    (to O from O' : check sc M)
    => if M == M'
       then < O : SCCBroker | tools : TS, reg : ((MN |-> O''), MNReg) >
            < O'' : SCC | module : M', requesters : (O',OS) >
           (to TS["MFE"] from O : output(showStateSCC( < O'' : SCC | module : M', requesters : (O',OS) > )))
       else < O : SCCBroker | tools : TS, reg : MNReg >
            (to O from O' : check sc M)
            ----c TODO: unregister SCC proofs
       fi
    if MN := getName(M) .

 --- applies the sufficient completeness result to the given broker
 --- by increasing the number of instances and registering the result
 --- in a SCC object
 --- PRE: it assumes that the name of the module is not in the domain
 --- of the map 'reg'
 op applyNewSCCResult : Oid Object SCCheckResult -> Configuration .
 eq applyNewSCCResult(O, < O' : SCCBroker | tools : TS, index : N, current : O'', reg : MNReg >,
     (M,SCCRes,CFCRes,isSound,isComplete))
  = < O' : SCCBroker | tools : TS, index : s N, current : SCC(N), reg : ((getName(M) |-> SCC(N)), MNReg) >
    < SCC(N) : SCC | requesters : O, module : M, sc-result : SCCRes, free-result : CFCRes, eq-sound : isSound, eq-complete : isComplete,
      eq-terminating : false, eq-sort-decreasing : false, trusted : false >
    to TS["MFE"] from O' : output(auxShowStateSCC(M,SCCRes,CFCRes,isSound,isComplete,false,false,false)) .

 --- This message is created assuming that the given module has been proved
 --- ground sort-decreassing and ground terminating
 op genSCCMsg : Oid Oid Set{Oid} Module SCCResult CFCResult Bool Bool Bool Bool -> Configuration .
 eq genSCCMsg(O,O',OS,M,complete,CFCRes,isSound,isComplete,true,true)
  =   if (isSound and isComplete)
      then
        if CFCRes == free
        then
          (to OS from O' : module getName(M) is sufficiently complete)
          (to OS from O' : module getName(M) has free equational constructors)
          (to mfe from O' :
            output(mfe-success('The 'functional 'module '\o getName(M) '\o 'is 'sufficiently
                              'complete 'and 'has 'free 'constructors. '\n)))
        else
          (to OS from O' : module getName(M) is sufficiently complete)
          (to O from O' :
            output(mfe-success('The 'functional 'module '\o getName(M) '\o 'is 'sufficiently
                              'complete. '\n)))
        fi
      else
        (to O from O' :
          output(mfe-warning('The 'functional 'module '\o getName(M) '\o 'is 'sufficiently
                             'complete 'and 'has 'free 'constructors. 'However`, 'module
                             '\o getName(M) '\o 'may 'still 'not 'be 'sufficiently 'complete
                             'or 'not 'have 'free 'constructors. '\n)))
      fi .
 eq genSCCMsg(O,O',OS,M,counterexample(T,S),CFCRes,isSound,isComplete,true,true)
  =   if isComplete
      then
        (to O from O' :
           output(mfe-failure('The 'term '\m metaPrettyPrint(M, T, mixfix) '\o ' 'is 'an
           'irreducible 'term 'with 'sort '\m S '\o 'in '\c getName(M) '\o
           'that 'does 'not 'have 'sort '\m S '\o 'in 'the 'constructor
           'subsignature. '\n)))
       else
           (to O from O' :
              output(mfe-warning('The 'term '\m metaPrettyPrint(M, T, mixfix) '\o 'was 'found
                                 'to 'be 'a 'counterexample;  'since 'the 'analysis 'is 'incomplete
                                 '`, ' 'it 'may 'not 'be 'a 'real 'counterexample. '\n)))
      fi .
  eq genSCCMsg(O,O',OS,M,SCCRes,CFCRes,isSound,isComplete,B,B')
  = none [owise] .

 ---- Sends messages to the tools that have requested the scc check
 ---- for the given proof object when the property and its associated
 ---- proof obligations have been proved, and also sends messages to
 ---- the those objects when the constructors are free.
 ---- It also prints in the terminal an informative message.
  op checkSCCSuccess : Oid Oid Configuration -> Configuration .
  eq checkSCCSuccess( O', O,
       < O : SCC | module : M, eq-sort-decreasing : B, eq-terminating : B', trusted : false, requesters : OS,
         sc-result : SCCRes, free-result : CFCRes, eq-sound : isSound, eq-complete : isComplete > )
   = genSCCMsg(O', O, (OS \ O'), M, SCCRes, CFCRes, isSound, isComplete, B, B') .
  eq checkSCCSuccess(O',O, Conf) = none [owise] .

 ---- Message generation when the SCC is not available
 op applyNewSCCDummyResult : Oid Object Module -> Configuration .
 eq applyNewSCCDummyResult(O, < O' : SCCBroker | tools : TS, index : N, current : O'', reg : MNReg >, M)
  = < O' : SCCBroker | tools : TS, index : s N, current : SCC(N), reg : ((getName(M) |-> SCC(N)), MNReg) >
    < SCC(N) : SCC | requesters : O, module : M, sc-result : invalid-input, free-result : invalid-input,
      eq-sound : true, eq-complete : true, eq-terminating : false, eq-sort-decreasing : false, trusted : false >
    genSCCDummyMsg(TS["MFE"],O',M) . ---- This message must be sent to the user, not to other tools
 op genSCCDummyMsg : Oid Oid Module -> Msg .
 eq genSCCDummyMsg(O,O',M)
  = to O from O' :
    output(mfe-warning('The 'sufficient 'completeness 'checker 'is 'not
      'fully 'available. 'Please 'use 'the 'trust
      'command 'to 'assume 'that 'module '\o '\c getName(M) '\o 'is 'sufficiently 'complete. '\n)) .

  rl [terminating] :
    < O''' : SCCBroker | tools : TS >
    < O : SCC | eq-terminating : B >
    (to O from O'' : module MN is terminating functional part true)
    => < O''' : SCCBroker | tools : TS >
       < O : SCC | eq-terminating : true >
       checkSCCSuccess(TS["MFE"], O, < O : SCC | eq-terminating : true > ) .

  rl [sort-decreasing] :
    < O''' : SCCBroker | tools : TS >
    < O : SCC | eq-sort-decreasing : B >
    (to O from O'' : module MN is sort-decreasing)
    => < O''' : SCCBroker | tools : TS >
       < O : SCC | eq-sort-decreasing : true >
       checkSCCSuccess(TS["MFE"], O, < O : SCC | eq-sort-decreasing : true > ) .

  rl [scc-trust] :
    < O : SCCBroker | current : null-oid, tools : TS >
    (to O from O' : ('trust`..@Command@))
    => < O : SCCBroker | current : null-oid, tools : TS >
       to TS["MFE"] from O : output(mfe-warning('Please 'select 'a 'module)) .
  rl [scc-trust] :
    < O : SCCBroker | current : O', tools : TS >
    < O' : SCC | module : M, requesters : OS, trusted : B >
    (to O from O'' : ('trust`..@Command@))
    => < O : SCCBroker | current : O', tools : TS >
       < O' : SCC | module : M, requesters : OS, trusted : true >
       (to TS["MFE"] from O' : output('Module eMetaPrettyPrint(getName(M)) 'is 'trusted 'to 'be 'sufficiently 'complete. '\n))
       if B == true
       then none
       else (to OS from O' : module getName(M) is sufficiently complete)
            (to OS from O' : module getName(M) has free equational constructors)
       fi .

  crl [scc-select] :
    < O : SCCBroker | current : O', reg : (MN |-> O'', MNReg) >
    (to O from O''' : 'SCC`select_.[T])
    => < O : SCCBroker |  current : O'', reg : (MN |-> O'', MNReg) >
       (to O''' from O : output(eMetaPrettyPrint(parseModExp(T)) 'is 'now 'the 'current 'module. '\n))
    if MN = parseModExp(T) .
  crl [scc-select] :
    < O : SCCBroker | reg : MNReg >
    (to O from O''' : 'SCC`select_.[T])
    => < O : SCCBroker | reg : MNReg >
       (to O''' from O : output(mfe-failure(eMetaPrettyPrint(parseModExp(T)) 'cannot 'be 'set 'as 'current. '\n)))
    if not parseModExp(T) in domain of MNReg .

---- outputs the current state of the SCC (taken from CRC)
  op pretty-print-scc-state : Oid Oid Nat Map{ModuleName, Oid} QidList -> Msg .

  rl [scc-show-state] :
    < O : SCCBroker | none >
    < SCC(N) : SCC | module : M, sc-result : SCCRes, free-result : CFCRes, eq-sound : isSound,
      eq-complete : isComplete, eq-terminating : B, eq-sort-decreasing : B', trusted : B'' >
    pretty-print-scc-state(O', O, N, (MN |-> SCC(N), MNReg), QIL)
    => < O : SCCBroker | none >
       < SCC(N) : SCC | module : M, sc-result : SCCRes, free-result : CFCRes, eq-sound : isSound,
         eq-complete : isComplete, eq-terminating : B, eq-sort-decreasing : B', trusted : B'' >
         pretty-print-scc-state(O', O, s N, MNReg,
           QIL '\n auxShowStateSCC(M,SCCRes,CFCRes,isSound,isComplete,B,B',B'')) .
  crl [scc-show-state] :
    < O : SCCBroker | none >
    pretty-print-scc-state(O', O, N, MNReg, QIL)
    => < O : SCCBroker | none >
       pretty-print-scc-state(O', O, s N, MNReg, QIL)
    if MNReg =/= empty /\ not (SCC(N) in codomain of MNReg) .
  rl [scc-show-state] :
    < O : SCCBroker | none >
    pretty-print-scc-state(O', O, N, empty, QIL)
    => < O : SCCBroker | none >
       (to O' from O : output(QIL)) .
endom

omod TERMINATION-CHECKER is
  pr PROC-TPDB .
  inc MFE-TOOL .
  pr 3BOOL .
  inc FILE . 
  pr MFE-TEXT-STYLE .
  pr LEXICAL .
  inc PROCESS .
  inc TIME .

  vars M M' : Module .
  var  P : Path .
  vars CONDITIONS CONTEXT : Bool .
  var  Str Str' TOOL : String .
  vars O O' O'' FH OStd OStderr : Oid .
  var  N : Nat .
  vars B B' : Bool .
  var  TS : Map{ToolName, Oid} .
  var  MN : ModuleName .
  var  MNReg : Map{ModuleName, Oid} .
  var  3B : 3Bool .
  vars OS : Set{Oid} .

  class MTTBroker | external-tool : String, path : Path .
  subclass MTTBroker < Tool .

  class MTT |
    proof : String,
    ---- requester : Oid,
    ---- module : Module,
    conditions : Bool,
    context : Bool,
    functional-part : Bool,  ---- true if the termination proof refers to the functional part of the module
    tool-input : Oid,
    tool-output : Oid,
    file-contents : String,
    terminating : 3Bool .    ---- true if the module has been proved terminating
  subclass MTT < Goal .

  op MTT : Nat -> Oid .
  op applyMTTresult from_ : Oid -> Msg [ctor] .

  eq < O : MTTBroker | path : P >
     (to O from O' : check termination M functional part B)
    = < O : MTTBroker | path : P >
      (to O from O' : check termination M using P functional part B) .

  ---- Depending on whether a module with the name of the module has previously been
  ---- checked or not the module is directly checked or it is checked after
  ---- deleting proofs or pending goals on this module.
  crl [mtt-check] :
    ---- a module with the same name (perhaps the same module) was previously checked
    < O : MTTBroker | tools : TS, reg : ((MN |-> O'), MNReg) >
    < O' : MTT | requester : OS, module : M, terminating : 3B, proof : Str, functional-part : B >
    (to O from O'' : check termination M' using P functional part B')
    => if (B == false or-else B == B') and-then M == M' and-then 3B =/= maybe
       then < O : MTTBroker | current : O' >
            < O' : MTT | requester : (OS, O'') >
            if 3B == true ---- TODO: 3B =/= maybe
            then (to O'' from O : module MN is terminating functional part B')
            else (to O'' from O : module MN is non-terminating functional part B')
            fi
       else ---- The MTT object is removed
            (to TS["MFE"] from O : output('The 'MTT 'proof 'for eMetaPrettyPrint(getName(M')) 'has 'been 'reset. '\n))
            ---- the association of module name in the reg map is removed
            < O : MTTBroker | reg : MNReg >
            (to O from O'' : check termination M' using P functional part B')
       fi
    if MN = getName(M') .
  crl [mtt-check] :
    ---- no module with the same name was previously checked
    < O : MTTBroker | index : N, reg : MNReg >
    (to O from O' : check termination M using P functional part B)
    => < O : MTTBroker | index : s N, reg : ((getName(M) |-> MTT(N)), MNReg), current : MTT(N) >
       < MTT(N) : MTT | requester : O', module : M, path : P, functional-part : B, conditions : false, context : false, 
                        tool-input : null-oid, tool-output : null-oid, file-contents : "", terminating : maybe, proof : "" >
       (to MTT(N) from O : check termination)
    if not getName(M) in domain of MNReg .

  rl [mtt-check-request] :
    < O : MTTBroker | external-tool : TOOL >
    < MTT(N) : MTT | module : M, path : P, functional-part : B >
    (to MTT(N) from O : check termination)
    =>  < O : MTTBroker | none >
        < MTT(N) : MTT | none >
        openFile(fileManager, MTT(N), "aprove_input.trs", "w") .

  rl [mtt-open-file] :
    < MTT(N) : MTT | module : M, path : P, functional-part : B, conditions : CONDITIONS, context : CONTEXT, tool-input : null-oid  >
    openedFile(MTT(N), fileManager, FH) 
    =>  < MTT(N) : MTT | tool-input : FH > 
        write(FH, MTT(N), printTokens($procTPDB(if B then eraseRls(M) else M fi, P, CONDITIONS, CONTEXT))) .

  rl [mtt-write-file] :
    < MTT(N) : MTT | none >
    wrote(MTT(N), FH) 
    =>  < MTT(N) : MTT | none > 
        closeFile(FH, MTT(N)) .

  rl [mtt-close-file] : ---- TODO: currently only AProVE is supported
    < MTT(N) : MTT | tool-input : FH >
    closedFile(MTT(N), FH) 
    =>  < MTT(N) : MTT | none > 
        ---- createProcess(processManager, MTT(N), "python", "aprove.py", none) 
        createProcess(processManager, MTT(N), "sh", 
          "-c" "java -ea -jar aprove.jar -p plain -m wst aprove_input.trs > aprove_output.txt 2> aprove_error.txt", none) .

  rl [mtt-created-process] :
    < MTT(N) : MTT | none >
    createdProcess(MTT(N), processManager, O, OStd, OStderr) 
    =>  < MTT(N) : MTT | none > 
         openFile(fileManager, MTT(N), "aprove_output.txt", "r") .

  rl [mtt-open-file] :
    < MTT(N) : MTT | tool-output : null-oid >
    openedFile(MTT(N), fileManager, FH) 
    =>  < MTT(N) : MTT | tool-output : FH > 
        getLine(FH, MTT(N)) .

 rl [mtt-write-file] :
    < MTT(N) : MTT | requester : O, tool-input : O', file-contents : Str >
    gotLine(MTT(N), FH, Str') 
    =>  if Str' == "" then 
          < MTT(N) : MTT | file-contents : Str + "\\n " > 
          closeFile(FH, MTT(N)) 
          applyMTTresult from MTT(N)
        else 
          < MTT(N) : MTT | file-contents : Str + "\\n " + decodeToolOutput(Str') > 
          getLine(FH, MTT(N)) 
        fi .

  crl [mtt-file-not-ready] :
    ---- if the output is not ready yet, a timer is set to check again later
    < MTT(N) : MTT | tool-input : O, tool-output : null-oid >
    fileError(MTT(N), fileManager, "No such file or directory")
    =>  < MTT(N) : MTT | none > 
        createTimer(timeManager, MTT(N)) 
    if O =/= null-oid . ---- TODO: condition unnecessary if null-oid was of type Maybe{Oid}

  rl [mtt-file-not-ready] :
    < MTT(N) : MTT | none >
    createdTimer(MTT(N), timeManager, O)
    =>  < MTT(N) : MTT | none > 
        startTimer(O, MTT(N), oneShot, 500 ms) .

  rl [mtt-file-not-ready] :
    < MTT(N) : MTT | none >
    startedTimer(MTT(N), O)
    =>  < MTT(N) : MTT | none > .

  rl [mtt-file-not-ready] :
    < MTT(N) : MTT | none >
    timeOut(MTT(N), O)
    =>  < MTT(N) : MTT | none > 
        openFile(fileManager, MTT(N), "aprove_output.txt", "r")
        deleteTimer(O, MTT(N)) .

  rl [mtt-file-not-ready] :
    < MTT(N) : MTT | none >
    deletedTimer(MTT(N), O)
    =>  < MTT(N) : MTT | none > .

  rl [mtt-close-file] : 
    < MTT(N) : MTT | tool-output : FH >
    closedFile(MTT(N), FH) 
    =>  < MTT(N) : MTT | none > 
        ----removeFile(fileManager, MTT(N), "aprove_input.trs")
        ----removeFile(fileManager, MTT(N), "aprove_output.txt")
        ----removeFile(fileManager, MTT(N), "aprove_error.txt") 
        .

  rl [mtt-created-process] :
    < MTT(N) : MTT | none >
    removedFile(MTT(N), fileManager) 
    =>  < MTT(N) : MTT | none > .

  op terminationCheck : Module Path Bool Bool String -> String .
  op terminationCheck : String String -> String .
  op terminationCheck : String -> String .
----   eq terminationCheck(M, P, CONDITIONS, CONTEXT, TOOL)
----     = terminationCheck(
----         replace(
----           replace(
----             replace(
----               qidList2string($procTPDB(M, P, CONDITIONS, CONTEXT)),
----               "`", ""),
----             "\\n", " "),
----           "\\s", " "), TOOL) .
----  ceq terminationCheck(In:String, TOOL)
----     = terminationCheck(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
----                         termCheck(TOOL, In:String, 30),
----                         "@osb@", "`["),
----                         "@csb@", "`]"),
----                         "@ocb@", "`{"),
----                         "@ccb@", "`}"),
----                         "@opar@", "`("),
----                         "@cpar@", "`)"),
----                         "@semicolon@", ";"),
----                         "@comma@", "`,"),
----                         "@bq@", "`"),
----                         "@vertical-bar@", "|"))
----     if writeToFile("log.txt", "MTT -> AProVE: \n" + In:String + "\n", true) : String .
---- ceq terminationCheck(Out:String)
----    = Out:String
----    if writeToFile("log.txt", "AProVE -> MTT: \n" + Out:String + "\n", false) : String .

---(
 ceq terminationCheck(M, PP, CONDITIONS, CONTEXT, TOOL)
    = Out:String
    if In:String := replace(
                      replace(
                        replace(
                          qidList2string($procTPDB(M, PP, CONDITIONS, CONTEXT)),
                          "`", ""),
                        "\\n", " "),
                      "\\s", " ")
    /\ writeToFile("log.txt", "MTT -> AProVE: \n" + In:String + "\n", true) : String
    /\ Out:String := replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
                        termCheck(TOOL, In:String, 30),
                        "@osb@", "`["),
                        "@csb@", "`]"),
                        "@ocb@", "`{"),
                        "@ccb@", "`}"),
                        "@opar@", "`("),
                        "@cpar@", "`)"),
                        "@semicolon@", ";"),
                        "@comma@", "`,"),
                        "@bq@", "`"),
                        "@vertical-bar@", "|")
    /\ writeToFile("log.txt", "AProVE -> MTT: \n" + Out:String + "\n", false) : String .
---)

---- filterTPDB in the MTT-transformations file makes the corresponding encoding
op decodeToolOutput : String -> String .
eq decodeToolOutput(Str)
 =  replace(
      replace(
        replace(
          replace(
            replace(
              replace(
                replace(
                  replace(
                    replace(
                      replace(
                        replace(
                          Str, "\n", " \\n "), 
                          "@osb@", "`["),
                        "@csb@", "`]"),
                      "@ocb@", "`{"),
                    "@ccb@", "`}"),
                  "@opar@", "`("),
                "@cpar@", "`)"),
              "@semicolon@", ";"),
            "@comma@", "`,"),
          "@bq@", "`"),
      "@vertical-bar@", "|") .

----  rl [mtt-check-response] :
----    ---- no module with the same name was previously checked
----    < O : MTTBroker | reg : (MN |-> MTT(N), MNReg), tools : TS >
----    < MTT(N) : MTT | requester : O', module : M, terminating : B, proof : Str, functional-part : B' >
----    (to O from MTT(N) : termination check response for module MN is Str)
----    => < O : MTTBroker | none >
----       < MTT(N) : MTT | none > 
----       ---- if TS["MFE"] =/= O it seems that if the requester is MFE then the message is not sent
----       if B then 
----         (to O from O' : module MN is terminating functional part B)
----         if TS["MFE"] == O then none
----         else 
----           if B' then ---- functional part
----             (to TS["MFE"] from O : output(mfe-success('The 'functional 'part 'of 'module MN 'is 'terminating. '\n)))
----           else 
----             (to TS["MFE"] from O : output(mfe-success('The 'module MN 'is 'terminating. '\n)))
----           fi
----         fi 
----       else
----         if not B then 
----           (to O from O' : module MN is non-terminating functional part B)
----           if TS["MFE"] == O then none
----           else 
----             if B' then ---- functional part
----               (to TS["MFE"] from O : output(mfe-failure('The 'functional 'part 'of 'module MN 'is 'non-terminating. '\n)))
----             else 
----               (to TS["MFE"] from O : output(mfe-failure('The 'module MN 'is 'non-terminating. '\n)))
----             fi
----           fi 
----         else 
----           if B' then ----- functional part
----             (to TS["MFE"] from O : output(mfe-warning('A 'proof 'of 'the 'termination 'of 'functional 'part 'of 'module MN 'has 'not 'been 'found. '\n)))
----           else 
----             (to TS["MFE"] from O : output(mfe-warning('A 'proof 'of 'the 'termination 'of 'module MN 'has 'not 'been 'found. '\n)))
----           fi
----         fi 
----       fi .

endom

--------------------------------------------------------------------------------
--- MFE-MTT
--------------------------------------------------------------------------------
omod MFE-MTT is
  ---- pr MFE-GLOBAL-VARS .
  inc MFE-TOOL .
  inc MFE-CONTROLLER .
  inc TPDB-DATABASE-HANDLING .
  inc MTT-BANNER .
  inc MTT-TOOL .
  pr 3BOOL .
  inc TERMINATION-CHECKER .
  pr LEXICAL .

  op init-mtt : Map{ToolName, Oid} -> Configuration [ctor] .

  vars O O' O'' O''' O4 O5 OMFE OCRC OChC OITP OSCC OMTT : Oid .
  var  OS : Set{Oid} .
  var  TS : Map{ToolName, Oid} .
  var  MN : ModuleName .
  var  MNReg : Map{ModuleName, Oid} .
  var  N : Nat .
  vars QIL QIL' : QidList .
  vars T T' : Term .
  vars DB DB' : Database .
  vars ME ME' : ModuleExpression .
  vars M M' : Module .
  var  Reg : Map{String, String} .
  vars B B' : Bool .
  vars 3B 3B' : 3Bool .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPS : OpDeclSet .
  var  MbS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars Id Id' Str TOOL : String .
  vars QI L L' : Qid .
  var  Cd : Condition .
  var  S : Sort .
  var  P : Path .

  op MTT-GRAMMAR : -> FModule .
  eq MTT-GRAMMAR = addImports((including 'MTT-SIGN .), BUBBLES) .

  eq (to O from O' : ('ct`..@Command@))
    = (to O from O' : ('check`termination`..@Command@)) .
  eq (to O from O' : ('ct_.[T]))
    = (to O from O' : ('check`termination_.[T])) .
  eq (to O from O' : ('ctf`..@Command@))
    = (to O from O' : ('check`termination`functional`part`..@Command@)) .
  eq (to O from O' : ('ctf_.[T]))
    = (to O from O' : ('check`termination`functional`part_.[T])) .

  ---- initialization
  rl init-mtt(TS)
    => < TS["MTT"] : MTTBroker |
             grammar : MTT-GRAMMAR,
             tools : TS,
             current : null-oid,
             index : 0,
             reg : empty,
             external-tool : "no-tool",
             path : C;A;B(no-sorts) > .

---(
  ---- output forwarding
  rl [output] :
     (to O from O' : mtt-output(QIL))
     => (to O from O' : output(QIL)) .
---)

  ---- help
  rl [mtt-help] :
     < O : MTTBroker | none >
     (to O from O' : 'MTT`help`..@Command@)
     => < O : MTTBroker | none >
        (to O' from O : output(mtt-help)) .

  ---- show termination proof
  rl [showTerminationProof] :
    < O : MTTBroker | current : O' >
    (to O from O'' : ('show`proof`..@Command@))
    => < O : MTTBroker | current : O' >
       (to O' from O'' : ('show`proof`..@Command@)) .
  rl [showTerminationProof] :
    < O : MTTBroker | current : null-oid >
    (to O from O' : ('show`proof`..@Command@))
    => < O : MTTBroker | current : null-oid >
       (to O' from O : output('No 'proof 'to 'show.
                              'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously. '\n)) .

  rl [show-proof] :
    < O : MTT | module : M, proof : Str >
    (to O from O' : ('show`proof`..@Command@))
    => < O : MTT | module : M, proof : Str >
       to O' from O : output(tokenize(Str)) .

  ---- show state (this behavior could perahps be move to the Broker class and share by all subclasses)
  rl [mtt-show-state] :
    < O : MTT | module : M, proof : Str, terminating : 3B >
    to O from O' : printState
    => < O : MTT | module : M, proof : Str, terminating : 3B >
       to O' from O : state(
         '- 'Termination 'check 'for eMetaPrettyPrint(getName(M)) ': '\n
         if 3B == true
             then 'The 'specification 'has 'been 'proved 'terminating. '\n
             else if 3B == false
                  then 'The 'specification 'has 'been 'proved 'non-terminating. '\n
                  else 'Termination 'has 'not 'been 'proved 'yet. '\n
                  fi
             fi
         ) .
  eq parseModExp('token[T]) = downQid(T) .

  rl [mtt-select-external-tool] :
    < O : MTTBroker | external-tool : TOOL >
    (to O from O' : 'select`external`tool_.['token[T]])
    => < O : MTTBroker | external-tool : string(downQid(T)) >
       (to O' from O : output(downQid(T) 'is 'now 'the 'current 'external 'tool. '\n)).

  rl [mtt-select-path] :
    < O : MTTBroker | path : P >
    (to O from O' : 'select`path_.[T])
    => < O : MTTBroker | path : parsePath(T) >
       (to O' from O : output(qid(string(parsePath(T))) 'is 'now 'the 'checking 'path. '\n)).

  rl [mtt-show-path] :
    < O : MTTBroker | path : P >
    (to O from O' : 'show`current`path`..@Command@)
    => < O : MTTBroker | path : P >
       (to O' from O : output('The 'current 'path 'for 'termination 'checks 'is qid(string(P)) '\n)).

  rl [mtt-show-graph] :
    < O : MTTBroker | none >
    (to O from O' : 'show`transformation`graph`..@Command@)
    => < O : MTTBroker | none >
       (to O' from O : output('The 'transformation 'graph 'is '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 'SRWT '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '/ '\s '\s '\s '\\ '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 'C '\s '/ '\s '\s '\s '\s '\s '\\ 'OS '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '/ '\s '\s '\s '\s '\s '\s '\s '\\ '\n
        '\s '\s '\s '\s '\s '\s '\s 'SCS-MCTRS '\s '\s '\s 'OS-RWT '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '/ '\s '\s '\s '\s '\\ '\s '\s '\s '\s '\s '/ '\n
        '\s 'A 'Uk 'U '/ '\s '\s '\s 'OS '\\ '\s '\s '\s '/ 'T '\n
        '\s '\s '\s '\s '\s '\s '\s '/ '\s '\s '\s '\s '\s '\s '\s '\s '\\ '\s '/ '\n
        '\s '\s 'CS-CTRS '<---- 'CS-OS-CTRS '\n
        '\s '\s '\s '\s '\s '\s '\\ '\s '\s '\s '\s 'Uk 'U '\s '\s '| '\n
        '\s '\s '\s '\s '\s '\s '\s '\\ '\s '\s '\s '\s '\s '\s '\s '\s '\s '| 'B '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\\ '\s '\s '\s '\s '\s '\s '\s '\s '| '\n
        '\s '\s '\s '\s '\s '\s '\s 'B '\\ '\s '\s '\s '\s '\s 'CS-OS-TRS '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\\ '\s '\s '\s '\s '\s '/ '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\\ '\s '\s '\s '/ 'O-L 'Uk 'U '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\\ '\s '/ '\n
        '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 'CS-TRS '\n
        '\n)).

  ---- These rules take the messages with the terms resulting from the parsing
  ---- and send messages with the common syntax.
  crl
    < O : MFE | db : DB, default : MN >
    < O' : MTTBroker | path : P >
    (to O' from O'' : ('check`termination`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : MTTBroker | path : P >
       (to O' from O'' : check termination M using P functional part false)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : MTTBroker | none >
    (to O' from O'' : ('check`termination`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : MTTBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB, default : MN >
    < O' : MTTBroker | path : P >
    (to O' from O'' : ('check`termination`functional`part`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : MTTBroker | path : P >
       (to O' from O'' : check termination M using P functional part true)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl
    < O : MFE | db : DB, default : MN >
    < O' : MTTBroker | none >
    (to O' from O'' : ('check`termination`functional`part`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : MTTBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  crl
    < O : MFE | db : DB >
    < O' : MTTBroker | path : P >
    (to O' from O'' : ('check`termination_.[T]))
    => < O : MFE | db : DB >
       < O' : MTTBroker | path : P >
       (to O' from O'' : check termination M using P functional part false)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl
    < O : MFE | db : DB >
    < O' : MTTBroker | none >
    (to O' from O'' : ('check`termination_.[T]))
    => < O : MFE | db : DB >
       < O' : MTTBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  crl [check-termination-command] :
    < O : MFE | db : DB >
    < O' : MTTBroker | path : P >
    (to O' from O'' : ('check`termination`functional`part_.[T]))
    => < O : MFE | db : DB >
       < O' : MTTBroker | path : P >
       (to O' from O'' : check termination M using P functional part true)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl [check-termination-command] :
    < O : MFE | db : DB >
    < O' : MTTBroker | none >
    (to O' from O'' : ('check`termination`functional`part_.[T]))
    => < O : MFE | db : DB >
       < O' : MTTBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .

  op parsePath : Term ~> Path .
  eq parsePath('C;A;B.@Path@) = C;A;B(complete) .
  eq parsePath('C;Uk;B.@Path@) = C;A;B(no-kinds) .
  eq parsePath('C;U;B.@Path@) = C;A;B(no-sorts) .
  eq parsePath('C;A.@Path@) = C;A(complete) .
  eq parsePath('C;Uk.@Path@) = C;A(no-kinds) .
  eq parsePath('C;U.@Path@) = C;A(no-sorts) .
  eq parsePath('C;OS;B;O-L.@Path@) = C;OS;B;O-L .
  eq parsePath('C;OS;B;Uk.@Path@) = C;OS;B;A(no-kinds) .
  eq parsePath('C;OS;B;U.@Path@) = C;OS;B;A(no-sorts) .
  eq parsePath('C;OS;Uk;B.@Path@) = C;OS;A;B(no-kinds) .
  eq parsePath('C;OS;U;B.@Path@) = C;OS;A;B(no-sorts) .
  eq parsePath('OS;T;B;O-L.@Path@) = OS;T;B;O-L .
  eq parsePath('OS;T;B;Uk.@Path@) = OS;T;B;A(no-kinds) .
  eq parsePath('OS;T;B;U.@Path@) = OS;T;B;A(no-sorts) .
  eq parsePath('OS;T;Uk;B.@Path@) = OS;T;A;B(no-kinds) .
  eq parsePath('OS;T;U;B.@Path@) = OS;T;A;B(no-sorts) .

  rl [mtt-response] :
    < O : MTTBroker | tools : TS >
    < O' : MTT | requester : O'', module : M, file-contents : Str, terminating : maybe, proof : "", functional-part : B >
    applyMTTresult from O'
    ---- the index is increased, the new MTT becomes the current one, and the module name is registered
    => < O : MTTBroker | none >
       if substr(Str, 3, 3) == "\\n YES" or-else substr(Str, _-_(length(Str), 10), 3) == "YES"
       then < O' : MTT | terminating : true, proof : Str, file-contents : "" >
            (to O'' from O : module getName(M) is terminating functional part B)
       else if substr(Str, 3, 2) == "\\n NO" or-else substr(Str, _-_(length(Str), 9), 2) == "NO"
            then < O' : MTT | terminating : false, proof : Str, file-contents : "" >
                 (to O'' from O : module getName(M) is non-terminating functional part B)
            else < O' : MTT | terminating : maybe, proof : Str, file-contents : "" >
                 if B ----- functional part
                 then (to O'' from O : output(mfe-warning('A 'proof 'of 'the 'termination 'of 'functional 'part 'of 'module getName(M) 'has 'not 'been 'found. '\n)))
                 else (to O'' from O : output(mfe-warning('A 'proof 'of 'the 'termination 'of 'module getName(M) 'has 'not 'been 'found. '\n)))
                 fi
            fi
       fi 
       .

----  op applyMTTDummyresult : Module Bool -> MsgBody .
----  eq applyMTTDummyresult(O, < O' : MTTBroker | index : N, current : O'', reg : MNReg, tools : TS >, M, B)
----    ---- the index is increased, the new MTT becomes the current one, and the module name is registered
----    = < O' : MTTBroker | index : s N, current : MTT(N), reg : ((getName(M) |-> MTT(N)), MNReg), tools : TS >
----      < MTT(N) : MTT | requester : O, module : M, terminating : maybe, proof : "MAYBE", functional-part : B >
----      (to TS["MFE"] from O' :
----        output(mfe-warning('The 'Maude 'Termination 'Tool 'is 'not 'fully 'available. 'Please 'use 'the 'trust
----      'command 'to 'assume 'that 'the '\o '\c getName(M) '\o 'module 'is 'terminating. '\n))) .

  rl [mtt-trust] :
    < O : MTTBroker | current : O', tools : TS >
    < O' : MTT | requester : OS, module : M, terminating : 3B, proof : Str, functional-part : B >
    (to O from O'' : ('trust`..@Command@))
    => < O : MTTBroker | current : O', tools : TS >
       < O' : MTT | requester : OS, module : M, terminating : true, proof : "TRUSTED", functional-part : B >
       if TS["MFE"] == O''
       then none
       else (to TS["MFE"] from O' : output(mfe-success('The if B then 'functional 'part else nil fi 'of 'module getName(M) 'is 'assumed 'terminating. '\n)))
       fi
       (to OS from O' : module getName(M) is terminating functional part B) .
endom

---(
--------------------------------------------------------------------------------
--- MFE-GLOT
--------------------------------------------------------------------------------
mod MFE-GLOT is
  ---- pr MFE-GLOBAL-VARS .
  inc MFE-TOOL .
  inc MFE-CONTROLLER .
  inc TPDB-DATABASE-HANDLING .
  inc GLOT-BANNER .
  inc GLOT-TOOL .
  pr 3BOOL .

  sort GLOTBroker .
  subsort GLOTBroker < Tool .
  op GLOTBroker : -> GLOTBroker [ctor] .
  op external-tool :_ : String -> Attribute [ctor gather (&)] .

  sort GLOT .
  subsort GLOT < Goal .
  op GLOT : -> GLOT [ctor] .

  op GLOT : Nat -> Oid .

  op init-glot : Map{ToolName, Oid} -> Configuration [ctor] .

  vars O O' O'' O''' O4 O5 OMFE OCRC OChC OITP OSCC OGLOT : Oid .
  var  OS : Set{Oid} .
  var  TS : Map{ToolName, Oid} .
  var  MN : ModuleName .
  var  MNReg : Map{ModuleName, Oid} .
  var  N : Nat .
  vars QIL QIL' : QidList .
  vars T T' T1 T2 : Term .
  vars DB DB' : Database .
  vars ME ME' : ModuleExpression .
  vars M M' : Module .
  var  Reg : Map{String, String} .
  vars B B' : Bool .
  vars 3B 3B' : 3Bool .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPS : OpDeclSet .
  var  MbS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars Id Id' Str TOOL : String .
  vars QI L L' : Qid .
  var  Cd : Condition .
  var  S : Sort .
  var  P : Path .

  op GLOT-GRAMMAR : -> FModule .
  eq GLOT-GRAMMAR = addImports((including 'GLOT-SIGN .), BUBBLES) .

  eq (to O from O' : ('ct`LAMBDA-CALCULUS`..@Command@))
    = (to O from O' : ('check`termination`LAMBDA-CALCULUS`..@Command@)) .
  eq (to O from O' : ('ct`CTRS_|_[T1, T2]))
    = (to O from O' : ('check`termination`CTRS_|_[T1, T2])) .

  ---- initialization
  rl init-glot(TS)
    => < TS["GLOT"] : GLOTBroker |
             grammar : GLOT-GRAMMAR,
             tools : TS,
             current : null-oid,
             index : 0,
             reg : empty > .

  ---- help
  rl [glot-help] :
     < O : GLOTBroker | none >
     (to O from O' : 'GLOT`help`..@Command@)
     => < O : GLOTBroker | none >
        (to O' from O : output(glot-help)) .

  rl < O : GLOTBroker | tools : TS >
     (to O from O' : ('check`termination`LAMBDA-CALCULUS`..@Command@))
     => < O : GLOTBroker | tools : TS >
        (to TS["MFE"] from O : output(genProofJumps('lambda-calculus, getInferenceSystem('lambda-calculus)))) .

  rl < O : GLOTBroker | tools : TS >
     (to O from O' : ('check`termination`CTRS_|_.[T1,T2]))
     => < O : GLOTBroker | tools : TS >
        (to TS["MFE"] from O : output(genProofJumps('CTRS, getInferenceSystem('CTRS, (T1, T2))))) .
endm
---)

---(
mod MFE-EqE is
  pr 3BOOL .
  pr DATABASE-HANDLING .
  pr EqE-BANNER .
  pr EqE-HELP .
  pr EQUALITY-ENRICHMENT .
  pr MFE-CONTROLLER .
  ---- pr MFE-GLOBAL-VARS .
  pr MFE-TOOL .
  pr SET{Oid} .

  --- if the given module does not import module BOOL,
  --- it enriches the module with equality and gives it the given module name
  op eqEnrich : Module ModuleName -> Module .
  --- enriches the given module and gives it the given module name,
  --- so that if the given module imports module BOOL, the operators
  --- in BOOL are replaced by equivalent ones that are sound for
  --- ground and non-ground analysis
  op eqEnrichPatching : Module ModuleName -> Module .

  --- EqE proof object attributes
  op EqE : -> Cid [ctor] .
  op EqE : Nat -> Oid [ctor] .
  op requesters :_   : Set{Oid} -> Attribute [ctor gather (&)] .
  op module :_       : Module -> Attribute [ctor gather (&)] .
  op eqe-module :_   : Module -> Attribute [ctor gather (&)] .
  op scc :_          : 3Bool -> Attribute [ctor gather (&)] .
  op free :_         : 3Bool -> Attribute [ctor gather (&)] .
  op gchr :_         : 3Bool -> Attribute [ctor gather (&)] .
  op terminating :_  : 3Bool -> Attribute [ctor gather (&)] .
  op gsort-dec :_    : 3Bool -> Attribute [ctor gather (&)] .
  op trusted :_      : Bool -> Attribute [ctor gather (&)] .
  op patched :_      : Bool -> Attribute [ctor gather (&)] .

  --- Definition of EqE tool object and proof objects
  sort EqEBroker .
  subsort EqEBroker < Tool .
  op EqEBroker : -> EqEBroker [ctor] .

  sort EqE .
  subsort EqE < Goal .
  op EqE : -> EqE [ctor] .

  op EqE-GRAMMAR : -> FModule .
  eq EqE-GRAMMAR
   = addImports((including 'EqE-SIGN .), BUBBLES) .

  op init-eqe : Map{ToolName,Oid} -> Configuration .

  var  AS           : AttrSet .
  vars DB DB'       : Database .
  var  EqE        : EqE .
  var  EqEBroker  : EqEBroker .
  var  TS           : Map{ToolName, Oid} .
  var  MNReg        : Map{ModuleName, Oid} .
  vars M M'         : Module .
  vars ME ME'       : ModuleExpression .
  var  N            : Nat .
  vars O O' O5      : Oid .
  vars O''          : Oid .
  vars QIL QIL'     : QidList .
  var  OS           : OpDeclSet .
  var  T            : Term .
  var  Tp           : Type .
  var  TpL          : TypeList .
  var  MN           : ModuleName .

  rl init-eqe(TS)
    => < TS["EqE"] : EqEBroker |
         grammar : EqE-GRAMMAR,
         tools : TS,
         current : null-oid,
         index : 0,
         reg : empty > .

  ---- help
  rl [eqe-help] :
     < O : EqEBroker | none >
     (to O from O' : 'EqE`help`..@Command@)
     => < O : EqEBroker | none >
        (to O' from O : output(eqe-help)) .

 ---- enrich
  crl [ee] :
    < O : MFE | db : DB >
    < O' : EqEBroker | none >
    (to O' from O'' : ('ee_.[T]))
    => < O : MFE | db : DB' >
       < O' : EqEBroker | none >
       (to O' from O'' : enrich M)
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ M := getFlatModule(ME', DB') .
  crl [ee] :
    < O : MFE | db : DB >
    < O' : EqEBroker | none >
    (to O' from O'' : ('ee_.[T]))
    => < O : MFE | db : DB >
       < O' : EqEBroker | none >
       (to O'' from O' : toolError(QIL))
    if ME := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME, DB)
    /\ unitError(QIL) := getFlatModule(ME', DB') .
  crl [ee] :
    < O : MFE | db : DB, default : MN >
    < O' : EqEBroker | none >
    (to O' from O'' : ('ee`..@Command@))
    => < O : MFE | db : DB', default : MN >
       < O' : EqEBroker | none >
       (to O' from O'' : enrich M)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl [ee] :
    < O : MFE | db : DB, default : MN >
    < O' : EqEBroker | none >
    (to O' from O'' : ('ee`..@Command@))
    => < O : MFE | db : DB, default : MN >
       < O' : EqEBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  rl [ee-public] :
    < O : MFE | db : DB >
    < O' : EqEBroker | none >
    (to O' from O'' : enrich M)
    => if isParameterized?(M)
       then < O : MFE | db : DB >
            < O' : EqEBroker | none >
            (to O'' from O' : output(mfe-error('The 'EqE 'cannot 'enrich 'parameterized 'modules. '\n)))
       else if M :: STheory
            then < O : MFE | db : DB >
                 < O' : EqEBroker | none >
                 (to O'' from O' : output(mfe-error('The 'EqE 'cannot 'enrich 'theories. '\n)))
            else if has==(M)
                 then < O : MFE | db : evalModule(enrich(M), none, DB) > --------------- enrich?
                      < O' : EqEBroker | none >
                      (to O'' from O' : output('The 'equational 'enrichment 'of 'module getName(M) 'is 'now 'available '`( getName(enrich(M)) '`) '\n))
                 else < O : MFE | db : evalModule(eq-enrich(M), none, DB) > --------------- eq-enrich?
                      < O' : EqEBroker | none >
                      (to O'' from O' : output('The 'equational 'enrichment 'of 'module getName(M) 'is 'now 'available '`( getName(eq-enrich(M)) '`) '\n))
                 fi
            fi
       fi .

  op has== : Module -> Bool .
  op has==Aux : OpDeclSet -> Bool .
  eq has==(M) = has==Aux(getOps(M)) .
  eq has==Aux((op '_==_ : 'Universal 'Universal -> 'Bool [AS]. ) OS) = true .
  eq has==Aux(OS) = false [owise] .
endm
)

---(
--------------------------------------------------------------------------------
---- MFE-ERTP
--------------------------------------------------------------------------------
mod MFE-ERTP is
  pr 3BOOL .
  pr DATABASE-HANDLING .
  pr ERTP-BANNER .
  pr ERTP-HELP .
----  pr ERTP .
  pr MFE-CONTROLLER .
  ---- pr MFE-GLOBAL-VARS .
  pr MFE-TOOL .
  pr SET{Oid} .

  --- ERTP proof object attributes
  op ERTP : -> Cid [ctor] .
  op ERTP : Nat -> Oid [ctor] .
  op requesters :_   : Set{Oid} -> Attribute [ctor gather (&)] .
  op module :_       : Module -> Attribute [ctor gather (&)] .
  op ertp-module :_  : Module -> Attribute [ctor gather (&)] .
---(
  op scc :_          : 3Bool -> Attribute [ctor gather (&)] .
  op free :_         : 3Bool -> Attribute [ctor gather (&)] .
  op gchr :_         : 3Bool -> Attribute [ctor gather (&)] .
  op terminating :_  : 3Bool -> Attribute [ctor gather (&)] .
  op gsort-dec :_    : 3Bool -> Attribute [ctor gather (&)] .
  op trusted :_      : Bool -> Attribute [ctor gather (&)] .
  op patched :_      : Bool -> Attribute [ctor gather (&)] .
---)

  --- Definition of ERTP tool object and proof objects
  sort ERTPBroker .
  subsort ERTPBroker < Tool .
  op ERTPBroker : -> ERTPBroker [ctor] .

  sort ERTP .
  subsort ERTP < Goal .
  op ERTP : -> ERTP [ctor] .

  op ERTP-GRAMMAR : -> FModule .
  eq ERTP-GRAMMAR
   = addImports((including 'ERTP-SIGN .), BUBBLES) .

  op init-ertp : Map{ToolName,Oid} -> Configuration .

  var  AS           : AttrSet .
  vars DB DB'       : Database .
  var  ERTP       : ERTP .
  var  ERTPBroker : ERTPBroker .
  var  TS           : Map{ToolName, Oid} .
  var  MNReg        : Map{ModuleName, Oid} .
  vars M M'         : Module .
  vars ME ME'       : ModuleExpression .
  var  N            : Nat .
  vars O O' O5      : Oid .
  vars O''          : Oid .
  vars QIL QIL'     : QidList .
  var  OS           : OpDeclSet .
  var  T            : Term .
  var  Tp           : Type .
  var  TpL          : TypeList .
  var  MN           : ModuleName .

  rl init-ertp(TS)
    => < TS["ERTP"] : ERTPBroker |
         grammar : ERTP-GRAMMAR,
         tools : TS,
         current : null-oid,
         index : 0,
         reg : empty > .

  ---- help
  rl [ertp-help] :
     < O : ERTPBroker | none >
     (to O from O' : 'ERTP`help`..@Command@)
     => < O : ERTPBroker | none >
        (to O' from O : output(ertp-help)) .

 ---- prove
  op goal : Term -> ERTPGoal .
  var G : ERTPGoal .

  crl [prove] :
    < O : MFE | db : DB, default : MN >
    < O' : ERTPBroker | none >
    (to O' from O'' : ('prove_.[T]))
    => < O : MFE | db : DB', default : MN >
       < O' : ERTPBroker | none >
       (to O' from O'' : prove goal(T) in M)
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ M := getFlatModule(ME, DB') .
  crl [prove] :
    < O : MFE | db : DB, default : MN >
    < O' : ERTPBroker | none >
    (to O' from O'' : ('prove_.[T]))
    => < O : MFE | db : DB, default : MN >
       < O' : ERTPBroker | none >
       (to O'' from O' : toolError(QIL))
    if < DB' ; ME > := evalModExp(MN, DB)
    /\ unitError(QIL) := getFlatModule(ME, DB') .

  rl [prove-public] :
    < O : MFE | db : DB >
    < O' : ERTPBroker | none >
    (to O' from O'' : prove G in M)
    => < O : MFE | db : DB >
       < O' : ERTPBroker | none >
       (to O'' from O' : output('Something 'should 'have 'been 'proved. '\n)) .
endm
)

--------------------------------------------------------------------------------
--- MFE
--------------------------------------------------------------------------------
*** 'Redefinition' of the FULL-MAUDE module. The init rule now creates an
*** instance of class CRChC. The init rule now takes CRChC objects, and for them
*** it uses CRChC-GRAMMAR instead of GRAMMAR to parse inputs.
omod MFE is ---- MAUDE-FORMAL-ENVIRONMENT
  inc STD-STREAM .
  inc MFE-CONTROLLER .
  ---- pr MFE-ITP .
  pr MFE-SCC .
  pr MFE-CRC .
  pr MFE-ChC .
  pr MFE-MTT .
  ---- pr MFE-EqE .
  ---- pr MFE-ERTP .
  ---- pr MFE-GLOT .
  pr MFE-PUBLIC-MESSAGES .
  pr META-MFE-SIGN .
  pr FM-BANNER .

  ---- subsort NeConstantSet < NeAtomicITPTermSet . ---- Added to avoid preregularity problems due
  ---- subsort ConstantSet < AtomicITPTermSet .     ---- to declarations coming from SCC and ITP

  op init : -> Configuration .
  op {_} : Configuration -> Configuration [ctor] .

  ---- Oids for the tools' brokers
  ---- add a new constant for a new tool
  ops crc chc mtt scc itp eqe ertp glot : -> Oid .

  op TOOLS : -> Map{ToolName, Oid} .
  eq TOOLS = ("MFE" |-> mfe,
              "CRC" |-> crc,
              "ChC" |-> chc,
              ---- "ITP" |-> itp,
              "SCC" |-> scc
              ---- "MTT" |-> mtt,
              ---- "EqE" |-> eqe,
              ---- "ERTP" |-> ertp,
              ---- "GLOT" |-> glot
              ) .

  rl [init] :
     init
     => { <>
          < mfe : MFE |
              db : initialDatabase,
              partial-input : nil,
              input : nilTermList,
              output : ('\n
                        '\s '\s '\s '\s tokenize(fm-banner) '\n 
                        '\n
                        '\s '\s '\s '\s tokenize(mfe-banner) '\n
                        '\s '\s '\s '\s '\s '\s tokenize(crc-banner) '\n
                        '\s '\s '\s '\s '\s '\s tokenize(chc-banner) '\n
                        ---- '\s '\s '\s '\s tokenize(itp-banner) '\n
                        '\s '\s '\s '\s '\s '\s tokenize(cc-banner) '\n
                        ---- '\s '\s '\s '\s '\s '\s tokenize(mtt-banner) '\n
                        ---- '\s '\s '\s '\s tokenize(eqe-banner) '\n
                        ---- '\s '\s '\s '\s tokenize(ertp-banner) '\n
                        ---- '\s '\s '\s '\s tokenize(glot-banner) '\n 
                        '\n
                       ),
              default : 'CONVERSION,
              current-tool : mfe,
              tools : TOOLS,
              prompt : "MFE>", 
              incomplete-input-prompt : "> " >
          init-crc(TOOLS)
          init-chc(TOOLS)
          ---- init-itp(TOOLS)
          init-scc(TOOLS)
          ---- init-mtt(TOOLS)
          ---- init-eqe(TOOLS)
          ---- init-ertp(TOOLS)
          ---- init-glot(TOOLS)
        } .

  rl [out] :
    < mfe : MFE | none >
    wrote(mfe, stdout)
    => < mfe : MFE | none >
       getLine(stdin, mfe, "MFE> ") .
endom

erew init .

eof
set print conceal on .
print conceal fmod_is_sorts_.____endfm
              mod_is_sorts_._____endm
              omod_is_sorts_.________endom
              db
              cps`:_
              proof`:_
              module`:_
              grammar`:_
              ---tools`:_
              unregisterProofs
              .

set show command off . 
set trace off .
set trace select off .
trace select mtt-response .

