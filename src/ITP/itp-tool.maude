---- Latest changes:
---- - Instead of having the ITP working as an isolated tool, it is going to be
----   integrated into the Maude Formal Environment (MFE). To get that we have 
----   made several changes:
----   - The state of the loop is a configuration, and the state of the ITP is 
----     represented by an object of class ITP in such a configuration. 
----   - The set of ITP attributes (sort ITPAttrSet) is now a set of attributes
----     in the AttributeSet sort from the CONFIGURATION module. 
----   - For historic reasons some of the functions take the whole set of attributes
----     and return a modified set of such attributes. This has been left like that 
----     for now, although the y now operate on the set of standard attributes. 
----     This will be changed at some point.     
---- - A new attribute externalMsgs has been added to the state of the ITP to 
----   be able to interact with other tools. The idea is to send messages like
----   "this goal has been proved". [DEPRECATED: currently, messages are handled
----   at the interface level, so the ITP does not requiere to keep a log-book
----   of events]
---- - A new attribute goalName has been added to the state of the ITP to 
----   be able to keep the name of the main goal. The idea is to be able to access
----   the name of the main goal even after a successful proof
---- - File ext-term.maude changed by Paco Duran on March 1st, 2010 to make it work on alpha92a
----   Look for "---- Paco Duran" on that file

***(
*** this is now done in itp.maude
load ext-term
load ext-mod
load basic
load cong
load itp-logic
load unification
load show-itp
load itp-builtins
load check
load itp-parser
load itp-reduce
***)

fmod ITP-BANNER is
  pr STRING .
  op itp-banner : -> String .
  eq itp-banner = "Inductive Theorem Prover - July 20th 2010" .
endfm

fmod ITP-INTERNAL-CONSTANTS is
 inc STRING .
 
 op AT : -> String .
 eq AT = "@" .
endfm

view ITPFormula from TRIV to ITP-LOGIC is
  sort Elt to Formula .
endv

--- This module declares a datatype for fields in the goal.
fmod ITP-GOAL-FIELD is
  pr ITP-LOGIC .

  --- A named formula.
  sort LabeledFormula .
  op pair : String Formula -> LabeledFormula [ctor].

  --- A binary relation known to be an equivalence relation.
  sort EquivRelation .
  --- equiv-rel(F, S) marks that the operator "F : S S -> Bool" is an
  --- equivalence relation.
  --- Currently, we require that F is commutative by an axiom.
  op equiv-rel : Qid Sort -> EquivRelation [ctor].

  sort GoalField .
  subsort LabeledFormula EquivRelation < GoalField .
  op name:_ : String -> GoalField [ctor prec 51].
  --- Number to use in labeled new variables (1 per goal)
  op varNum:_ : Nat -> GoalField [ctor prec 51].
  --- Number to use in labeled new hypothesis (1 per goal)
  op hypNum:_ : Nat -> GoalField [ctor prec 51].
  --- Module to reason about formula in (1 per goal).
  op module:_ : FModule -> GoalField [ctor].
  --- Formula to prove (1 per goal).
  op formula:_ : Formula -> GoalField [ctor].
  --- A set of memberships that constructs all elements of a given sort.
  --- 1st argument is the sort.
  --- 2nd argument is name of memberships.
  --- 3rd argument is the memberships themselves.
  --- 4th argument is true if the constructor memberships should be default
  --- memberships.
  op ctor-mbs : Sort String MembAxSet Bool -> GoalField [ctor].
endfm

view ITPGoalField from TRIV to ITP-GOAL-FIELD is
  sort Elt to GoalField .
endv

fmod ITP-CTORS is
  pr ITP-LOGIC-SIMPLIFY .
  pr ITP-LOGIC-OPS .
  pr ITP-BUILTIN-OPS .
  pr ITP-INTERNAL-CONSTANTS .
  pr SET{ITPFormula}
   * (sort NeSet{ITPFormula} to NeFormulaSet,
      sort Set{ITPFormula} to FormulaSet,
      op empty : -> Set{ITPFormula} to none,
      op _,_ : Set{ITPFormula} Set{ITPFormula}
            -> Set{ITPFormula} to _;_) .
  pr SET{ITPGoalField}
   * (sort NeSet{ITPGoalField} to NeGoalFieldSet,
      sort Set{ITPGoalField} to GoalFieldSet,
      op empty : -> Set{ITPGoalField} to none,
      op _,_ : Set{ITPGoalField} Set{ITPGoalField}
            -> Set{ITPGoalField} to _;_ [prec 55]) .

  sort EmptyGoalFieldSet .
  subsort EmptyGoalFieldSet < GoalFieldSet .
  op none : -> EmptyGoalFieldSet [ctor ditto].
  op _;_ : EmptyGoalFieldSet EmptyGoalFieldSet -> EmptyGoalFieldSet
          [ctor ditto].

  --- Define a subsort for sets of labeled formulas.
  sort NeLabeledFormulaSet LabeledFormulaSet .
  subsort LabeledFormula < NeLabeledFormulaSet < LabeledFormulaSet .
  subsort NeLabeledFormulaSet < NeGoalFieldSet .
  subsort LabeledFormulaSet < GoalFieldSet .
  subsort EmptyGoalFieldSet < LabeledFormulaSet .
  op _;_ : LabeledFormulaSet LabeledFormulaSet -> LabeledFormulaSet
          [ctor ditto].
  op _;_ : LabeledFormulaSet NeLabeledFormulaSet -> NeLabeledFormulaSet
          [ctor ditto].

  --- Define a subsort for sets of equivalence relations.
  sort NeEquivRelationSet EquivRelationSet .
  subsort EquivRelation < NeEquivRelationSet < EquivRelationSet .
  subsort NeEquivRelationSet < NeGoalFieldSet .
  subsort EquivRelationSet < GoalFieldSet .
  subsort EmptyGoalFieldSet < EquivRelationSet .
  op _;_ : EquivRelationSet EquivRelationSet -> EquivRelationSet
          [ctor ditto].
  op _;_ : EquivRelationSet NeEquivRelationSet -> NeEquivRelationSet
          [ctor ditto].

  --- This sort contains all data relevant to a specific proof obligation.
  --- * String:       Name of the goal
  --- * VarNum: Nat   Major number to use when generating new variables.
  ---                 Should be incremented by one each time new variables
  ---                 are generated.
  --- * HypNum: Nat   Number to use when adding new hypothesis to module.
  ---                 Should be incremented when a new hypothesis is added.
  --- * Module:       Module we are reasoning in.
  --- * GoalFieldSet  Contains several things:
  ---                 * Labeled formulas known to be true; and
  ---                 * Alternative constructor memberships for specific
  ---                   sorts in module.
  --- * Formula:      Current goal
  ---
  --- Invariants: (incomplete)
  --- * A label should be associated to at most one equation, membership, or
  ---   labeled formula.
  sort Goal .
  op goal : GoalFieldSet -> Goal [ctor].

  sort Goal? .
  subsort Goal < Goal? .
  op nil : -> Goal? [ctor].

  sort GoalList .
  subsort Goal? < GoalList .
  op __ : GoalList GoalList -> GoalList [ctor assoc id: nil].

  var B : Bool .
  var Eq : Equation .
  var ER : EquivRelation .
  var NeERS : NeEquivRelationSet .
  var Alpha Beta : Formula .
  var Mod Mod' : FModule .
  var FS : FormulaSet .
  var G : Goal .
  var GL : GoalList .
  var GFS : GoalFieldSet .
  var LFS : LabeledFormulaSet .
  var Mb : MembAx .
  var Mbs Mbs' : MembAxSet .
  var N N' : Nat .
  var S : Sort .
  var SS : SortSet .
  var St St' St'' Label : String .
  var Labels : StringSet .
  var VS : VariableSet .

*** added by Camilo to compute the number of goals
*** in the given list of goals
  op number-of-goals : GoalList -> Nat .
  eq number-of-goals(nil) = 0 .
  eq number-of-goals(G GL) = s number-of-goals(GL) .

  --- Returns attribute set for hypothesis.
  op mk-hyp : Nat -> AttrSet .
  eq mk-hyp(N) = label(qid("hyp-" + string(N, 10))) metadata("|cat:hyp|") .

  --- Returns attribute set for lemma.
  op mk-lem : String -> AttrSet .
  eq mk-lem(Label) = label(qid(Label)) metadata("|cat:lem|") .

  --- Adds formula as antecedent to each formula in set.
  op add-antc-to-all : Formula FormulaSet -> FormulaSet .
  eq add-antc-to-all(Alpha, Beta ; FS)
   = implication(Alpha, Beta) ; add-antc-to-all(Alpha, FS) .
  eq add-antc-to-all(Alpha, none) = none .

  --- Add aquantification with given vars to each formula in set.
  op add-aquant-to-all : VariableSet FormulaSet -> FormulaSet .
  eq add-aquant-to-all(VS, Alpha ; FS)
   = AQuantification(VS, Alpha) ; add-aquant-to-all(VS, FS) .
  eq add-aquant-to-all(VS, none) = none .

  --- Dives into formula to extract conjunction as best it can.
  op extract-conj : Formula -> FormulaSet .
  eq extract-conj(trueFormula) = none .
  eq extract-conj(conjunction(Alpha, Beta))
   = extract-conj(Alpha) ; extract-conj(Beta) .
  eq extract-conj(implication(Alpha, Beta))
   = add-antc-to-all(Alpha, extract-conj(Beta)) .
  eq extract-conj(AQuantification(VS, Alpha))
   = add-aquant-to-all(VS, extract-conj(Alpha)) .
  eq extract-conj(Alpha) = Alpha [owise].

  --- addChild
  --- Adds an additional number to string.
  --- The string is assumed to have the form "A*<AT>(N.)0" where A is any
  --- character, <AT> is the constant in ITP-INTERNAL-CONSTANTS,
  --- and N is a positive integer.
  op addChild : String ~> String .
  eq addChild(St)
   = if substr(St, rfind(St, AT, length(St)) + 1, length(St)) == "0" then
       substr(St, 0, rfind(St, AT, length(St)) + 1) +  "1.0"
     else
       substr(St, 0, rfind(St, ".0", length(St)) + 1) + "1.0"
     fi .

  --- addBrother
  op addBrother : String ~> String .
  eq addBrother(St)
   = substr(St, 0, rfind(St, AT, length(St)) + 1)
   + addBrotherAux(substr(St, rfind(St, AT, length(St)) + 1, length(St))) .

  op addBrotherAux : String ~> String .
  eq addBrotherAux(St)
   = if find(St, ".", 0) == rfind(St, ".", length(St)) then
       string(rat(float(St) + 1.0), 10) + "." + "0"
     else
       substr(St, 0, find(St, ".", 0) + 1)
          + addBrotherAux(substr(St, find(St, ".", 0) + 1, length(St)))
     fi .

  --- Creates a new goal with the given name, module and formula.
  op new-goal : String Module Formula -> Goal .
  eq new-goal(St, Mod, Alpha)
   = goal( name: St ;
           varNum: 0 ;
           hypNum: 0 ;
           module: setName(qid(St), Mod) ;
           formula: Alpha) .

  --- Returns the name of the goal.
  op getName : Goal -> String .
  eq getName(goal(name: St ; GFS)) = St .

  --- Sets the name of the goal
  op setName : String Goal -> Goal .
  eq setName(St, goal(name: St' ; module: Mod ; GFS))
   = goal(name: St ; module: setName(qid(St), Mod) ; GFS) .

  --- Returns current variable number in goal.
  op getVarNum : Goal -> Nat .
  eq getVarNum(goal(varNum: N ; GFS)) = N .

  --- Increments variable number by one.
  op incVarNum : Goal -> Goal .
  eq incVarNum(goal(varNum: N ; GFS)) = goal(varNum: N + 1 ; GFS) .

  --- Returns hypothesis number of goal.
  op getHypNum : Goal -> Nat .
  eq getHypNum(goal(hypNum: N ; GFS)) = N .

  --- Increments hypothesis number by given count.
  op incHypNum : Nat Goal -> Goal .
  eq incHypNum(N', goal(hypNum: N ; GFS))
   = goal(hypNum: N + N' ; GFS) .

  op setHypNum : Nat Goal -> Goal .
  eq setHypNum(N', goal(hypNum: N ; GFS)) = goal(hypNum: N' ; GFS) .

  --- getMod
  op getMod : Goal -> FModule .
  eq getMod(goal(module: Mod ; GFS)) = Mod .

  --- Updates module in goal.
  op setMod : FModule Goal -> Goal .
  eq setMod(Mod', goal(name: St ; module: Mod ; GFS))
   = goal(name: St ; module: setName(qid(St), Mod') ; GFS) .

  --- Returns formula in goal.
  op getFormula : Goal -> Formula .
  eq getFormula(goal(formula: Alpha ; GFS)) = Alpha .

  --- Sets formula in goal.
  op setFormula : Formula Goal -> Goal .
  eq setFormula(Beta, goal(formula: Alpha ; GFS))
   = goal(formula: Beta ; GFS) .

  --- Returns all labeled formulas in goal.
  op getLabeledFormulas : Goal -> LabeledFormulaSet .
  eq getLabeledFormulas(goal(GFS))
   = $getLabeledFormulas(GFS, none) .

  --- Tail recursive implementation of getLabeledFormulas (above).
  op $getLabeledFormulas : GoalFieldSet LabeledFormulaSet
        -> LabeledFormulaSet .
  eq $getLabeledFormulas(pair(St, Alpha) ; GFS, LFS)
   = $getLabeledFormulas(GFS, pair(St, Alpha) ; LFS) .
  eq $getLabeledFormulas(GFS, LFS) = LFS [owise].

  --- Returns true if labeled formulas in set have the same name as labeled
  --- formula in goal.
  op have-conflicting-names? : LabeledFormulaSet GoalFieldSet -> Bool .
  eq have-conflicting-names?(pair(St, Alpha) ; LFS, pair(St, Beta) ; GFS)
   = true .
  eq have-conflicting-names?(pair(St, Alpha) ; pair(St, Beta) ; LFS, GFS)
   = true .
  eq have-conflicting-names?(LFS, GFS) = false [owise].

  --- Adds a labeled formula to goal.
  op addLabeledFormulas : LabeledFormulaSet Goal ~> Goal .
  ceq addLabeledFormulas(LFS, goal(GFS))
    = goal(LFS ; GFS)
   if have-conflicting-names?(LFS, GFS) = false .

  --- Returns formula with given name in goal or trueFormula is no formula
  --- with that name exists.
  op getLabeledFormula : String Goal ~> Formula .
  eq getLabeledFormula(St, goal(pair(St, Beta) ; GFS)) = Beta .
  ceq getLabeledFormula(St, goal(module: Mod ; GFS)) = eqToFormula(Eq)
   if Eq := find-eq(qid(St), getEqs(Mod)) .
  ceq getLabeledFormula(St, goal(module: Mod ; GFS)) = mbToFormula(Mb)
   if Mb := find-mb(qid(St), getMbs(Mod)) .

  --- Removes labled formula from goal if it exists.
  op removeLabeledFormula : String Goal ~> Goal .
  eq removeLabeledFormula(St, goal(pair(St, Beta) ; GFS))
   = goal(GFS) .

  --- Returns true if goal already constraints a constructor memberships with
  --- given name.
  op bound-ctor-set? : String Goal -> Bool .
  eq bound-ctor-set?(St, goal(ctor-mbs(S, St, Mbs, B) ; GFS)) = true .
  eq bound-ctor-set?(St, G) = qid(St) in getSorts(getMod(G)) [owise].

  op set-default-ctor : String Goal ~> Goal .
  --- Already set as default.
  eq set-default-ctor(St, goal(ctor-mbs(S, St, Mbs, true) ; GFS))
   = goal(ctor-mbs(S, St, Mbs, true) ; GFS) .
  --- Switch default.
  eq set-default-ctor(St, 
      goal(ctor-mbs(S, St, Mbs, false) ; ctor-mbs(S, St', Mbs', true) ; GFS))
   =  goal(ctor-mbs(S, St, Mbs, true) ; ctor-mbs(S, St', Mbs', false) ; GFS).
  --- Set default if none set.
  eq set-default-ctor(St, goal(ctor-mbs(S, St, Mbs, false) ; GFS))
   =                      goal(ctor-mbs(S, St, Mbs,  true) ; GFS) [owise].
  --- Clear default if being set to default.
  ceq set-default-ctor(St,
        goal(ctor-mbs(S, St', Mbs, true)  ; module: Mod ; GFS))
    =   goal(ctor-mbs(S, St', Mbs, false) ; module: Mod ; GFS) 
   if S := qid(St) 
   /\ S in getSorts(Mod) .
  --- Keep as default otherwise.
  ceq set-default-ctor(St, goal(module: Mod ; GFS))
    = goal(module: Mod ; GFS) 
   if S := qid(St) 
   /\ S in getSorts(Mod) [owise].

  --- Returns constructor memberships associated to given sort in goal using
  --- the given qids as labels for alternative constructor memberships.
  op weak-ctor-mbs : Sort StringSet Goal ~> MembAxSet .
  --- Return named memberships in goal.
  eq weak-ctor-mbs(S, St ; Labels, goal(ctor-mbs(S, St, Mbs, B) ; GFS))
   = Mbs .
  eq weak-ctor-mbs(S, Labels, goal(ctor-mbs(S, St, Mbs, true) ; GFS))
   = Mbs .
  eq weak-ctor-mbs(S, Labels, goal(module: Mod ; GFS))
   = ctor-mbs-with-sort(S, Mod, include-subsort-decls) [owise].

  --- Adds named constructor memberships for the given sort to the goal.
  op add-named-ctors : String Sort MembAxSet Goal -> Goal .
  eq add-named-ctors(St, S, Mbs, goal(GFS))
   = goal(ctor-mbs(S, St, Mbs, false) ; GFS) .

  -----------------------------------------------------
  --- Equivalence Relation functions.
  -----------------------------------------------------
  --- Adds equivalence relation to goal.
  op add : EquivRelation Goal -> Goal .
  eq add(ER, goal(GFS)) = goal(ER ; GFS) .

  --- Returns equivalence relations in goal.
  op get-equiv-relations : Goal -> EquivRelationSet .
  eq get-equiv-relations(goal(NeERS ; GFS))
   = NeERS ; get-equiv-relations(goal(GFS)) .
  eq get-equiv-relations(G) = none [owise].
endfm

fmod ITP-COMMAND-PARSER is
  pr ITP-EXT-MOD .
  pr ITP-COMMANDS{itp-user-types} .
  pr ITP-PARSER .
  pr ITP-FORMULA-PARSER .
  pr ITP-MODULE-PARSER .
  pr ITP-CTORS .
  pr DATABASE .           ---- Full Maude  

  sort Module? .
  subsort Module < Module? .
  op none : -> Module? .

  sort CtorParseResult .
  op ctorDefs : StringSet -> CtorParseResult [ctor].
  op ctorDefError : QidList -> CtorParseResult [ctor].

  sort ParseInputResult .
  --- 1st arg is formula we parsed and second argument is free variables in
  --- formula.
  op input : Input -> ParseInputResult [ctor].
  op parse-input-error : QidList -> ParseInputResult [ctor].

  sort ParseUserInputResult .
  op userInput : TermList -> ParseUserInputResult [ctor].
  op parse-user-input-error : QidList -> ParseUserInputResult [ctor].

  op errorInput : ~> Input [ctor].
  op errorModule : ~> Module [ctor].

  var Alpha : Formula .
  var Mod ParseMod : Module .
  var G : Goal .
  var G? : Goal? .
  var UserMod? Mod? : Module? .
  var Q : Qid .
  var Msg : QidList .
  var S : Sort .
  var SB : Substitution .
  var St : String .
  var StS : StringSet .
  var T T' : Term .
  var TL TL' NewTL : TermList .
  var V : Variable .
  var BoundVS : VariableSet .
  var NeVS : NeVariableSet .
  var  DB : Database .

  --- Attempts to reduce input to parse input result.
  op downInput : Term ~> ParseInputResult .
  eq downInput(T)
   = if downTerm(T, errorInput) :: Input then
       input(downTerm(T, errorInput))
     else
       parse-input-error('Unexpected 'inability 'to 'parse 'input 'command.)
     fi .

  op append : TermList ParseUserInputResult -> ParseUserInputResult .
  eq append(TL, parse-user-input-error(Msg)) = parse-user-input-error(Msg) .
  eq append(TL, userInput(T)) = userInput((TL, T)) .

  --- parseInput(Mod, G?, C) parse the user's command, which is currently a
  --- term in Mod.
  op parseInput : Module Goal? GroundTerm Database ~> ParseInputResult .
  eq parseInput(ParseMod, G?, C:Constant, DB)
   = downInput(C:Constant) .

  --- Success at parsing user module name.
  ceq parseInput(ParseMod, G?, Q[TL, T, TL'], DB)
    = $parseInput(Q, (TL, T, TL'), ParseMod, none, Mod, G?, userInput(empty))
   if sameKind(ParseMod, leastSort(ParseMod, T), 'UserModule)
   /\ module(Mod) := parseModule(T, DB) .

  --- Error parsing module.
  ceq parseInput(ParseMod, G?, Q[TL, T, TL'], DB)
    = parse-input-error(Msg)
   if sameKind(ParseMod, getType(metaNormalize(ParseMod, T)), 'UserModule)
   /\ parse-module-error(Msg) := parseModule(T, DB) .

  --- No user module found.
  ceq parseInput(ParseMod, G, Q[TL], DB)
    = $parseInput(Q, TL, ParseMod, BoundVS, Mod, G, userInput(empty))
   if BoundVS := getOuterBoundVars(getFormula(G))
   /\ Mod := addOpsITP(varOpDecls(BoundVS), getMod(G)) [owise].

  eq parseInput(ParseMod, nil, Q[TL], DB)
   = $parseInput(Q, TL, ParseMod, none, none, nil, userInput(empty))
     [owise].

  --- Tail recursive procedure that parses each input.
  op $parseInput : Qid TermList Module VariableSet Module? Goal?
      ParseUserInputResult ~> ParseInputResult .
  eq $parseInput(Q, TL, ParseMod, BoundVS, UserMod?, G?,
                 parse-user-input-error(Msg))
   = parse-input-error(Msg) .
  eq $parseInput(Q, (T, TL), ParseMod, BoundVS, UserMod?, G?,
                userInput(NewTL))
   = $parseInput(Q, TL, ParseMod, BoundVS, UserMod?, G?,
       append(NewTL,
         $parseInput1(leastSort(ParseMod, T), T, BoundVS, UserMod?, G?))) .
  eq $parseInput(Q, empty, ParseMod, BoundVS, UserMod?, G?, userInput(NewTL))
   = downInput(Q[NewTL]) .

  --- Parse a single term in input.
  op $parseInput1 : Sort Term VariableSet Module? Goal?
      ~> ParseUserInputResult .

  eq $parseInput1('UserModule, T, BoundVS, Mod?, G?)
   = userInput(upTerm(Mod?)) .

  eq $parseInput1('UserToken, T, BoundVS, Mod?, G?)
   = userInput(upTerm(parseToken(T))) .

  ceq $parseInput1('CtorDefSet, T, BoundVS, Mod?, G)
    = parse-user-input-error('There 'is 'no 'constructor 'definition 'named
                             qid(St) '.)
   if St ; StS := parseCtorDefs(T)
   /\ bound-ctor-set?(St, G) = false .
  eq $parseInput1('CtorDefSet, T, BoundVS, Mod?, G)
   = userInput(upTerm(parseCtorDefs(T))) [owise].
  eq $parseInput1('CtorDefSet, T, BoundVS, Mod?, nil)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .

  ceq $parseInput1('UserVar, T, BoundVS, Mod, G?)
    = userInput(upTerm(V))
   if V := parseVar(Mod, BoundVS, T) .
  ceq $parseInput1('UserVar, T, BoundVS, Mod, G?)
    = parse-user-input-error(Msg)
   if Msg := parseVarError(Mod, BoundVS, T) .
  eq $parseInput1('UserVar, T, BoundVS, none, G?)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .

  ceq $parseInput1('UserTerm, T, BoundVS, Mod, G?)
    = userInput(upTerm(T'))
   if T' := parseTerm(Mod, BoundVS, T, anyType) .
  ceq $parseInput1('UserTerm, T, BoundVS, Mod, G?)
    = parse-user-input-error(Msg)
   if Msg := parseTermError(Mod, BoundVS, T, anyType) .
  eq $parseInput1('UserTerm, T, BoundVS, none, G?)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .

  ceq $parseInput1('UserTermSet, T, BoundVS, Mod, G?)
    = userInput(upTerm(TS:ITPTermSet))
   if TS:ITPTermSet := parseITPTermSet(Mod, BoundVS, T) .
  ceq $parseInput1('UserTermSet, T, BoundVS, Mod, G?)
    = parse-user-input-error(Msg)
   if Msg := parseITPTermSetError(Mod, BoundVS, T) .
  eq $parseInput1('UserTermSet, T, BoundVS, none, G?)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .

  ceq $parseInput1('UserSort, T, BoundVS, Mod?, G?)
   = userInput(upTerm(S))
   if S := $parseSort(T) .
  ceq $parseInput1('UserSort, T, BoundVS, Mod?, G?)
    = parse-user-input-error(Msg)
   if Msg := parseSortError(T) .

  eq $parseInput1('UserOpName, T, BoundVS, Mod?, G?)
   = userInput(upTerm(parseOpName(T))) .

  ceq $parseInput1('UserSubstitution, T, BoundVS, Mod, G?)
    = userInput(upTerm(SB))
   if SB := parseSubst(T, none, Mod) .
  ceq $parseInput1('UserSubstitution, T, BoundVS, Mod, G?)
    = parse-user-input-error(Msg)
   if Msg := parseSubstError(T, none, Mod) .
  eq $parseInput1('UserSubstitution, T, BoundVS, none, G?)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .

  ceq $parseInput1('UserSentence, T, BoundVS, Mod, G?)
    = userInput(upTerm(Alpha))
   if formula(Alpha, none) := parseFormula(T, Mod, none) .
  ceq $parseInput1('UserSentence, T, BoundVS, Mod, G?)
    = parse-user-input-error('The 'formula 'contains 'free 'variables
        printVariableSet(NeVS) 'when 'free 'variables 'are 'not 'allowed.)
   if formula(Alpha, NeVS) := parseFormula(T, Mod, none) .
  ceq $parseInput1('UserSentence, T, BoundVS, Mod, G?)
    = parse-user-input-error(Msg)
   if parse-formula-error(Msg) := parseFormula(T, Mod, none) .
  eq $parseInput1('UserSentence, T, BoundVS, none, G?)
   = parse-user-input-error('The 'goal 'must 'be 'set 'for 'this 'command.) .
endfm

fmod ITP-NEW-VAR is
  pr CONVERSION .
  pr ITP-LOGIC .
  pr META-TERM .

  var N N' : Nat .
  var SB : Substitution .
  var Tp : Type .
  var TpL : TypeList .
  var V : Variable .
  var VL : VarList .
  var VS : VariableSet .

  --- Constructs a new variable with the given type from two numbers.
  op newVar : Nat Type Nat -> Variable .
  eq newVar(N, Tp, N')
   = qid("V" + string(N, 10) + "#" + string(N', 10) + ":" + string(Tp)) .

  --- Constructs new variables from a list of types.
  op newVarList : Nat TypeList -> VarList .
  eq newVarList(N, TpL) = $newVarList(N, TpL, 0, empty) .

  --- Tail recursive implementation of newVarList (above).
  op $newVarList : Nat TypeList Nat VarList -> VarList .
  eq $newVarList(N, Tp TpL, N', VL)
   = $newVarList(N, TpL, s N', (VL, newVar(N, Tp, N'))) .
  eq $newVarList(N, nil, N', VL) = VL .

  --- Constructs a substitution mapping each variable in set to a new
  --- variable.
  --- Warning: This is not confluent.
  op newVars : VariableSet Nat -> Substitution .
  eq newVars(VS, N) = $newVars(VS, N, 0, none) .

  --- Tail recursive implementation of newVars (above)
  op $newVars : VariableSet Nat Nat Substitution -> Substitution .
  eq $newVars(V ; V ; VS, N, N', SB) = $newVars(V ; VS, N, N', SB) .
  eq $newVars(V ; VS, N, N', SB)
   = $newVars(VS, N, s N', (V <- newVar(N, getType(V), N')) ; SB) [owise].
  eq $newVars(none, N, N', SB) = SB .
endfm

--- Provides function for meta pretty printing goal set.
fmod ITP-PRETTY-PRINT is
  pr ITP-CTORS .
  pr SHOW-ITP .

  var Alpha Beta : Formula .
  var G : Goal .
  var Mod : Module .
  var N N' Id Id' : Nat .
  var NL NL' : NatList .
  var QI : Qid .
  var QIL QIL' : QidList .
  var S : Sort .
  var T1 T2 : Term .
  var V : Variable .
  var VS : VariableSet .

  --- Pretty prints variable list.
  --- Warning: This function is not confluent.
  op meta-pretty-print-VarSet : Module VariableSet -> QidList .
  eq meta-pretty-print-VarSet(Mod, V ; VS) =
     if VS == none then
       tokenize(V)
     else
       tokenize(V) '; meta-pretty-print-VarSet(Mod, VS)
     fi .
  eq meta-pretty-print-VarSet(Mod, none) = ' .

  --- Adds a space at end of qidlist if one is not already implied.
  op post-space : QidList -> QidList .
  eq post-space(nil) = nil .
  eq post-space(QIL '`{) = QIL '`{ ' .
  eq post-space(QIL '`}) = QIL '`} ' .
  eq post-space(QIL '`() = QIL '`( ' .
  eq post-space(QIL '`)) = QIL '`) ' .
  eq post-space(QIL) = QIL [owise].

  --- Returns estimate of length of qidlist when printed out by Maude.
  op print-len : QidList -> NeNatList .
  eq print-len(QIL) = $print-len(QIL, 0) .

  --- Tail recursive implementation of print-len (above).
  op $print-len : QidList NeNatList -> NeNatList .
  eq $print-len(nil, NL) = NL .
  eq $print-len('`{ QIL, NL N) = $print-len(QIL, NL s N) .
  eq $print-len('`} QIL, NL N) = $print-len(QIL, NL s N) .
  eq $print-len('`( QIL, NL N) = $print-len(QIL, NL s N) .
  eq $print-len('`) QIL, NL N) = $print-len(QIL, NL s N) .
  eq $print-len('   QIL, NL N) = $print-len(QIL, NL s N) .
  eq $print-len('\n QIL, NL)   = $print-len(QIL, NL 0) .
  eq $print-len(QI  QIL, NL N)
   = $print-len(QIL, NL (s N + length(string(QI)))) [owise].

  --- Length of expression before it should be broken.
  op break-len : -> Nat .
  eq break-len = 70 .

  op indent : Nat -> QidList .
  eq indent(0) = nil .
  eq indent(s N) = '\s indent(N) .

  op break : QidList QidList Nat -> QidList .
  ceq break(QIL, QIL', Id) = QIL '\n indent(Id) QIL'
   if NL  N  := print-len(QIL)
   /\ N' NL' := print-len(QIL')
   /\ N + N' >= break-len .
  eq break(QIL, QIL', Id) = post-space(QIL) QIL' [owise].

  --- Add parens around qidlist if bool is true.
  op add-parens : Bool QidList -> QidList .
  eq add-parens(true, QIL) = '`( QIL '`) .
  eq add-parens(false, QIL) = QIL .

  --- Pretty prints formula for display.
  op meta-pretty-print-Formula : Module Formula ~> QidList .
  eq meta-pretty-print-Formula(Mod, Alpha) = $mpp(Mod, Alpha, 0, 0) .

  --- Implementation of meta-pretty-print-Formula (above).
  --- The third parameter is the priority of the outer construct, and is used
  --- to control when parenthesis appear.  Higher priorities mean the
  --- operator that called $mpp recursively has a tighter binding power.
  op $mpp : Module Formula Nat Nat ~> QidList .
  eq $mpp(Mod, trueFormula, N, Id) = 'true .
  eq $mpp(Mod, falseFormula, N, Id) = 'false .
  eq $mpp(Mod, AQuantification(VS, Alpha), N, Id)
   = add-parens(N > 1,
        break('A '`{ meta-pretty-print-VarSet(Mod, VS) '`},
              $mpp(Mod, Alpha, 1, s Id),
              s Id)) .
  eq $mpp(Mod, EQuantification(VS, Alpha), N, Id)
   = add-parens(N > 1,
        break('E '`{ meta-pretty-print-VarSet(Mod, VS) '`},
              $mpp(Mod, Alpha, 1, s Id),
              s Id)) .
  --- Negation is highest operator and never has parens.
  eq $mpp(Mod, negation(Alpha), N, Id)
   = '~ $mpp(Mod, Alpha, 5, Id) .
  --- Implication has parens if N > 3, but is considered priority 4 for
  --- subformulas to force parens around nested implications.
  ceq $mpp(Mod, implication(Alpha, Beta), N, Id)
   = add-parens(N > 3,
       break($mpp(Mod, Alpha, 4, Id'),
             '==> $mpp(Mod, Beta, 4, Id'),
             Id'))
   if Id' := if N > 3 then s Id else Id fi .
  ceq $mpp(Mod, conjunction(Alpha, Beta), N, Id)
   = add-parens(N > 4,
                break($mpp(Mod, Alpha, 4, Id'),
                      '& $mpp(Mod, Beta, 4, Id'),
                      Id'))
   if Id' := if N > 4 then s Id else Id fi .
  eq $mpp(Mod, disjunction(Alpha, Beta), N, Id)
   = add-parens(N > 2,
                break($mpp(Mod, Alpha, 2, s Id),
                      'V $mpp(Mod, Beta, 2, s Id),
                      s Id)) .
  eq $mpp(Mod, equality(T1, T2), N, Id)
   = break(metaPrettyPrint(Mod, T1),
           '= metaPrettyPrint(Mod, T2),
           s Id) .
  eq $mpp(Mod, sortP(T1, S), N, Id)
   = post-space(metaPrettyPrint(Mod, T1)) ': tokenize(S) .
endfm

--- Defines constructors for induction schemes and some basic operations.
fmod ITP-INDUCTION-SCHEMES is
  pr ITP-CTORS .

  --- A substitution which can only be applied if the condition is true.
  sort CondSubst .
  op cs : Substitution EqCondition -> CondSubst [ctor].

  --- A set of conditional substitutions.
  sort CondSubstSet .
  subsort CondSubst < CondSubstSet .
  op none : -> CondSubstSet [ctor].
  op _;_ : CondSubstSet CondSubstSet -> CondSubstSet
           [ctor assoc comm id: none].

  var Alpha Beta : Formula .
  var CS : CondSubst .
  var CSS : CondSubstSet .
  var EqC : EqCondition .
  var FS : FormulaSet .
  var G : Goal .
  var GL : GoalList .
  var M : FModule .
  var SB : Substitution .

  --- conjoin-subst(Alpha, CSS) returns conjunction of instantations of
  --- Alpha.
  op conjoin-subst : Formula CondSubstSet -> Formula .
  eq conjoin-subst(Alpha, CSS) = $conjoin-subst(Alpha, CSS, trueFormula) .

  --- Tail recursive implementation of conjoin-subt.
  op $conjoin-subst : Formula CondSubstSet Formula -> Formula .
  eq $conjoin-subst(Alpha, cs(SB, EqC) ; CSS, Beta)
   = $conjoin-subst(Alpha, CSS,
        conjunction(
          implication(condToFormula(EqC), substitute(Alpha, SB)),
          Beta)) .
  eq $conjoin-subst(Alpha, none, Beta) = Beta .

  --- Update the name of the goal to the "child" goal.
  op makeChildGoal : Goal ~> Goal .
  eq makeChildGoal(G) = setName(addChild(getName(G)), G) .

  --- Update the name of the goal to the "brother" goal.
  op makeBrotherGoal : Goal ~> Goal .
  eq makeBrotherGoal(G) = setName(addBrother(getName(G)), G) .

  --- Create a goal for each formula in the set.
  op replace-formulas : FormulaSet Goal -> GoalList .
  eq replace-formulas(FS, G) = $replace-formulas(FS, makeChildGoal(G), nil) .

  --- Tail-recursive implementation of replace-formulas (above).
  op $replace-formulas : FormulaSet Goal GoalList -> GoalList .
  eq $replace-formulas(Alpha ; FS, G, GL)
   = $replace-formulas(FS, makeBrotherGoal(G), GL setFormula(Alpha, G)) .
  eq $replace-formulas(none, G, GL) = GL .
endfm

--- Provides operations for performing cover set induction.
--- The key method is cover-set-scheme which generates an induction scheme
--- from a seed term and module.
fmod COVERSET-INDUCTION is
  pr ITP-INDUCTION-SCHEMES .
  pr ITP-CTORS .
  pr ITP-EXT-TERM .
  pr UNIFICATION .
  pr META-MODULE-EXT .
  pr TERM-SUBST .
  pr ITP-LOGIC-OPS .
  pr ITP-BUILTIN-OPS .
  pr ITP-NEW-VAR .

  --- Represents a matching equation.
  --- With an equation me(Pattern, Subject), we are trying to find a
  --- substitution which when applied to Subject results in a term that
  --- matches Pattern.
  sort MatchEq .
  op me : Term Term -> MatchEq [ctor].

  --- A conjunction set of match equations.
  sort MatchEqSet .
  subsort MatchEq < MatchEqSet .
  op none : -> MatchEqSet [ctor].
  op _;_ : MatchEqSet MatchEqSet -> MatchEqSet [ctor assoc comm id: none].

  --- A system of match equations.
  sort ExpansionTest .
  op et : MatchEqSet -> ExpansionTest [ctor].

  ---  A disjunctive set of systems of match equations.
  sort ExpansionTestSet .
  subsort ExpansionTest < ExpansionTestSet .
  op none : -> ExpansionTestSet [ctor].
  op _;_ : ExpansionTestSet ExpansionTestSet -> ExpansionTestSet
          [ctor assoc comm id: none].

  --- A partial result containing a disjunctive set of match equations
  --- one of which must be satisfied and a partial conditional substitution.
  sort ExpansionSubst .
  op esub : ExpansionTestSet CondSubst -> ExpansionSubst [ctor].

  sort ExpansionSubstSet .
  subsort ExpansionSubst < ExpansionSubstSet .
  op none : -> ExpansionSubstSet [ctor].
  op _;_ : ExpansionSubstSet ExpansionSubstSet -> ExpansionSubstSet
           [ctor assoc comm id: none].
  --- TODO: Perform intersection.
  eq esub(ETS, CS) ; esub(ETS', CS) = esub(ETS, CS) .

  --- Maps each variable to number of equations that demended it.
  sorts NeDemandedVarMap DemandedVarMap .
  subsort NeDemandedVarMap < DemandedVarMap .
  op none : -> DemandedVarMap [ctor].
  op var : Variable NzNat -> NeDemandedVarMap [ctor].
  op _;_ : DemandedVarMap DemandedVarMap -> DemandedVarMap
           [ctor assoc comm id: none].
  op _;_ : DemandedVarMap NeDemandedVarMap -> NeDemandedVarMap [ctor ditto].

  sort ExpandableVarsResult1 .
  op evr1 : MatchEqSet VariableSet -> ExpandableVarsResult1 [ctor].

  sort ExpandableVarsResult .
  op evr : ExpansionTestSet DemandedVarMap -> ExpandableVarsResult [ctor].

  var AS : AttrSet .
  var C : Constant .
  var CS CS' : CondSubst .
  var CSS CSS' : CondSubstSet .
  var Con : Context .
  var DVM : DemandedVarMap .
  var NeDVM : NeDemandedVarMap .
  var Eq Eq' : Equation .
  var Eqs Eqs' : EquationSet .
  var EqC EqC' EqC'' : EqCondition .
  var ES : ExpansionSubst .
  var ESS : ExpansionSubstSet .
  var ETS ETS' ETS'' : ExpansionTestSet .
  var Alpha Beta : Formula .
  var FS : FormulaSet .
  var G : Goal .
  var GT : GroundTerm .
  var K : Kind .
  var M : Module .
  var Mb : MembAx .
  var Mbs : MembAxSet .
  var MES MES' : MatchEqSet .
  var N N' VarNum : Nat .
  var Op : OpDecl .
  var Ops : OpDeclSet .
  var Q Q' : Qid .
  var S : Sort .
  var SS : SortSet .
  var SB SB' SeedSB ResultSB : Substitution .
  var SBS : ITPSubstitutionSet .
  var STS : StringSet .
  var T T' T'' Seed T1 T2 T3 T4 : Term .
  var TL TL' : TermList .
  var TS : ITPTermSet .
  var Tp Tp' : Type .
  var TpL : TypeList .
  var TpS : TypeSet .
  var V V' : Variable .
  var NeVS : NeVariableSet .
  var VS VS' : VariableSet .

  --- Returns a variable demanded by the most number of equations.
  op find-var : NeDemandedVarMap -> Variable .
  eq find-var(var(V, N) ; DVM) = $find-var(DVM, V, N) .

  op $find-var : DemandedVarMap Variable Nat -> Variable .
  eq $find-var(var(V, N) ; DVM, V', N')
   = if N > N' then
       $find-var(DVM, V, N)
     else
       $find-var(DVM, V', N')
     fi .
  eq $find-var(DVM, V, N) = V .

  op inc-vars : VariableSet DemandedVarMap -> DemandedVarMap .
  eq inc-vars(V ; VS, var(V, N) ; DVM) = inc-vars(VS, var(V, s N) ; DVM) .
  eq inc-vars(V ; VS, DVM) = inc-vars(VS, var(V, 1) ; DVM) [owise].
  eq inc-vars(none, DVM) = DVM .

  --- Returns variable with name of the given variable and the new type.
  op set-var-type : Variable Type -> Variable .
  eq set-var-type(V, Tp) = qid(string(getName(V)) + ":" + string(Tp)) .

  --- Returns variable for each term in list whose type is the kind of the
  --- term.
  op kind-vars : Module TermList -> TermList .
  eq kind-vars(M, TL) = $kind-vars(M, TL, 0, empty) .

  op $kind-vars : Module TermList Nat TermList ~> TermList  .
  eq $kind-vars(M, (T, TL), N, TL')
   = $kind-vars(M, TL, s N, (TL',
       qid("X" + string(N, 10) + ":" + string(kindOf(M, T))))) .
  eq $kind-vars(M, empty, N, TL) = TL .

  --- Given a term f(t1, ..., tn) returns f(x1, ..., xn).
  --- Given a variable x, returns x.
  op root-expr : Module Term -> Term .
  eq root-expr(M, C) = C .
  eq root-expr(M, V) = V .
  eq root-expr(M, Q[TL]) = Q[kind-vars(M, TL)].

  --- Returns true if there is a membership in set matching term.
  op matching-mb? : MembAxSet Module Term -> Bool .
  ceq matching-mb?(Mb Mbs, M, T) = true
   if metaMatch(M, root-expr(M, term(Mb)), T, nil, 0) : Substitution .
  eq matching-mb?(Mbs, M, T) = false [owise].

  --- Returns true if the two types share a common subsort in the module.
  --- The types should be concrete type in the module.
  op share-subsort? : Module Type Type ~> Bool .
  eq share-subsort?(M, Tp, Tp')
   = sameKind(M, Tp, Tp') and-then (glbSorts(M, Tp, Tp') :: NeTypeSet) .

  --- Returns memberships for all sorts in set.
  op ext-ctor-mbs-with-sorts : SortSet StringSet Goal -> MembAxSet .
  eq ext-ctor-mbs-with-sorts(S ; SS, STS, G)
   = weak-ctor-mbs(S, STS, G) ext-ctor-mbs-with-sorts(SS, STS, G) .
  eq ext-ctor-mbs-with-sorts(none, STS, G) = none .

  --- Returns true if we should expand a variable to match a term with the
  --- given type.
  --- The type should be a concrete type in the module.
  op type-compatible? : StringSet Goal Term Type -> Bool .
  eq type-compatible?(STS, G, V, Tp)
   = share-subsort?(getMod(G), getType(V), Tp) .
  --- TODO: Revisit whether this rule is a good idea.
  eq type-compatible?(STS, G, GT, Tp)
   = subtype?(getMod(G), leastSort(getMod(G), GT), Tp) .
  eq type-compatible?(STS, G, Q[TL], K) = kindOf(getMod(G), Q[TL]) == K .
  eq type-compatible?(STS, G, Q[TL], S)
   = sameKind(getMod(G), kindOf(getMod(G), Q[TL]), S) and-then
     matching-mb?(
       ext-ctor-mbs-with-sorts(lesserSorts(getMod(G), S) ; S, STS, G),
       getMod(G),
       Q[TL]) .

  --- Returns true if a variable with the given type should expand against
  --- a particular term in the pattern.
  op should-expand? : Module Term Type -> Bool .
  eq should-expand?(M, V, Tp)
   = not sortLeq(M, Tp, getType(V)) and-then algebraic-sort?(Tp) .
  eq should-expand?(M, T, Tp) = algebraic-sort?(Tp) [owise].

  --- expand-var(M, VS, V) generates a conditional subst set where each
  --- conditional substitution maps V to terms in T_M(X) such that:
  --- * For all ground constructor terms U \in T_{M,getType(V)}, there is a
  ---   conditional substitution cs(V <- T, EqC) \in expand-var(M, VS, V)
  ---   such that:
  ---    exists \theta where "T\theta =_M U" and "M |= EqC\theta"
  --- * For all cond. subst. cs(V <- T, EqC) \in expand-var(M, VS, V),
  ---   1. metaMatch(M, V, T, nil, 0) = noMatch
  ---   2. vars-itp(T) and VS are disjoint sets.
  --- Requirements:
  --- * M is a flattened except that it may import one of the ITP arithmetic
  ---   modules.
  --- * V and VS have types in M.
  --- * Elements in the type getType(V) must be constructable by the
  ---   constructor operators and memberships,
  ---   i.e.,  algebraic-sort?(getType(V)) = true .
  op expand-var : VariableSet Variable StringSet Goal ~> CondSubstSet .
  eq expand-var(VS, V, STS, G)
   = $expand-var-mb(VS, V, weak-ctor-mbs(getType(V), STS, G),
                    none) .

  op $expand-var-mb : VariableSet Variable MembAxSet CondSubstSet
          -> CondSubstSet .
  eq $expand-var-mb(VS, V, Mb Mbs, CSS)
   = $expand-var-mb(VS, V, Mbs, CSS ;
        cs(V <- substitute(term(Mb), freeVarSubst(vars-itp(Mb), VS)),
           substitute(condition(Mb), freeVarSubst(vars-itp(Mb), VS)))) .
  eq $expand-var-mb(VS, V, none, CSS) = CSS .

  op subst : CondSubstSet ExpansionTestSet CondSubst -> ExpansionSubstSet .
  eq subst(cs(SB, EqC) ; CSS, ETS, cs(SB', EqC'))
   = esub(substitute(ETS, SB),
          cs(substitute-rhs(SB', SB),
             substitute(EqC', SB) /\ EqC)) ;
     subst(CSS, ETS, cs(SB', EqC')) .
  eq subst(none, ETS, CS) = none .

  --- Applies substitution to right-hand side of each match equation in set.
  op substitute : MatchEqSet Substitution -> MatchEqSet .
  eq substitute(me(T, T') ; MES, SB)
   = me(T, substitute(T', SB)) ; substitute(MES, SB) .
  eq substitute((none).MatchEqSet, SB) = none .

  --- Applies substitution to right-hand side of each match equation in
  --- expansion test set.
  op substitute : ExpansionTestSet Substitution -> ExpansionTestSet .
  eq substitute(et(MES) ; ETS, SB)
   = et(substitute(MES, SB)) ; substitute(ETS, SB) .
  eq substitute((none).ExpansionTestSet, SB) = none .

  op rhs-vars : CondSubstSet ~> VariableSet .
  eq rhs-vars(CSS) = $rhs-vars(CSS, none) .

  op $rhs-vars : CondSubstSet VariableSet ~> VariableSet .
  eq $rhs-vars(cs(SB, EqC) ; CSS, VS)
   = $rhs-vars(CSS, $vars(EqC, $rhs-vars(SB, VS))) .
  eq $rhs-vars((none).CondSubstSet, VS) = VS .

  --- Returns substitution which when applied to first substitution causes
  --- it to equal second.
  op first-match : Module Substitution Substitution ~> Substitution? .
  eq first-match(M, SB, SB') = $first-match(M, SB, SB', none) .

  op $first-match : Module Substitution Substitution
        Substitution? ~> Substitution? .
  eq $first-match(M, V <- T ; SB, V <- T' ; SB', ResultSB)
   = $first-match(M, SB, SB',
        merge-subst(ResultSB, metaMatch(M, T, T', nil, 0))) .
  eq $first-match(M, V <- T ; SB, SB', ResultSB)
   = $first-match(M, SB, SB',
        merge-subst(ResultSB, metaMatch(M, T, V, nil, 0))) [owise].
  eq $first-match(M, none, V <- T' ; SB', ResultSB)
   = $first-match(M, none, SB', merge-subst(ResultSB, V <- T')) .
  eq $first-match(M, none, none, ResultSB) = ResultSB .
  eq $first-match(M, SB, SB', noMatch) = noMatch .

  --- Merge two substitutions that agree on bindings or return noMatch.
  --- Note that the bindings in the substitutions may not be denormalized.
  --- Varables that are not bound are considered "don't care".
  op merge-subst : Substitution Substitution? -> Substitution? .
  eq merge-subst(SB, SB') = $merge-subst(SB, SB', none) .
  eq merge-subst(SB, noMatch) = noMatch .

  --- Tail recursive implementation of merge-subst (above).
  op $merge-subst : Substitution Substitution? Substitution
        -> Substitution? .
  eq $merge-subst((V <- T) ; SB, (V <- T') ; SB', ResultSB)
   = if T == T' then
       $merge-subst(SB, SB', ResultSB ; (V <- T))
     else
       noMatch
     fi .
  eq $merge-subst(SB, SB', ResultSB) = SB ; SB' ; ResultSB .

  --- Returns true if predicates in first condition appear in second.
  op subset? : EqCondition EqCondition ~> Bool .
  eq subset?(T = T' /\ EqC, EqC' /\ T = T' /\ EqC'')
   = subset?(EqC, EqC' /\ T = T' /\ EqC'') .
  eq subset?(T = T' /\ EqC, EqC' /\ T' = T /\ EqC'')
   = subset?(EqC, EqC' /\ T = T' /\ EqC'') .
  eq subset?(T : S /\ EqC, EqC' /\ T : S /\ EqC'')
   = subset?(EqC, EqC' /\ T : S /\ EqC'') .
  eq subset?(T := T' /\ EqC, EqC' /\ T := T' /\ EqC'')
   = subset?(EqC, EqC' /\ T := T' /\ EqC'') .
  eq subset?(EqC, EqC') = EqC == nil [owise].

  --- Applies substitution to all conditional substitutions in set.
  op substitute-rhs : CondSubstSet Substitution -> CondSubstSet .
  eq substitute-rhs(cs(SB', EqC) ; CSS, SB)
   = cs(substitute-rhs(SB', SB), substitute(EqC, SB)) ;
     substitute-rhs(CSS, SB) .
  eq substitute-rhs((none).CondSubstSet, SB) = none .

  --- Normalizes each term in the condition.
  op normalizeEqCondition : Module EqCondition ~> EqCondition .
  eq normalizeEqCondition(M, T = T' /\ EqC)
   = getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, T'))
     /\ normalizeEqCondition(M, EqC) .
  eq normalizeEqCondition(M, T : S /\ EqC)
   = getTerm(metaNormalize(M, T)) : S /\ normalizeEqCondition(M, EqC) .
  eq normalizeEqCondition(M, T := T' /\ EqC)
   = getTerm(metaNormalize(M, T)) := getTerm(metaNormalize(M, T'))
     /\ normalizeEqCondition(M, EqC) .
  eq normalizeEqCondition(M, nil) = nil .

  --- Returns true if the first conditional substitution subsumes the second.
  --- A conditional substitution cs(SB, EqC) subsumes cs(SB', EqC') if there
  --- is a substitution \theta such that SB \theta = SB' and
  --- each condition A in EqC\theta is in EqC'.
  op subsumes? : Module CondSubst CondSubst ~> Bool .
  eq subsumes?(M, cs(SB, EqC), cs(SB', EqC'))
   = if first-match(M, SB, SB') :: Substitution then
       subset?(normalizeEqCondition(M, substitute(EqC, first-match(M, SB, SB'))),
               normalizeEqCondition(M, EqC'))
     else
       false
     fi .

  --- Adds substitution to set with subsumption checking.
  op add : Module CondSubstSet CondSubst -> CondSubstSet .
  eq add(M, CSS, CS) = $add(M, CSS, CS, none) .

  --- Implementation of add (above).
  op $add : Module CondSubstSet CondSubst CondSubstSet -> CondSubstSet .
  eq $add(M, CS ; CSS, CS', CSS')
   = if subsumes?(M, CS, CS') then
       CS ; CSS ; CSS'
     else if subsumes?(M, CS', CS) then
       $add(M, CSS, CS', CSS')
     else
       $add(M, CSS, CS', CS ; CSS')
     fi fi .
  eq $add(M, none, CS', CSS) = CS' ; CSS .

  --- Normalizes the root symbol of a term to eliminate uses of the iter.
  op $unflatten : Module Term ~> Term .
  ceq $unflatten(M, Q[T]) = qid(St:String)[$unflatten(M, T')]
   if pir(St:String, s NzN:NzNat) := parse-iter(Q)
   /\ T' := getTerm(metaNormalize(M,
          qid(St:String + "^" + string(NzN:NzNat, 10))[T])) .
  eq $unflatten(M, T) = T [owise].

  op make-me : Module Term Term ~> MatchEq .
  eq make-me(M, T, T') = me($unflatten(M, T), $unflatten(M, T')) [owise].

  --- Make match eq set from pairs of terms in set.
  op make-test : Module Qid TermList TermList MatchEqSet
      ~> ExpansionTestSet .
  ceq make-test(M, Q, (T1, T2), (T3, T4), MES)
    = et(make-me(M, T1, T3) ; make-me(M, T2, T4))
    ; et(make-me(M, T1, T4) ; make-me(M, T2, T3))
   if kindOf(M, T1) = kindOf(M, T2)
   /\ kindOf(M, T1) = kindOf(M, T3)
   /\ kindOf(M, T1) = kindOf(M, T4)
   /\ is-comm(M, Q, kindOf(M, T1)) .
  eq make-test(M, Q, TL, TL', MES) = $make-test(M, TL, TL', MES) [owise].

  --- Tail recursive implementation of make-test.
  op $make-test : Module TermList TermList MatchEqSet ~> ExpansionTestSet .
  eq $make-test(M, (T, TL), (T', TL'), MES)
   = if kindOf(M, T) == kindOf(M, T') then
       $make-test(M, TL, TL', make-me(M, T, T') ; MES)
     else
       none
     fi .
  eq $make-test(M, empty, (T, TL), MES) = none .
  eq $make-test(M, (T, TL), empty, MES) = none .
  eq $make-test(M, empty, empty, MES) = et(MES) .

  --- Generates a substitution mapping each variable to itself.
  op id-sub : VariableSet -> Substitution .
  eq id-sub(V ; VS) = (V <- V) ; id-sub(VS) .
  eq id-sub(none) = none .

  --- Predicate that is used to process matchEqSet to extract variables that
  --- should be expanded and match equations that should be considered after
  --- expanding.
  op simplify : StringSet Goal ExpansionTestSet ~> ExpansionTestSet .
  eq simplify(STS, G, et(me(T, GT) ; MES) ; ETS)
   = if metaMatch(getMod(G), T, GT, nil, 0) :: Substitution then
       simplify(STS, G, et(MES) ; ETS)
     else
       simplify(STS, G, ETS)
     fi .
  --- If pattern is ground and does not match subject we can immediately
  --- eliminate it.
  ceq simplify(STS, G, et(me(GT, Q[TL]) ; MES) ; ETS)
    = simplify(STS, G, ETS)
   if metaMatch(getMod(G), Q[TL], GT, nil, 0) = noMatch .
  ceq simplify(STS, G, et(me(V, T) ; MES) ; ETS)
    = simplify(STS, G, et(MES) ; ETS)
   if sortLeq(getMod(G), leastSort(getMod(G), T), getType(V)) .
  ceq simplify(STS, G, et(me(V, T) ; MES) ; ETS)
    = simplify(STS, G, ETS)
   if share-subsort?(getMod(G), leastSort(getMod(G), T), getType(V))
        = false .
  ceq simplify(STS, G, et(me(T, V) ; MES) ; ETS)
    = simplify(STS, G, ETS)
   if type-compatible?(STS, G, T, getType(V)) = false .
  eq simplify(STS, G, et(me(Q[TL], Q'[TL']) ; MES) ; ETS)
   = if Q == Q' then
       simplify(STS, G, make-test(getMod(G), Q, TL, TL', MES) ; ETS)
     else
       simplify(STS, G, ETS)
     fi .
  eq simplify(STS, G, ETS) = ETS [owise].

  op expandable-vars1 : Module MatchEqSet ~> ExpandableVarsResult1 .
  eq expandable-vars1(M, MES) = $expandable-vars1(M, MES, none, none) .

  op $expandable-vars1 : Module MatchEqSet MatchEqSet VariableSet
      ~> ExpandableVarsResult1 .
  eq $expandable-vars1(M, me(T, V) ; MES, MES', VS)
   = if should-expand?(M, T, getType(V)) then
       $expandable-vars1(M, MES, me(T, V) ; MES', V ; VS)
     else
       $expandable-vars1(M, MES, MES', VS)
     fi .
  eq $expandable-vars1(M, MES, MES', VS) = evr1(MES ; MES', VS) [owise].

  op expandable-vars : Module ExpansionTestSet ~> ExpandableVarsResult .
  eq expandable-vars(M, ETS) = $expandable-vars(M, ETS, none, none) .

  op $expandable-vars : Module ExpansionTestSet
        ExpansionTestSet DemandedVarMap ~> ExpandableVarsResult .
  ceq $expandable-vars(M, et(MES') ; ETS', ETS, DVM)
    = if VS :: NeVariableSet then
        $expandable-vars(M, ETS', et(MES) ; ETS, inc-vars(VS, DVM))
      else
        $expandable-vars(M, ETS', ETS, DVM)
      fi
   if evr1(MES, VS) := expandable-vars1(M, MES') .
  eq $expandable-vars(M, none, ETS, DVM) = evr(ETS, DVM) .

  --- Expands each term in list again equations in goal.
  op expand : StringSet Goal ITPTermSet ~> CondSubstSet .
  --- TODO:
  ---  * Variables should be instantiated only when they are demanded by the
  ---    most number of patterns,
  ---  * Terms should stop being expanded when they match a pattern term
  ---    -- optionally allow users to select which patterns to stop narrowing
  ---     and which do not.
  ---  * We should improve the use of secondary constructors so that instead
  ---    of using a QidSet, we expand terms based on the pattern we are
  ---    trying to match against.
  eq expand(STS, G, TS)
   = $expand(STS, G,
             esub(make-ets*(getMod(G), TS), cs(id-sub(vars-itp(TS)), nil)),
             none) .

  --- Implementation of expand (above).
  op $expand : StringSet Goal ExpansionSubstSet CondSubstSet
        -> CondSubstSet .
  eq $expand(STS, G, esub(ETS, CS) ; ESS, CSS)
   = $parse-filter(expandable-vars(getMod(G), simplify(STS, G, ETS)),
                   STS, G, CS, ESS, CSS) .
  eq $expand(STS, G, none, CSS) = CSS .

  --- Helper function that parses filter result.
  op $parse-filter : ExpandableVarsResult StringSet Goal CondSubst
        ExpansionSubstSet CondSubstSet -> CondSubstSet .
  eq $parse-filter(evr(ETS, NeDVM), STS, G, CS, ESS, CSS)
   = $expand(STS, G,
             subst(
               expand-var(rhs-vars(CS), find-var(NeDVM), STS, G), ETS, CS) ;
             ESS,
             CSS) .
  eq $parse-filter(evr(ETS, none), STS, G, CS, ESS, CSS)
   = $expand(STS, G, ESS,
        add(getMod(G),
            CSS,
            substitute-rhs(CS, newVars(rhs-vars(CS), getVarNum(G))))) .

  --- Returns left-hand-side of all equations in module that share a subsort
  --- with given type in module.
  op all-lhs-eq-share-subsort : Module Type -> ITPTermSet .
  eq all-lhs-eq-share-subsort(M, Tp)
   = $all-lhs-eq-share-subsort(getEqs(M), M, Tp, none) .

  op $all-lhs-eq-share-subsort : EquationSet Module Type ITPTermSet -> ITPTermSet .
  eq $all-lhs-eq-share-subsort(Eq Eqs, M, Tp, TS)
   = $all-lhs-eq-share-subsort(Eqs, M, Tp,
        if share-subsort?(M, leastSort(M, lhs(Eq)), Tp)
              and-then isAx?(attrSet(Eq)) then
          TS ; lhs(Eq)
        else
          TS
        fi) .
  eq $all-lhs-eq-share-subsort(none, M, Tp, TS) = TS .

  --- Returns order-sorted condition which holds iff the substitution is an
  --- order-sorted substitution.
  op os-cond : Module Substitution ~> EqCondition .
  eq os-cond(M, SB) = $os-cond(M, SB, nil) .

  op $os-cond : Module Substitution EqCondition ~> EqCondition .
  eq $os-cond(M, (V <- T) ; SB, EqC)
   = if sortLeq(M, leastSort(M, T), getType(V)) then
       $os-cond(M, SB, EqC)
     else
       $os-cond(M, SB, EqC /\ T : getType(V))
     fi .
  eq $os-cond(M, none, EqC) = EqC .

  --- Applies each conditional substitution to substitution.
  --- Each conditional substitution has condition to ensure it is an
  --- order-sorted substitution.
  op os-subst-rhs : Module Substitution CondSubstSet ~> CondSubstSet .
  eq os-subst-rhs(M, SB, CSS) = $os-subst-rhs(M, SB, CSS, none) .

  op $os-subst-rhs : Module Substitution CondSubstSet CondSubstSet ~>
        CondSubstSet .
  eq $os-subst-rhs(M, SB, cs(SB', EqC) ; CSS, CSS')
   = $os-subst-rhs(M, SB, CSS, CSS' ;
       cs(substitute-rhs(SB, SB'),
          $os-cond(M, substitute-rhs(SB, SB'), EqC))) .
  eq $os-subst-rhs(M, SB, none, CSS) = CSS .

  --- Creates substitution mapping each variable in first set to unique
  --- variable at the kind level.
  op vars-to-kind : Module VariableSet -> Substitution .
  eq vars-to-kind(M, VS) = $vars-to-kind(M, VS, none, none) .

  --- Implementation of vars-to-kind.
  op $vars-to-kind : Module VariableSet VariableSet Substitution
        ~> Substitution .
  eq $vars-to-kind(M, V ; V ; VS, VS', SB)
   = $vars-to-kind(M, V ; VS, VS', SB) .
  eq $vars-to-kind(M, V ; VS, VS', SB)
   = $vars-to-kind(M, VS,
                   nextFreeVar(set-type-to-kind(M, V), VS') ; VS',
                   SB ; (V <- nextFreeVar(set-type-to-kind(M, V), VS'))) .
  eq $vars-to-kind(M, none, VS', SB) = SB .

  --- Returns all substitutions \theta such that Seed\theta is equivalent
  --- modulo axioms to a subterm in T.
  op matching-subterms : Module Term EqCondition Term ~> CondSubstSet .
  eq matching-subterms(M, Seed, EqC, T)
   = $matching-subterms(M, Seed, EqC, T, nil, none) .

  op $matching-subterms : Module Term EqCondition Term EqCondition
      CondSubstSet
      ~> CondSubstSet .
  eq $matching-subterms(M, Seed, T' = T'' /\ EqC', T, EqC, CSS)
   = $matching-subterms(M, Seed, EqC', T,
        T' = T'' /\ EqC,
        $matching-subterms1(M, Seed, T', EqC, 0,
          $matching-subterms1(M, Seed, T'', EqC, 0, CSS))) .
  eq $matching-subterms(M, Seed, T' : S /\ EqC', T, EqC, CSS)
   = $matching-subterms(M, Seed, EqC', T,
        T' : S /\ EqC,
        $matching-subterms1(M, Seed, T', EqC, 0, CSS)) .
  eq $matching-subterms(M, Seed, nil, T, EqC, CSS)
   = $matching-subterms1(M, Seed, T, EqC, 0, CSS) .

  --- Returns all subterms of terms in list along with terms in set.
  op $matching-subterms1 : Module Term Term EqCondition Nat CondSubstSet
        ~> CondSubstSet .
  ceq $matching-subterms1(M, Seed, T, EqC, N, CSS)
    = $matching-subterms1(M, Seed, T, EqC, s N,  CSS ; cs(SB, EqC))
   if { SB, Con } := metaXmatch(M, Seed, T, nil, 0, unbounded, N) .
  ceq $matching-subterms1(M, Seed, T, EqC, N, CSS)
    = CSS
   if noMatch := metaXmatch(M, Seed, T, nil, 0, unbounded, N) .


  op append-cond : CondSubstSet EqCondition -> CondSubstSet .
  eq append-cond(cs(SB, EqC') ; CSS, EqC)
   = cs(SB, EqC' /\ EqC) ; append-cond(CSS, EqC) .
  eq append-cond(none, EqC) = none .

  --- Replaces type in variable with kind of type.
  op set-type-to-kind : Module Variable ~> Variable .
  eq set-type-to-kind(M, V)
   = qid(string(getName(V)) + ":" + string(getKind(M, getType(V)))) .

  --- Returns true if the condition has matching expressions with the form
  --- T := T' .
  op matchings? : EqCondition -> Bool .
  eq matchings?(EqC /\ T := T' /\ EqC') = true .
  eq matchings?(EqC) = false [owise].

  --- specialized-eqs(M, T) returns set of equations in M.
  --- { l\theta = r\theta if C\theta | l = r if C in getEqs(M)
  ---                               /\ T = l\theta }.
  --- Performs checks to guarantee that variables in resulting equations are
  --- subset of variables in T.
  op specialized-eqs : Module Term ~> EquationSet .
  eq specialized-eqs(M, T)
   = $specialized-eqs(M, T, getEqs(M), none) .

  --- Tail-recursive implementation of specialized-eqs.
  op $specialized-eqs : Module Term EquationSet EquationSet ~> EquationSet .
  eq $specialized-eqs(M, T, Eq Eqs', Eqs)
   = $specialized-eqs(M, T, Eqs',
       if (kindOf(M, T) == kindOf(M, lhs(Eq)))
           and-then not matchings?(condition(Eq)) then
         $specialized-eqs1(M, T, Eq, 0, Eqs)
       else
         Eqs
       fi) .
  eq $specialized-eqs(M, T, none, Eqs) = Eqs .

  --- $specialized-eqs1(M, T, Eq, N, Eqs) returns Eqs plus specializations
  --- Eq' of Eq such that T =_Ax lhs(Eq').
  op $specialized-eqs1 : Module Term Equation Nat EquationSet ~>
        EquationSet .
  ceq $specialized-eqs1(M, T, Eq, N, Eqs)
    = $specialized-eqs1(M, T, Eq, s N, Eqs substitute(Eq, SB))
   if SB := metaMatch(M, lhs(Eq), T, nil, N) .
  ceq $specialized-eqs1(M, T, Eq, N, Eqs) = Eqs
   if noMatch = metaMatch(M, lhs(Eq), T, nil, N) .

  --- eq-instances-rhs-subst(M, T, Eqs) returns substitutions that cause
  --- T to match a term in the right-hand side or condition of equation.
  op eq-instances-rhs-subst : Module Term EquationSet ~> CondSubstSet .
  eq eq-instances-rhs-subst(M, T, Eqs)
   = $eq-instances-rhs-subst(M, T, Eqs, none) .

  --- Implementation of eq-instances-rhs-subterms.
  op $eq-instances-rhs-subst : Module Term EquationSet
        CondSubstSet ~> CondSubstSet .
  eq $eq-instances-rhs-subst(M, T, Eq Eqs, CSS)
   = $eq-instances-rhs-subst(M, T, Eqs, CSS ;
        matching-subterms(M, T, condition(Eq), rhs(Eq))) .
  eq $eq-instances-rhs-subst(M, T, Eqs, CSS) = CSS [owise].

  --- Constructs an expansion test set for each term in list.
  op make-ets* : Module ITPTermSet -> ExpansionTestSet .
  eq make-ets*(M, T ; TS)
   = make-ets(M, all-lhs-eq-share-subsort(M, leastSort(M, T)), T) ;
     make-ets*(M, TS) .
  eq make-ets*(M, none) = none .

  --- Makes initial expansion test set from set of patterns and seed term.
  op make-ets : Module ITPTermSet Term -> ExpansionTestSet .
  eq make-ets(M, T ; TS, Seed)
   = et(make-me(M, T, Seed)) ; make-ets(M, TS, Seed) .
  eq make-ets(M, none, Seed) = none .

  --- Returns hypothesis for coverset induction.
  op coverset-hyps : Module Formula Term Substitution -> Formula .
  eq coverset-hyps(M, Alpha, T, SB)
   = conjoin-subst(Alpha,
                   os-subst-rhs(M, vars-to-kind(M, vars-itp(T)),
                     eq-instances-rhs-subst(M,
                       substitute(T, vars-to-kind(M, vars-itp(T))),
                       specialized-eqs(M, substitute(T, SB))))) .

  --- Returns induction scheme for cov-split command.
  op cov-split-scheme : StringSet Goal Term ITPTermSet ~> FormulaSet .
  eq cov-split-scheme(STS, G, T, TS)
   = $cov-split-scheme(G, T, expand(STS, G, T ; TS), none) .

  --- Tail recursive implementation of cov-split-scheme.
  op $cov-split-scheme : Goal Term CondSubstSet FormulaSet ~> FormulaSet .
  eq $cov-split-scheme(G, T, cs(SB, EqC) ; CSS, FS)
   = $cov-split-scheme(G, T, CSS, FS ;
        normalize(
          AQuantification(
            rhs-vars(SB),
            implication(
              conjunction(condToFormula(EqC),
                          coverset-hyps(getMod(G),
                            stripAQuantVars(vars-itp(T), getFormula(G)),
                            T,
                            SB)),
              substitute(stripAQuantVars(lhs-vars(SB), getFormula(G)), SB))),
          getMod(G))) .
  eq $cov-split-scheme(G, T, none, FS) = FS .
endfm

--- Defines function extract rules which parses a formula to extract
--- memberships and equations that could be added to the module.
fmod ITP-RULE-EXTRACTION is
  pr CONVERSION .
  pr ITP-EXT-MOD .
  pr ITP-EXT-TERM .
  pr META-MODULE-EXT .
  pr ITP-CTORS .
  pr ITP-LOGIC-OPS .

  sort ExtractRuleResult .
  op err : MembAxSet EquationSet FormulaSet -> ExtractRuleResult [ctor].

  var Alpha Beta : Formula .
  var CAF : ConjAtomic .
  var Eq : Equation .
  var Eqs Eqs' : EquationSet .
  var FS FS' : FormulaSet .
  var Mb : MembAx .
  var Mbs Mbs' : MembAxSet .
  var N : Nat .
  var S : Sort .
  var St : String .
  var T T' : Term .
  var VS VS' : VariableSet .

  --- Adds additional condition to rules in set.
  op add-antc : ConjAtomic ExtractRuleResult -> ExtractRuleResult .
  eq add-antc(CAF, err(Mbs, Eqs, FS))
   = err(prepend-cond(formulaToCond(CAF), Mbs),
         prepend-cond(formulaToCond(CAF), Eqs),
         add-antc-to-all(CAF, FS)) .

  --- Returns conjunction of two extract rule results.
  op conjoin : ExtractRuleResult ExtractRuleResult
        -> ExtractRuleResult [ctor].
  eq conjoin(err(Mbs, Eqs, FS), err(Mbs', Eqs', FS'))
   = err(Mbs Mbs', Eqs Eqs', FS ; FS') .

  --- Adds aquantifier to uninterpreted formula in extract rule result.
  op aquant-vars : VariableSet ExtractRuleResult -> ExtractRuleResult [ctor].
  eq aquant-vars(VS, err(Mbs, Eqs, FS))
   = err(Mbs, Eqs, add-aquant-to-all(VS, FS)) .

  --- Returns ExtractRuleResult equivalent to given formula where equations
  --- and memberships that can be directly added to module are extracted.
  op extract-rules : Formula -> ExtractRuleResult .
  eq extract-rules(Alpha) = $extract-rules(Alpha, none) .

  --- Implementation of extract-rules.
  --- The variable set contains variables that the left-hand side of the
  --- membership must contain.
  op $extract-rules : Formula VariableSet -> ExtractRuleResult .
  eq $extract-rules(trueFormula, VS) = err(none, none, none) .
  eq $extract-rules(equality(T, T'), VS)
   = if (vars-itp(T') ; VS) subset vars-itp(T) then
       err(none, eq T = T' [none]., none)
     else
       err(none, none, equality(T, T'))
     fi .
  eq $extract-rules(sortP(T, S), VS)
   = if VS subset vars-itp(T) then
       err(mb T : S [none]., none, none)
     else
       err(none, none, sortP(T, S))
     fi .
  eq $extract-rules(conjunction(Alpha, Beta), VS)
   = conjoin($extract-rules(Alpha, VS), $extract-rules(Beta, VS)) .
  eq $extract-rules(implication(CAF, Alpha), VS)
   = add-antc(CAF, $extract-rules(Alpha, free-vars(CAF) ; VS)) .
  eq $extract-rules(AQuantification(VS', Alpha), VS)
   = aquant-vars(VS', $extract-rules(Alpha, VS)) .
  eq $extract-rules(Alpha, VS) = err(none, none, Alpha) [owise].
endfm

fmod ITP-PROOF-STATE is
  pr ITP-CTORS .
  pr ITP-PRETTY-PRINT .

  sort ProofState .
  op ps : GoalList -> ProofState [ctor].

  var Alpha : Formula .
  var G : Goal .
  var GFS : GoalFieldSet .
  var GL GL' NewGL : GoalList .
  var Mod : FModule .
  var N1 N2 : Nat .
  var ST : String .

  *** Added by Camilo to compute the number of open goals
  *** in a proof state
  op number-of-goals : ProofState -> Nat .
  eq number-of-goals(ps(GL)) = number-of-goals(GL) .

  --- Prints goals in list.
  op meta-pretty-print-list : String GoalList ~> QidList .
  eq meta-pretty-print-list(ST, G GL)
   = '\n '================================= '\n
     if getName(G) == ST then
       'label-sel: qid(getName(G))
     else
       'label: qid(getName(G))
     fi
     '\n '================================= '\n
     meta-pretty-print-Formula(getMod(G), getFormula(G)) '\n
     meta-pretty-print-list(ST, GL) .
  eq meta-pretty-print-list(ST, nil)
   = '\n '+++++++++++++++++++++++++++++++++ '\n .

  op meta-pretty-print : String ProofState ~> QidList .
  eq meta-pretty-print(ST, ps(GL)) = meta-pretty-print-list(ST, GL) .

  op emptyProofState : -> ProofState .
  eq emptyProofState = ps(nil) .

  --- Returns goal with given name.
  op getGoal : String ProofState ~> Goal .
  eq getGoal(ST, ps(GL goal(name: ST ; GFS) GL')) = goal(name: ST ; GFS) .
  eq getGoal(ST, ps(GL)) = nil [owise].

  --- Return goal after one with given name in state.
  op nextGoal : String ProofState ~> String .
  eq nextGoal(ST, ps(GL goal(name: ST ; GFS) G GL')) = getName(G) .
  eq nextGoal(ST, ps(GL G goal(name: ST ; GFS))) = getName(G) .
  eq nextGoal(ST, ps(goal(name: ST ; GFS))) = "" .

  --- Replace the given goal in the proofstate.
  op replaceGoal : String GoalList ProofState ~> ProofState .
  eq replaceGoal(ST, NewGL, ps(GL goal(name: ST ; GFS) GL'))
   = ps(GL NewGL GL') .
endfm

fmod ITP-LABELED-RULES is
  pr ITP-CTORS .
  pr ITP-RULE-EXTRACTION .
  pr ITP-PRETTY-PRINT .

  sort NameFn .
  op prev-hyp-fn : String Nat -> NameFn [ctor].
  op hyp-fn : Nat -> NameFn [ctor].
  op lem-fn : String NzNat -> NameFn [ctor].

  --- A set of extracted rules after being labeled with ITP metadata.
  sort LabeledRules .
  op lr : MembAxSet EquationSet LabeledFormulaSet -> LabeledRules [ctor].

  var A : Attr .
  var Eq : Equation .
  var Eqs Eqs' : EquationSet .
  var ERR : ExtractRuleResult .
  var Alpha : Formula .
  var FS : FormulaSet .
  var G : Goal .
  var LFS : LabeledFormulaSet .
  var LR : LabeledRules .
  var M : Module .
  var Mb : MembAx .
  var Mbs Mbs' : MembAxSet .
  var N : Nat .
  var NF : NameFn .
  var QI : Qid .
  var St St' : String .

  --- Returns number of separate formulas in extract rule result.
  op |_| : LabeledRules -> Nat .
  eq | lr(Mbs, Eqs, LFS) | = | Mbs | + | Eqs | + | LFS | .

  --- Returns true if no membership or equations are in extraction result.
  op is-empty? : LabeledRules -> Bool .
  eq is-empty?(lr(none, none, none)) = true .
  eq is-empty?(LR) = false [owise].

  op name : NameFn -> String .
  eq name(prev-hyp-fn(St, N)) = St .
  eq name(hyp-fn(N)) = "hyp-" + string(N, 10) .
  eq name(lem-fn(St, N))
   = if N == 1 then St else St + string(N, 10) fi .

  op attr : NameFn -> AttrSet .
  eq attr(prev-hyp-fn(St, N))
   = metadata("|cat:hyp|") label(qid(St)) .
  eq attr(hyp-fn(N))
   = metadata("|cat:hyp|") label(qid(name(hyp-fn(N)))) .
  eq attr(lem-fn(St, N))
   = metadata("|cat:lem|") label(qid(name(lem-fn(St, N)))) .

  op next : NameFn -> NameFn .
  eq next(prev-hyp-fn(St, N)) = hyp-fn(N) .
  eq next(hyp-fn(N)) = hyp-fn(s N) .
  eq next(lem-fn(St, N)) = lem-fn(St, s N) .

  --- Labels rules in extract rule result for adding to goal.
  op label-rules : ExtractRuleResult NameFn ~> LabeledRules .
  eq label-rules(ERR, NF)
   = $label-rules(ERR, NF, none, none, none) .

  --- Implementation of label-rules.
  op $label-rules : ExtractRuleResult NameFn
                    MembAxSet EquationSet LabeledFormulaSet ~> LabeledRules .
  eq $label-rules(err(Mb Mbs, Eqs, FS), NF, Mbs', Eqs', LFS)
   = $label-rules(err(Mbs, Eqs, FS), next(NF),
       Mbs' setAttrSet(attr(NF), Mb),
       Eqs',
       LFS) .
  eq $label-rules(err(none, Eq Eqs, FS), NF, Mbs', Eqs', LFS)
   = $label-rules(err(none, Eqs, FS), next(NF),
       Mbs',
       Eqs' setAttrSet(attr(NF), Eq),
       LFS) .
  eq $label-rules(err(none, none, Alpha ; FS), NF, Mbs', Eqs', LFS)
   = $label-rules(err(none, none, FS), next(NF),
       Mbs', Eqs', LFS ; pair(name(NF), Alpha)) .
  eq $label-rules(err(none, none, none), NF, Mbs', Eqs', LFS)
   = lr(Mbs', Eqs', LFS) .

  --- Adds result of rule extraction to goal.
  op add-rules : LabeledRules Goal ~> Goal .
  eq add-rules(lr(Mbs, Eqs, LFS), G)
   = setMod(addMbsITP(Mbs, addEqsITP(Eqs, getMod(G))),
            addLabeledFormulas(LFS, G)) .

  op mpp-lfs : Module LabeledFormulaSet ~> QidList .
  eq mpp-lfs(M, pair(St, Alpha) ; LFS)
   = '`[ qid(St) '`] ': meta-pretty-print-Formula(M, Alpha) '\n
     mpp-lfs(M, LFS) .
  eq mpp-lfs(M, none) = nil .

  op mpp-rules : LabeledRules Module ~> QidList  .
  eq mpp-rules(lr(Mbs, Eqs, LFS), M)
   = mpp-mbs(M, Mbs) mpp-eqs(M, Eqs) mpp-lfs(M, LFS) .
endfm

--- Code for checking whether a given module and formula is valid.
fmod ITP-VALIDITY-CHECKING is
---  pr EXT-PRES-ARITH .
  pr ITP-CTORS .

  var Alpha Beta Gamma Delta : Formula .
  var LFS : LabeledFormulaSet .
  var Mod : Module .
  var Label : String .

  -------------------
  -------------
  --- function:
  -------------
---  op getExtLinIneq : LabeledFormulaSet Module Module -> Formula .
---  eq getExtLinIneq((none).LabeledFormulaSet, ExtMod, Mod) = trueFormula .
---  eq getExtLinIneq(pair(Label, Alpha) ; LFS, ExtMod, Mod)
---   = if isExtLinIneq?(Alpha, ExtMod) then
---       conjunction(reduce(Alpha, Mod),
---                   getExtLinIneq(LFS, ExtMod, Mod))
---     else
---       getExtLinIneq(LFS, ExtMod, Mod)
---     fi .

  -------------
  --- function: createNewSolutionPlus
  -------------
---  op createNewSolutionPlus : Module LabeledFormulaSet -> Formula .
---  ceq createNewSolutionPlus(Mod, LFS)
---    = createNewSolutionAux2(Mod,
---        toDNFAux(
---          toDNF(x-elimLinIneqSortInfo(
---                  conjunction(
---                    x-getLinIneqVarSortInfo(x-getVarInLinIneq(Gamma)),
---                    Gamma)))))
---   if Alpha := getGroundLinIneqs(Mod)
---   /\ Delta := getExtLinIneq(LFS, extModSupInf(Mod), setEqs(none, Mod))
---   /\ Beta := preProcFormulaNew(conjunction(Alpha, Delta), Mod)
---   /\ Gamma := x-procLinIneq(Beta) .
endfm

--- Provides operators for parsing a formula to extract an alternative
--- constructor definition from the module.
fmod ITP-CTOR-DEF is
  pr ITP-CTORS .

  var Alpha Beta : Formula .
  var CAF : ConjAtomic .
  var GT : GroundTerm .
  var S : Sort .
  var T : Term .
  var V : Variable .
  var VS : VariableSet .

  --- Extracts memberships out of a user formula.
  --- Formula should be a disjunction of existentially quantified
  --- conjunctions.
  op parse-mbs : Variable Formula ~> MembAxSet .
  eq parse-mbs(V, disjunction(Alpha, Beta))
   = parse-mbs(V, Alpha) parse-mbs(V, Beta) .
  eq parse-mbs(V, falseFormula) = none .

  eq parse-mbs(V, sortP(V, S))
   = (mb qid("X:" + string(S)) : getType(V) [none].) .

  eq parse-mbs(V, equality(GT, V))
   = (mb GT : getType(V) [none].) .

  ceq parse-mbs(V, conjunction(equality(GT, V), CAF))
    = (cmb GT : getType(V) if formulaToCond(CAF) [none].)
   if free-vars(CAF) = none .

  ceq parse-mbs(V, EQuantification(VS, equality(T, V)))
    = (mb T : getType(V) [none].)
   if V in VS = false
   /\ vars-itp(T) = VS .

  ceq parse-mbs(V, EQuantification(VS, conjunction(equality(T, V), CAF)))
    =  (cmb T : getType(V) if formulaToCond(CAF) [none].)
   if V in VS = false
   /\ vars-itp(T) = VS
   /\ free-vars(CAF) subset VS .
endfm

--- Provides operation for defining new equivalence relations and
--- propagating equivalences.
fmod ITP-EQUIV-PROPAGATE is
  pr ITP-CTORS .
  pr ITP-NEW-VAR .
  pr ITP-LABELED-RULES .
  pr ITP-INTERNAL-CONSTANTS .

  --- Type used for indicating pairs of equivalent terms.
  sort EquivTerm .
  op eq-term : Term Term -> EquivTerm [ctor comm].

  --- Set of equivalent terms.
  sort EquivTermSet .
  subsort EquivTerm < EquivTermSet .
  op none : -> EquivTermSet [ctor].
  op _;_ : EquivTermSet EquivTermSet -> EquivTermSet
           [ctor assoc comm id: none].
  eq ET:EquivTerm ; ET:EquivTerm = ET:EquivTerm .

  --- Sort used for indicating propagation result.
  sort EquivPropagateResult .
  --- First variable contains new module, Second contains number of new
  --- hypotheses.
  op epr : Module Nat -> EquivPropagateResult [ctor].
  op conflict : -> EquivPropagateResult [ctor].

  var AS AS1 AS2 : AttrSet .
  var TrueCon : Constant .
  var EPR : EquivPropagateResult .
  var ERS : EquivRelationSet .
  var Eq : Equation .
  var Eqs NewEqs : EquationSet .
  var ETS : EquivTermSet .
  var G : Goal .
  var M : Module .
  var HypNum N : Nat .
  var Ops : OpDeclSet .
  var F : Qid .
  var S : Sort .
  var Label RefLabel TransLabel : String .
  var Tp Tp1 Tp2 : Type .
  var T T' T1 T2 T3 : Term .
  var V1 V2 V3 : Variable .

  --- Returns equations in sets that are hypotheses.
  op getEquivTerms : Module Qid Sort -> EquivTermSet .
  eq getEquivTerms(M, F, S)
   = $getEquivTerms(M, F, S, true-con(M), getEqs(M), none) .

  --- Tail recursive implementation of getEquivTerms (above)
  op $getEquivTerms : Module Qid Sort Constant EquationSet EquivTermSet
        -> EquivTermSet .
  eq $getEquivTerms(M, F, S, TrueCon, (eq F[T, T'] = TrueCon [AS].) Eqs, ETS)
   = if sameKind(M, kindOf(M, T), S) and-then
        sameKind(M, kindOf(M, T'), S) then
       $getEquivTerms(M, F, S, TrueCon, Eqs, eq-term(T, T') ; ETS)
     else
       $getEquivTerms(M, F, S, TrueCon, Eqs, ETS)
     fi .
  eq $getEquivTerms(M, F, S, TrueCon, Eqs, ETS) = ETS [owise].

  --- mk-reflex(N, F, S) returns a sentence stating that F is reflexive on
  --- inputs with sort S.
  op mk-reflex : Nat Qid Sort -> Formula .
  eq mk-reflex(N, F, S)
   = AQuantification(newVar(N, S, 0),
       equality(F[newVar(N, S, 0), newVar(N, S, 0)], 'true.Bool)) .

  --- mk-trans(N, F, S) returns a sentence stating that F is transitive on
  --- inputs with sort S.
  op mk-trans : Nat Qid Sort -> Formula .
  ceq mk-trans(N, F, S)
    = AQuantification(V1 ; V2 ; V3,
       implication(
         conjunction(equality(F[V1, V2], 'true.Bool),
                     equality(F[V2, V3], 'true.Bool)),
         equality(F[V1, V3], 'true.Bool)))
   if V1 := newVar(N, S, 0)
   /\ V2 := newVar(N, S, 1)
   /\ V3 := newVar(N, S, 2) .

  --- Defines new equivalence relation in goal after adding lemmas that
  --- must be proven.
  --- Note: Assumes is-comm-rel(getMod(G), F, S) is true.
  op defequiv : Goal Qid Sort ~> GoalList .
  ceq defequiv(G, F, S)
    = setFormula(normalize(mk-reflex(getVarNum(G), F, S), M),
        setName(RefLabel, incVarNum(G)))
      setFormula(normalize(mk-trans(getVarNum(G), F, S), M),
        setName(TransLabel, incVarNum(G)))
      if T == true-con(M) then
        --- Don't add reflexitivity equation.
        add(equiv-rel(F, S), G)
      else
        --- Add reflexitivity equation.
        setMod(addEqsITP((eq T = true-con(M) [mk-lem(RefLabel)].), M),
               add(equiv-rel(F, S), G))
      fi
   if is-comm-rel(getMod(G), F, S)
   /\ M := getMod(G)
   /\ T := getTerm(metaReduce(M,
             F[qid("X:" + string(S)), qid("X:" + string(S))]))
   /\ RefLabel  := "*er-" + string(F) + "-reflex-" + string(S) + AT + "0"
   /\ TransLabel := "*er-" + string(F) + "-trans-" + string(S) + AT + "0" .

  --- Applies equivalence propagation on all equivalence relations in goal.
  op equiv-propagate : Goal -> GoalList .
  ceq equiv-propagate(G) = setMod(M, setHypNum(N, G))
   if epr(M, N)
        := $eprop(get-equiv-relations(G), epr(getMod(G), getHypNum(G))) .
  ceq equiv-propagate(G) = nil
   if conflict
         = $eprop(get-equiv-relations(G), epr(getMod(G), getHypNum(G))) .

  op $eprop : EquivRelationSet EquivPropagateResult
      -> EquivPropagateResult .
  eq $eprop(equiv-rel(F, S) ; ERS, epr(M, N))
   = $eprop(ERS, $eprop1(F, S, getEquivTerms(M, F, S), epr(M, N))) .
  eq $eprop(ERS, conflict) = conflict .
  eq $eprop(none, EPR) = EPR .

  --- Implementation of equivalence propagation for 1 qid and sort.
  op $eprop1 : Qid Sort EquivTermSet EquivPropagateResult
          -> EquivPropagateResult .
  ceq $eprop1(F, S, eq-term(T1, T2) ; eq-term(T1, T3) ; ETS, epr(M, N))
    = $eprop1(F, S, eq-term(T1, T2) ; eq-term(T1, T3) ; eq-term(T, T') ; ETS,
             epr(addEqsITP(eq F[T, T'] = true-con(M) [mk-hyp(N)]., M), N + 1))
   if sortLeq(M, leastSort(M, T1), S)
   /\ sortLeq(M, leastSort(M, T2), S)
   /\ sortLeq(M, leastSort(M, T3), S)
   /\ F[T, T'] := getTerm(metaReduce(M, F[T2, T3])) .

  ceq $eprop1(F, S, eq-term(T1, T2) ; eq-term(T1, T3) ; ETS, epr(M, N))
    = conflict
   if sortLeq(M, leastSort(M, T1), S)
   /\ sortLeq(M, leastSort(M, T2), S)
   /\ sortLeq(M, leastSort(M, T3), S)
   /\ false-con(M) = getTerm(metaReduce(M, F[T2, T3])) .
  eq $eprop1(F, S, ETS, conflict) = conflict .
  eq $eprop1(F, S, ETS, EPR) = EPR [owise].
endfm

--- Provides operators for simplification.
fmod ITP-SIMP is
  pr ITP-CTORS .
  pr ITP-REDUCE .
  pr ITP-LABELED-RULES .

  --- Returns result of simplifying module.
  sort SimpResult .
  --- Result with new module and new hypothesis number.
  op sr : Module Nat -> SimpResult [ctor].
  --- Result indicating that simplifying module introduced an inconsistency.
  op inconsistent : -> SimpResult [ctor].

  var AS : AttrSet .
  var B Changed : Bool .
  var C C' : Constant .
  var CAF : ConjAtomic .
  var EqC : EqCondition .
  var Eq : Equation .
  var Eqs Eqs' : EquationSet .
  var Alpha Alpha' Beta Beta' : Formula .
  var FS : FormulaSet .
  var Mb NewMb : MembAx .
  var Mbs Mbs' : MembAxSet .
  var M M' : Module .
  var N : Nat .
  var NF : NameFn .
  var HypNum : Nat .
  var S : Sort .
  var SR : SimpResult .
  var T T' : Term .
  var VS : VariableSet .

  --- Returns true if each variable in the condition is in the set or
  --- defined before use.
  op check-vars : EqCondition VariableSet -> Bool .
  eq check-vars(T : S /\ EqC, VS)
   = (vars-itp(T) subset VS) and-then check-vars(EqC, VS) .
  eq check-vars(T = T' /\ EqC, VS)
   = (vars-itp((T, T')) subset VS) and-then check-vars(EqC, VS) .
  eq check-vars(T := T' /\ EqC, VS)
   = (vars-itp(T') subset VS) and-then check-vars(EqC, vars-itp(T) ; VS) .
  eq check-vars(nil, VS) = true .

  --- Creates a new membership that is nonexec if there are free variables
  --- in the condition.
  op newMb-checked : Term Sort EqCondition AttrSet -> MembAx .
  eq newMb-checked(T, S, EqC, AS)
   = newMb(T, S, EqC,
           set-enabled(is-enabled?(AS)
                       and-then check-vars(EqC, vars-itp(T)), AS)) .

  --- Creates a new equation that is nonexec if there are free variables
  --- in the right-hand side or condition.
  op newEq-checked : Term Term EqCondition AttrSet -> Equation .
  eq newEq-checked(T, T', EqC, AS)
   = newEq(T, T', EqC,
           set-enabled(check-vars(EqC /\ T' = T', vars-itp(T)), AS)) .

  op extract-hyp-num : NameFn ~> Nat .
  eq extract-hyp-num(prev-hyp-fn(St:String, N)) = N .
  eq extract-hyp-num(hyp-fn(N)) = N .

  --- Parse result of equational simplification.
  op parse-simp : FormulaSet EqCondition Module NameFn ~> SimpResult .
  eq parse-simp(none, EqC, M, NF) = sr(M, extract-hyp-num(NF)) .
  eq parse-simp(trueFormula ; FS, EqC, M, NF)
   = parse-simp(FS, EqC, M, NF) .
  eq parse-simp(conjunction(Alpha, Beta) ; FS, EqC, M, NF)
   = parse-simp(Alpha ; Beta ; FS, EqC, M, NF) .
  eq parse-simp(equality(T, T) ; FS, EqC, M, NF)
   = parse-simp(FS, EqC, M, NF) .
  ceq parse-simp(equality(C, C') ; FS, EqC, M, NF)
    = inconsistent
   if      (C ==  true-con(M)) and-then (C' == false-con(M))
   or-else (C == false-con(M)) and-then (C' ==  true-con(M)) .
  eq parse-simp(equality(T, T') ; FS, EqC, M, NF)
   = parse-simp(FS, EqC,
        addEqsITP(newEq-checked(T, T', EqC, attr(NF)), M),
        next(NF)) [owise].
  eq parse-simp(sortP(T, S) ; FS, EqC, M, NF)
   = parse-simp(FS, EqC,
        addMbsITP(newMb-checked(T, S, EqC, attr(NF)), M),
        next(NF)) [owise].

  op get-label : AttrSet ~> String .
  eq get-label(label(Q:Qid) AS) = string(Q:Qid) .

  op simpMb : Module Nat MembAx Bool MembAxSet -> SimpResult .
  ceq simpMb(M, HypNum, Mb, Changed, Mbs)
    = simpMbs(parse-simp(Alpha', formulaToCond(CAF), M',
                         prev-hyp-fn(get-label(attrSet(Mb)), HypNum)),
              Mbs,
              true)
   if is-hyp?(attrSet(Mb))
   /\ is-enabled?(attrSet(Mb))
   /\ Alpha := sortP(term(Mb), sort(Mb))
   /\ M' := setMbs(getMbs(M) \ Mb, M)
   /\ Alpha' := applyReducePlus(M', Alpha)
   /\ Beta := condToFormula(condition(Mb))
   /\ CAF := applyReducePlus(M', Beta)
   /\ (Alpha' =/= Alpha) or-else (CAF =/= Beta) .

  eq simpMb(M, HypNum, Mb, Changed, Mbs)
   = simpMbs(sr(M, HypNum), Mbs, Changed) [owise].

  op simpMbs : SimpResult MembAxSet Bool -> SimpResult .
  eq simpMbs(inconsistent, Mbs, Changed) = inconsistent .
  eq simpMbs(sr(M, HypNum), Mb Mbs, Changed)
   = simpMb(M, HypNum, Mb, Changed, Mbs) .
  eq simpMbs(sr(M, HypNum), none, Changed)
   = simpEqs(sr(M, HypNum), getEqs(M), Changed) .

  op simpEq : Module Nat Equation Bool EquationSet -> SimpResult .
  ceq simpEq(M, HypNum, Eq, Changed, Eqs)
    = simpEqs(parse-simp(Alpha', formulaToCond(CAF), M',
                         prev-hyp-fn(get-label(attrSet(Eq)), HypNum)),
              Eqs,
              true)
   if is-hyp?(attrSet(Eq))
   /\ is-enabled?(attrSet(Eq))
   /\ Alpha := equality(lhs(Eq), rhs(Eq))
   /\ M' := setEqs(getEqs(M) \ Eq, M)
   /\ Alpha' := applyReducePlus(M', Alpha)
   /\ Beta := condToFormula(condition(Eq))
   /\ CAF := applyReducePlus(M', Beta)
   /\ (Alpha' =/= Alpha) or-else (CAF =/= Beta) .
  eq simpEq(M, HypNum, Eq, Changed, Eqs)
   = simpEqs(sr(M, HypNum), Eqs, Changed) [owise].

  op simpEqs : SimpResult EquationSet Bool -> SimpResult .
  eq simpEqs(inconsistent, Eqs, Changed) = inconsistent .
  eq simpEqs(sr(M, HypNum), Eq Eqs, Changed)
   = simpEq(M, HypNum, Eq, Changed, Eqs) .
  eq simpEqs(sr(M, HypNum), none, true)
   = simpMbs(sr(M, HypNum), getMbs(M), false) .
  eq simpEqs(sr(M, HypNum), none, false) = sr(M, HypNum) .

  op simpMod : Module Nat -> SimpResult .
  eq simpMod(M, HypNum) = simpMbs(sr(M, HypNum), getMbs(M), false) .
endfm

fmod ITP-INTERNAL-MESSAGE is
  pr ITP-EXT-TERM .
  sort ITPInternalMessage .
  op created : String String -> ITPInternalMessage [ctor] .
  op proved : String -> ITPInternalMessage [ctor] .

  sort ITPInternalMessageList .
  subsorts ITPInternalMessage < ITPInternalMessageList .
  op nilmsgs : -> ITPInternalMessageList [ctor] .
  op _._ : ITPInternalMessageList ITPInternalMessageList ->
      ITPInternalMessageList [ctor assoc id: nilmsgs] .
endfm

*** The module "ITP-TOOL
*** defines the interface for
*** the ITP tool
mod ITP-TOOL is
  including UNIFICATION .
  including COMP-CHECK .
  including SHOW-ITP .
---  including EXT-PRES-ARITH .
  including LOOP-MODE .
  including ITP-PRETTY-PRINT .
  including ITP-REDUCE .
  pr ITP-EXT-TERM .
----  pr UNIFICATION . ---- see the above including clause
  including COVERSET-INDUCTION .
  including ITP-PROOF-STATE .
  pr ITP-COMMAND-PARSER .
  pr ITP-CTOR-DEF .
  pr ITP-EQUIV-PROPAGATE .
  pr ITP-FORMULA-PARSER .
  pr ITP-LABELED-RULES .
  pr ITP-SIMP .
  pr ITP-VALIDITY-CHECKING .
  pr ITP-INTERNAL-MESSAGE .
  inc CONFIGURATION . ---- ITP objects now follow the standard notation for objects

  --- Represents conditional memberships.
  sort HornMb .
  op hc : EqCondition Membership -> HornMb [ctor].

  sorts PairSubstFormula PairSubstFormulaSet .
  op pairSubstFormula : VariableSet Substitution Formula
        -> PairSubstFormula [ctor].
  op pairSubstFormulaSet : PairSubstFormula PairSubstFormulaSet
        -> PairSubstFormulaSet [ctor].
  op nonePairSubstFormulaSet : -> PairSubstFormulaSet [ctor].

----
  op ITP : -> ITP .
  op ITPBroker : -> ITPBroker .

  sorts ITP ITPBroker .
  subsorts ITP ITPBroker < Cid .
----

---- ITP objects now follow the standard notation for objects
----  sort ITPAttr ITPAttrSet .
----  subsort ITPAttr < ITPAttrSet .
----  --- Module used for parsing commands (defaults to ['ITP-GRAMMAR]).
----  op cmdMod :_ : Module -> ITPAttr [ctor].
----  op proofState :_ : ProofState -> ITPAttr [ctor].
----  op defaultGoal :_ : String -> ITPAttr [ctor].
----  op emptyAttrSet : -> ITPAttrSet [ctor].
----  op externalMsgs :_ : ITPInternalMessageList -> ITPAttr [ctor] .
----
----  op attrs : ITPAttrSet ITPAttrSet -> ITPAttrSet
----     [ctor assoc comm id: emptyAttrSet] .

  --- [DEPRECATED] Module used for parsing commands (defaults to ['ITP-GRAMMAR]).
  --- Instead of carrying around the grammar module, global constant 'itp-grammar'
  --- is used in place
---  op cmdMod :_ : Module -> Attribute [ctor].
  op proofState :_ : ProofState -> Attribute [ctor].
  op defaultGoal :_ : String -> Attribute [ctor].
  op goalName :_ : String -> Attribute [ctor].
----  op externalMsgs :_ : ITPInternalMessageList -> Attribute [ctor] .

----  op state : ITPAttrSet -> State [ctor].
---- The state of the loop is a configuration, and the ITP object is one of the 
---- objects in it. 

  --- Result of executing a user command on the ITP state.
  sorts ExecResult .
  --- Operator indicating error occured in command.  Provides error message.
  op itp-error : QidList -> ExecResult [ctor].
  --- Operator indicating command was succesful with some output.
----  op next : ITPAttrSet QidList -> ExecResult [ctor].
  op next : AttributeSet QidList -> ExecResult [ctor].

  op init-itp : Module -> System [ctor].

  var AF : Atomic .
  var AS AS' AtS : AttrSet .
  var B B1 B2 Changed : Bool .
  var CL : Clause .
  var CAF : ConjAtomic .
  var C SelCns : Constant .
  var CSS : CondSubstSet .
  var EqC EqC' : EqCondition .
  var Eq NewEq : Equation .
  var Eqs Eqs' NewEqs : EquationSet .
  var ERR : ExtractRuleResult .
  var Alpha Beta Gamma Delta NewFormula NewHyp SelFormula : Formula .
  var FS : FormulaSet .
  var G NewG SelTask NewTask : Goal .
  var GL GL' NewGoals : GoalList .
  var GT : GroundTerm .
  var Cmd : Input .
----  var Atts Atts' : ITPAttrSet .
  var Atts Atts' : AttributeSet .
  var EM  : ITPInternalMessage .
  var EML : ITPInternalMessageList .
  var LFS LFS' : LabeledFormulaSet .
  var LR : LabeledRules .
  var Mb NewMb : MembAx .
  var Mbs Mbs' : MembAxSet .
  var Mod NewMod SelMod CmdMod M : Module .
  var I N N' N1 N2 HypNum NewHypNum : Nat .
  var Ops : OpDeclSet .
  var PSBF : PairSubstFormulaSet .
  var POS : ProofObligationSet .
  var PS PS' : ProofState .
  var Q Q' QI F X : Qid .
  var QIL QIL' Msg : QidList .
  var NeQIL : NeQidList .
  var RP RP' : ResultPair .
  var S S' SelSort : Sort .
  var SS : SortSet .
  var St ST Label NewLabel : String .
  var STS : StringSet .
  var SB SB' SelSubst : Substitution .
  var SBS : ITPSubstitutionSet .
  var T T' T1 T2 T3 MyTerm SelTerm : Term .
  var TL TL' : TermList .
  var TS : ITPTermSet .
  var Tp Tp1 Tp2 : Type .
  var TpL : TypeList .
  var NeTpL : NeTypeList .
  var V V' NewVar SelVar : Variable .
  var VS VS' : VariableSet .
  var  DB : Database .
  
  -------------------------------------------
  --- createNewConstants

  --- Returns the name of the constant we want to create.
  op createNewConstantName : Variable String -> String .
  eq createNewConstantName(V, ST)
   = string(getName(V)) + ST + "*" + string(getType(V)) .

  op createNewConstants : VariableSet String -> OpDeclSet .
  eq createNewConstants(none, ST) = none .
  eq createNewConstants(V ; V ; VS, ST) = createNewConstants(V ; VS, ST) .
  eq createNewConstants(V ; VS, ST)
   = (op qid(createNewConstantName(V, ST)) : nil -> getType(V) [none] .)
     createNewConstants(VS, ST) [owise].

  --- Creates a substitution mapping each variable to it's new constant.
  op createNewConstantSubst : VariableSet String -> Substitution .
  eq createNewConstantSubst(V ; VS, ST)
   = (V <- qid(createNewConstantName(V, ST) + "." + string(getType(V))))
   ; createNewConstantSubst(VS, ST) .
  eq createNewConstantSubst(none, ST) = none .

  --- varsToNewConstants
  op varsToNewConstants : VariableSet Formula String -> Formula .
  eq varsToNewConstants(VS, Alpha, ST)
   = substitute(Alpha, createNewConstantSubst(VS, "")) .

  --- Init itp with default grammar.
  op init-itp : -> System .
  eq init-itp = init-itp(['ITP-GRAMMAR]) .

  --- Parses command using command module in attribute set.
----  op parse-cmd : ITPAttrSet NeQidList ~> ParseInputResult .
  op parse-cmd : AttributeSet NeQidList Database ~> ParseInputResult .

  --- Parse command when successful.
----  ceq parse-cmd(attrs(cmdMod : CmdMod, Atts), NeQIL)
----    = parseInput(CmdMod,
----                 getDefaultGoal(attrs(cmdMod : CmdMod, Atts)),
----                 getTerm(metaReduce(CmdMod, T)))
----   if {T, Tp} := metaParse(CmdMod, NeQIL, 'Input) .
  ceq parse-cmd(Atts, NeQIL, DB)
    = parseInput(itp-grammar,
                 getDefaultGoal(Atts),
                 getTerm(metaReduce(itp-grammar, T)),  ---- PD: could metaNormalize be used instead of metaReduce?
                 DB)
   if {T, Tp} := metaParse(itp-grammar, NeQIL, 'Input) .

  --- Unsuccessful parse.
----  ceq parse-cmd(attrs(cmdMod : CmdMod, Atts), NeQIL)
----    = parse-input-error(
----        if N == size(NeQIL) then
----          'Unexpected 'end 'of 'input.
----        else
----          'Unable 'to 'parse 'input 'command 'starting 'from:
----          ' nth-tail(N, NeQIL)
----        fi)
----   if noParse(N) := metaParse(CmdMod, NeQIL, 'Input) .
  ceq parse-cmd(Atts, NeQIL, DB)
    = parse-input-error(
        if N == size(NeQIL) 
        then 'Unexpected 'end 'of 'input.
        else 'Unable 'to 'parse 'input 'command 'starting 'from: ' nth-tail(N, NeQIL)
        fi)
    if noParse(N) := metaParse(itp-grammar, NeQIL, 'Input) .

  --- Ambiguous parse.
----  ceq parse-cmd(attrs(cmdMod : CmdMod, Atts), NeQIL)
----    = parse-input-error(
----       'The 'list 'of 'tokens '\n NeQIL '\n 'can 'be 'parsed 'in 'at 'least
----       'two 'different 'ways ':
----       'a. metaPrettyPrint(CmdMod, getTerm(RP)) '`, 'and
----       'b. metaPrettyPrint(CmdMod, getTerm(RP')) '.)
----   if ambiguity(RP, RP') := metaParse(CmdMod, NeQIL, 'Input) .
  ceq parse-cmd(Atts, NeQIL, DB)
    = parse-input-error(
       'The 'list 'of 'tokens '\n NeQIL '\n 'can 'be 'parsed 'in 'at 'least 'two 'different 'ways ':
       'a. metaPrettyPrint(itp-grammar, getTerm(RP)) '`, 'and
       'b. metaPrettyPrint(itp-grammar, getTerm(RP')) '.)
   if ambiguity(RP, RP') := metaParse(itp-grammar, NeQIL, 'Input) .

  --- addHypTo
  op addHypTo : Formula Module Qid ~> Module .
  eq addHypTo(trueFormula, Mod, QI) = Mod .
  --- TODO: This equation seems improper since it may result in multiple
  --- hypothesis being added with the same number.  We should double check
  --- that this is really desired.
  eq addHypTo(conjunction(Alpha, Beta), Mod, QI)
   = addHypTo(Beta, addHypTo(Alpha, Mod, QI), QI) .
  eq addHypTo(implication(Alpha, equality(T1, T2)), Mod, QI)
   = addEqsITP(ceq T1 = T2 if formulaToCond(Alpha)
                [label(QI) metadata("|cat:hyp|")] .,
            Mod) .
  eq addHypTo(implication(Alpha, sortP(T, S)), Mod, QI)
   = addMbsITP(cmb T : S if formulaToCond(Alpha)
                [label(QI) metadata("|cat:hyp|")] .,
            Mod) .
  eq addHypTo(equality(T1, T2), Mod, QI)
   = addEqsITP(eq T1 = T2 [label(QI) metadata("|cat:hyp|")] ., Mod) .
  eq addHypTo(sortP(T, S), Mod, QI)
   = addMbsITP(mb T : S [label(QI) metadata("|cat:hyp|")] ., Mod) .
  eq addHypTo(AQuantification(VS, equality(T1, T2)), Mod, QI)
   = addEqsITP(eq T1 = T2 [label(QI) metadata("|cat:hyp|")] ., Mod) .
  eq addHypTo(AQuantification(VS, sortP(T, S)), Mod, QI)
   = addMbsITP(mb T : S [label(QI) metadata("|cat:hyp|")] ., Mod) .
  eq addHypTo(AQuantification(VS, implication(Alpha, equality(T1, T2))),
              Mod, QI)
   = addEqsITP(ceq T1 = T2 if formulaToCond(Alpha)
                [label(QI) metadata("|cat:hyp|")] .,
            Mod) .
  eq addHypTo(AQuantification(VS, implication(Alpha, sortP(T, S))), Mod, QI)
   = addMbsITP(cmb T : S if formulaToCond(Alpha)
                [label(QI) metadata("|cat:hyp|")] .,
            Mod) .

  ---
  --- addLemTo
  ---
  op addLemTo : Formula Module Qid ~> Module .
  eq addLemTo(trueFormula, Mod, QI) = Mod .
  eq addLemTo(implication(Alpha, equality(T1, T2)), Mod, QI)
   = addEqsITP(ceq T1 = T2 if formulaToCond(Alpha)
                [label(QI) metadata("|cat:lem|")] .,
            Mod) .
  eq addLemTo(implication(Alpha, sortP(T, S)), Mod, QI)
   = addMbsITP(cmb T : S if formulaToCond(Alpha)
                [label(QI) metadata("|cat:lem|")] .,
            Mod) .
  eq addLemTo(equality(T1, T2), Mod, QI)
   = addEqsITP(eq T1 = T2 [label(QI) metadata("|cat:lem|")] ., Mod) .
  eq addLemTo(sortP(T, S), Mod, QI)
   = addMbsITP(mb T : S [label(QI) metadata("|cat:lem|")] ., Mod) .
  eq addLemTo(AQuantification(VS, equality(T1, T2)), Mod, QI)
   = addEqsITP(eq T1 = T2 [label(QI) metadata("|cat:lem|")] ., Mod) .
  eq addLemTo(AQuantification(VS, sortP(T, S)), Mod, QI)
   = addMbsITP(mb T : S [label(QI) metadata("|cat:lem|")] ., Mod) .
  eq addLemTo(AQuantification(VS, implication(Alpha, equality(T1, T2))),
              Mod, QI)
   = addEqsITP(ceq T1 = T2 if formulaToCond(Alpha)
                [label(QI) metadata("|cat:lem|")] .,
            Mod) .
  eq addLemTo(AQuantification(VS, implication(Alpha, sortP(T, S))), Mod, QI)
   = addMbsITP(cmb T : S if formulaToCond(Alpha)
                [label(QI) metadata("|cat:lem|")] .,
            Mod) .

  --- Returns the goal associated to the default goal in the set, or
  --- nil if there is not one.
----  op getDefaultGoal : ITPAttrSet ~> Goal? .
----  eq getDefaultGoal(attrs(proofState : PS, defaultGoal : Label, Atts))
----   = getGoal(Label, PS) .
  op getDefaultGoal : AttributeSet ~> Goal? .
  eq getDefaultGoal((proofState : PS, defaultGoal : Label, Atts)) = getGoal(Label, PS) .

----  op goalExists? : String ITPAttrSet -> Bool .
----  eq goalExists?(Label, attrs(proofState : PS, Atts))
----   = getGoal(Label, PS) :: Goal .
  op goalExists? : String AttributeSet -> Bool .
  eq goalExists?(Label, (proofState : PS, Atts)) = getGoal(Label, PS) :: Goal .

  --- Replaces the current goal in the attribute set with the goal set.
----  op replaceCurrentGoal : GoalList ITPAttrSet ~> ITPAttrSet .
----  eq replaceCurrentGoal(NewTask NewGoals,
----       attrs(proofState : PS,
----            defaultGoal : Label, Atts))
----   = attrs(proofState : replaceGoal(Label, NewTask NewGoals, PS),
----          defaultGoal : getName(NewTask), Atts) .
----  eq replaceCurrentGoal(nil,
----       attrs(proofState : PS,
----            defaultGoal : Label, Atts))
----   = attrs(proofState : replaceGoal(Label, nil, PS),
----          defaultGoal : nextGoal(Label, PS), Atts) .
  op replaceCurrentGoal : GoalList AttributeSet ~> AttributeSet .
  eq replaceCurrentGoal(NewTask NewGoals, (proofState : PS, defaultGoal : Label, Atts))
   = (proofState : replaceGoal(Label, NewTask NewGoals, PS), defaultGoal : getName(NewTask), Atts) .
  eq replaceCurrentGoal(nil, (proofState : PS, defaultGoal : Label, Atts))
   = (proofState : replaceGoal(Label, nil, PS), defaultGoal : nextGoal(Label, PS), Atts) .

  --- Removes default goal from attribute set.
  --- TODO: Check that no goals with the given name already exist.
----  op replaceDefaultGoal : GoalList ITPAttrSet ~> ExecResult .
----  eq replaceDefaultGoal(NewTask NewGoals,
----       attrs(proofState : PS,
----            defaultGoal : Label, Atts))
----   = next(attrs(proofState : replaceGoal(Label, NewTask NewGoals, PS),
----               defaultGoal : getName(NewTask), Atts),
----          'New 'goals: '\n
----          meta-pretty-print-list(getName(NewTask), NewTask NewGoals)) .
----  ceq replaceDefaultGoal(nil,
----       attrs(proofState : PS,
----            defaultGoal : Label, 
----            externalMsgs : EML, Atts))
----    = if PS' == emptyProofState
----        then
----          next(
----            attrs(
----              proofState : replaceGoal(Label, nil, PS),
----              defaultGoal : nextGoal(Label, PS),
----              externalMsgs : (proved(Label) . EML), Atts),
----            'Eliminated 'current 'goal. '\n
----            '\n 'q.e.d '\n
----            meta-pretty-print(nextGoal(Label, PS), PS'))
----        else
----          next(
----            attrs(
----              proofState : replaceGoal(Label, nil, PS),
----              defaultGoal : nextGoal(Label, PS),
----              externalMsgs : EML, Atts),
----            'Eliminated 'current 'goal. '\n
----             '\n 'New 'current 'goal: '\n
----             meta-pretty-print-list(nextGoal(Label, PS),
----                                    getGoal(nextGoal(Label, PS), PS')))
----      fi
----   if PS' := replaceGoal(Label, nil, PS) .
  op replaceDefaultGoal : GoalList AttributeSet ~> ExecResult .
  eq replaceDefaultGoal(NewTask NewGoals, (proofState : PS, defaultGoal : Label, Atts))
   = next((proofState : replaceGoal(Label, NewTask NewGoals, PS), defaultGoal : getName(NewTask), Atts),
          'New 'goals: '\n meta-pretty-print-list(getName(NewTask), NewTask NewGoals)) .
  ceq replaceDefaultGoal(nil, (proofState : PS, defaultGoal : Label, Atts))
    = if PS' == emptyProofState
      then next(
             (proofState : replaceGoal(Label, nil, PS),
              defaultGoal : nextGoal(Label, PS), Atts),
            'Eliminated 'current 'goal. '\n
            '\n 'q.e.d '\n
            meta-pretty-print(nextGoal(Label, PS), PS'))
      else next(
             (proofState : replaceGoal(Label, nil, PS),
              defaultGoal : nextGoal(Label, PS), Atts),
            'Eliminated 'current 'goal. '\n
             '\n 'New 'current 'goal: '\n
             meta-pretty-print-list(nextGoal(Label, PS),
                                    getGoal(nextGoal(Label, PS), PS')))
      fi
   if PS' := replaceGoal(Label, nil, PS) .

  -----------------------------------------------------
  -----------------------------------------------------
  --- exec operator
  -----------------------------------------------------
  -----------------------------------------------------
  --- Tries running the given command on the current ITP attribute state.
  --- Equations defined much farther below.
----  op exec : Input ITPAttrSet ~> ExecResult .
  op exec : Input AttributeSet ~> ExecResult .


  -----------------------------------------------------
  --- goal
  -----------------------------------------------------
  --- Set new goal if defaultGoal is unassigned.
  --- TODO: Check that variable and constant names in formula are distinct
  ---   from variable and constant names that may be generated by ITP.
  ceq exec(goal NewLabel : SelMod |- SelFormula .,
           (proofState   : PS,
            defaultGoal  : "",
            goalName     : "",
            Atts))
    = next((proofState   : ps(NewTask),
            defaultGoal  : (NewLabel + AT + "0"),
            goalName     : (NewLabel + AT + "0"),
            Atts),
           meta-pretty-print(NewLabel + AT + "0", ps(NewTask)))
   if NewTask := new-goal(NewLabel + AT + "0", SelMod, SelFormula) .

  --- Treat as lemma if we already have a goal set.
  ceq exec(goal NewLabel : SelMod |- SelFormula .,
           (defaultGoal : ST, Atts))
    = exec(lem NewLabel : SelFormula .,
           (defaultGoal : ST, Atts))
   if ST =/= "" .

  ceq exec(new-goal NewLabel : SelMod |- SelFormula .,
           (proofState   : PS,
            defaultGoal  : "",
            goalName     : "",
            Atts))
    = next((proofState   : ps(NewTask),
            defaultGoal  : (NewLabel + AT + "0"),
            goalName     : (NewLabel + AT + "0"),
            Atts),
           meta-pretty-print(NewLabel + AT + "0", ps(NewTask)))
   if NewTask := new-goal(NewLabel + AT + "0", SelMod, SelFormula) .

  --- Attempts to get Horn clauses from the antecedent of the
  ceq exec(imp ., Atts)
    = if is-empty?(LR) then
        itp-error('No 'antecedents 'could 'be 'found 'to 'add 'to 'module.)
      else
        next(replaceCurrentGoal(NewTask, Atts),
             'Adding 'to 'hypothesis: '\n
             mpp-rules(LR, getMod(SelTask))
             meta-pretty-print-list(getName(NewTask), NewTask))
      fi
   if SelTask := getDefaultGoal(Atts)
   /\ ERR := extract-rules(getAllAntc(getFormula(SelTask)))
   /\ LR := label-rules(ERR, hyp-fn(getHypNum(SelTask)))
   /\ NewTask
        := setFormula(getConseq(getFormula(SelTask)),
                      incHypNum(| LR |, add-rules(LR, SelTask))) .

  -----------------------------------------------------
  --- simp
  -----------------------------------------------------
  ceq exec(simp ., Atts)
    = if Mod == getMod(SelTask) then
        itp-error('Could 'not 'further 'simplify 'axioms 'in 'module.)
      else
        replaceDefaultGoal(setMod(Mod, setHypNum(HypNum, SelTask)), Atts)
      fi
   if SelTask := getDefaultGoal(Atts)
   /\ sr(Mod, HypNum) := simpMod(getMod(SelTask), getHypNum(SelTask)) .

  ceq exec(simp ., Atts)
    = replaceDefaultGoal(nil, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ inconsistent := simpMod(getMod(SelTask), getHypNum(SelTask)) .

  -----------------------------------------------------
  --- rwr
  -----------------------------------------------------
  ceq exec(rwr ., Atts)
    = replaceDefaultGoal(setFormula(NewFormula, SelTask), Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ NewFormula := applyReducePlus(getMod(SelTask), getFormula(SelTask)) .

  -----------------------------------------------------
  --- idt
  -----------------------------------------------------
  ceq exec(idt ., Atts)
    = if isAnIdentity?(getMod(SelTask), getFormula(SelTask))
        or-else inconsistent?(getMod(SelTask)) then
        replaceDefaultGoal(nil, Atts)
      else
        next(Atts,
             meta-pretty-print-list(getName(SelTask), SelTask)
             'The 'current 'goal 'is 'not 'an 'identity)
      fi
   if SelTask := getDefaultGoal(Atts) .

  -----------------------------------------------------
  --- cns
  -----------------------------------------------------
  ---TODO: Fix bug where constants may be created from variable with same
  --- name as existing constant.
  ceq exec(cns ., Atts) = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, SelFormula) := getFormula(SelTask)
   /\ NewTask
        := setFormula(
             varsToNewConstants(VS, SelFormula, AT),
             setMod(addOpsITP(createNewConstants(VS, ""), getMod(SelTask)),
                    SelTask)) .

  --- Make a particular variable in formula into a constant.
  ceq exec(cns V ., Atts) = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS ; V ; VS', SelFormula) := getFormula(SelTask)
   /\ NewTask := setFormula(
        varsToNewConstants(V, AQuantification(VS ; VS', SelFormula), AT),
        setMod(addOpsITP(createNewConstants(V, ""), getMod(SelTask)),
                SelTask)) .

  ------------------------------------------------------------------------
  --- LEMMA RULE
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  --- This equation introduces a new lemma named by Label with the formula
  --- Alpha.
  --- The effects include:
  --- * Generating a new goal from the current goal named Label + "<AT>0" with
  ---   the formula Alpha.
  --- * Extract equations and memberships out of Alpha, and add them to
  ---   the module in current goal along with the remaining part of the
  ---   formula as a labeled equation.
  --- * If there is only one equation, membership or labeled equation to add,
  ---   then we give it the lemma name "lem-" + Label.  Otherwise, we index
  ---   them by a natural number N starting from 0, and give each one the
  ---   name "lem-" + Label + string(N, 10).
  ceq exec(lem Label : Alpha ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if NewLabel := Label + AT + "0"
   /\ goalExists?(NewLabel, Atts) = false
   /\ SelTask := getDefaultGoal(Atts)
   /\ NewGoals :=
       setName(NewLabel, setFormula(Alpha, SelTask))
       add-rules(
         label-rules(extract-rules(Alpha), lem-fn("lem-" + Label, 1)),
         SelTask) .

  ceq exec(lem Label : Alpha ., Atts)
    = itp-error('A 'goal 'with 'the 'name qid(NewLabel) 'already 'exists.)
   if NewLabel := Label + AT + "0"
   /\ goalExists?(NewLabel, Atts) .

  ------------------------------------------------------------------------
  --- ex-lem
  ------------------------------------------------------------------------
  ceq exec(ex-lem Label : SelFormula ., Atts)
    = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ NewTask := addLabeledFormulas(pair(Label, SelFormula), SelTask) .

  ------------------------------------------------------------------------
  --- a-inst
  ------------------------------------------------------------------------
  --- Returns a formula that guarantees each term has the sort of variable
  --- it is being substituted for.
  --- We use the module to simplify the resulting formula slightly.
  op subst-sort-formula : Substitution Module -> Formula .
  eq subst-sort-formula(V <- T ; SB, Mod)
   = if sortLeq(Mod, leastSort(Mod, T), getType(V)) then
       subst-sort-formula(SB, Mod)
     else
       conjunction(sortP(T, getType(V)), subst-sort-formula(SB, Mod))
     fi .
  eq subst-sort-formula(none, Mod) = trueFormula .

  --- "a-inst NewLabel : Label Subst ." instantiates a universally quantified
  --- formula labeled by "Label" as a new formula with the substitution
  --- "Subst".
  ceq exec(a-inst Label with SelSubst ., Atts)
    = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, Alpha) := getLabeledFormula(Label, SelTask)
   /\ lhs-vars(SelSubst) subset VS
   /\ ERR := extract-rules(
        AQuantification((VS \ lhs-vars(SelSubst)) ; rhs-vars(SelSubst),
          implication(subst-sort-formula(SelSubst, getMod(SelTask)),
                      substitute(Alpha, SelSubst))))
   /\ LR := label-rules(ERR, hyp-fn(getHypNum(SelTask)))
   /\ NewTask := incHypNum(| LR |, add-rules(LR, SelTask)) .

  --- Handle error where formula with given name could not be found.
  --- of substitution contains variables not universally quantified.
  ceq exec(a-inst Label with SelSubst ., Atts)
    = itp-error('The 'formula 'with 'name qid(Label) 'could 'not 'be 'found.)
   if SelTask := getDefaultGoal(Atts)
   /\ getLabeledFormula(Label, SelTask) :: Formula = false .

  --- Handle error where universally quantified variables in left-hand-side
  --- of substitution contains variables not universally quantified.
  ceq exec(a-inst Label with SelSubst ., Atts)
    = itp-error('The 'variables 'in 'substitution 'are 'not 'all 'universally
            'quantified 'in 'formula.)
   if SelTask := getDefaultGoal(Atts)
   /\ SelFormula := getLabeledFormula(Label, SelTask)
   /\ hasAQuantVars(lhs-vars(SelSubst), SelFormula) = false .

  ----------
  --- e-inst
  ----------

  ---------------------------
  --- in the selected goal
  ---------------------------
  ceq exec(e-inst with (SB)., Atts)
    = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SB : GroundSubstitution
   /\ Alpha := stripEQuantVars(lhs-vars(SB), getFormula(SelTask))
   /\ NewTask := setFormula(substitute(Alpha, SB), SelTask) .

  ceq exec(e-inst with (SB)., Atts)
    = itp-error('The 'substitution 'must 'be 'a 'ground 'substitution.)
   if SelTask := getDefaultGoal(Atts)
   /\ SB :: GroundSubstitution = false .

  ceq exec(e-inst with (SB)., Atts)
    = itp-error('The 'variables 'in 'the 'substitution 'must 'be 'a 'subset 'of
            'the 'existentially 'quantified 'variables.)
   if SelTask := getDefaultGoal(Atts)
   /\ SB : GroundSubstitution
   /\ stripEQuantVars(lhs-vars(SB), getFormula(SelTask)) :: Formula = false .

  ---------------------------
  --- in the auxiliary axioms
  ---------------------------
  ceq exec(e-inst Label ., Atts)
    = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ EQuantification(VS, SelFormula) := getLabeledFormula(Label, SelTask)
   /\ NewMod := addHypTo(
                  substitute(
                    SelFormula,
                    createNewConstantSubst(VS, "!" + Label)),
                  addOpsITP(createNewConstants(VS, "!" + Label),
                         getMod(SelTask)),
                  qid("hyp-" + string(getHypNum(SelTask), 10)))
   /\ NewTask := removeLabeledFormula(Label,
                   setMod(NewMod, incHypNum(1, SelTask))) .

  ------------------------------------------------------------------------
  --- show-all
  ------------------------------------------------------------------------
  ceq exec(show-all ., Atts)
    = next(Atts, mpp-mod(getMod(SelTask)))
   if SelTask := getDefaultGoal(Atts) .

  ------------------------------------------------------------------------
  --- show-goal
  ------------------------------------------------------------------------
  ceq exec(show-goal ., Atts)
    = next(Atts,
           'goal: meta-pretty-print-Formula(getMod(SelTask),
                                            getFormula(SelTask)))
   if SelTask := getDefaultGoal(Atts) .

  ------------------------------------------------------------------------
  --- show-hyps.
  ------------------------------------------------------------------------
  --- Returns hypotheses in labeled formula set.
  op getHyps : LabeledFormulaSet ~> LabeledFormulaSet .
  eq getHyps(LFS) = $getHyps(LFS, none) .

  --- Implementation of getHyps.
  op $getHyps : LabeledFormulaSet LabeledFormulaSet ~> LabeledFormulaSet .
  eq $getHyps(pair(St, Alpha) ; LFS', LFS)
   = if substr(St, 0, 3) == "hyp" then
       $getHyps(LFS', pair(St, Alpha) ; LFS)
     else
       $getHyps(LFS', LFS)
     fi .
  eq $getHyps(none, LFS) = LFS .

  ceq exec(show-hyps ., Atts)
    = next(Atts,
           'hyps: '\n
           mpp-mbs(getMod(SelTask), getHyps(getMbs(getMod(SelTask))))
           mpp-eqs(getMod(SelTask), getHyps(getEqs(getMod(SelTask))))
           mpp-lfs(getMod(SelTask), getHyps(getLabeledFormulas(SelTask))))
   if SelTask := getDefaultGoal(Atts) .

  ------------------------------------------------------------------------
  --- show-rules with
  ------------------------------------------------------------------------

  --- Returns true if any term in list contains given operator symbol.
  op contains-op? : Qid TermList -> Bool .
  eq contains-op?(Q, (Q'[TL'], TL))
   = (Q == Q') or-else contains-op?(Q, (TL', TL)) .
  eq contains-op?(Q, (V, TL)) = contains-op?(Q, TL) .
  eq contains-op?(Q, (C, TL))
   = (Q == getName(C)) or-else contains-op?(Q, TL) .
  eq contains-op?(Q, empty) = false .

  --- Returns true if any term in any formula contains given operator symbol.
  op contains-op? : Qid FormulaSet -> Bool .
  eq contains-op?(Q, FS ; trueFormula) = contains-op?(Q, FS) .
  eq contains-op?(Q, FS ; falseFormula) = contains-op?(Q, FS) .
  eq contains-op?(Q, FS ; sortP(T, S))
   = contains-op?(Q, T) or-else contains-op?(Q, FS) .
  eq contains-op?(Q, FS ; equality(T, T'))
   = contains-op?(Q, (T, T')) or-else contains-op?(Q, FS) .
  eq contains-op?(Q, FS ; conjunction(Alpha, Beta))
   = contains-op?(Q, FS ; Alpha ; Beta) .
  eq contains-op?(Q, FS ; disjunction(Alpha, Beta))
   = contains-op?(Q, FS ; Alpha ; Beta) .
  eq contains-op?(Q, FS ; implication(Alpha, Beta))
   = contains-op?(Q, FS ; Alpha ; Beta) .
  eq contains-op?(Q, FS ; AQuantification(VS, Alpha))
   = contains-op?(Q, FS ; Alpha) .
  eq contains-op?(Q, FS ; EQuantification(VS, Alpha))
   = contains-op?(Q, FS ; Alpha) .
  eq contains-op?(Q, (none).FormulaSet) = false .

  --- Returns memberships whose left-hand side contains the given root
  --- symbol.
  op mbs-with-op : Qid MembAxSet -> MembAxSet .
  eq mbs-with-op(Q, Mbs) = $mbs-with-op(Q, Mbs, none) .

  --- Implementation of above.
  op $mbs-with-op : Qid MembAxSet MembAxSet -> MembAxSet .
  eq $mbs-with-op(Q, Mb Mbs', Mbs)
   = if contains-op?(Q, term(Mb)) then
       $mbs-with-op(Q, Mbs', Mb Mbs)
     else
       $mbs-with-op(Q, Mbs', Mbs)
     fi .
  eq $mbs-with-op(Q, none, Mbs) = Mbs .

  op eqs-with-op : Qid EquationSet -> EquationSet .
  eq eqs-with-op(Q, Eqs) = $eqs-with-op(Q, Eqs, none) .

  op $eqs-with-op : Qid EquationSet EquationSet -> EquationSet .
  eq $eqs-with-op(Q, Eq Eqs', Eqs)
   = if contains-op?(Q, lhs(Eq)) then
       $eqs-with-op(Q, Eqs', Eq Eqs)
     else
       $eqs-with-op(Q, Eqs', Eqs)
     fi .
  eq $eqs-with-op(Q, none, Eqs) = Eqs .

  op lf-with-op : Qid LabeledFormulaSet -> LabeledFormulaSet .
  eq lf-with-op(Q, LFS) = $lf-with-op(Q, LFS, none) .

  op $lf-with-op : Qid LabeledFormulaSet LabeledFormulaSet
        -> LabeledFormulaSet .
  eq $lf-with-op(Q, LFS' ; pair(St, Alpha), LFS)
   = if contains-op?(Q, Alpha) then
       $lf-with-op(Q, LFS', pair(St, Alpha) ; LFS)
     else
       $lf-with-op(Q, LFS', LFS)
     fi .
  eq $lf-with-op(Q, none, LFS) = LFS .

  ceq exec(show-rules with Q ., Atts)
    = next(Atts,
           'rules 'containing Q ': '\n
           mpp-mbs(M, mbs-with-op(Q, getMbs(M)))
           mpp-eqs(M, eqs-with-op(Q, getEqs(M)))
           mpp-lfs(M,  lf-with-op(Q, getLabeledFormulas(SelTask))))
   if SelTask := getDefaultGoal(Atts)
   /\ M := getMod(SelTask) .

  ------------------------------------------------------------------------
  --- AUTO
  ------------------------------------------------------------------------
  --- Applies auto to all goals in list.
  op auto : GoalList -> GoalList .
  eq auto(GL) = $auto(GL, nil) .

  --- Tail recursive implementation of auto (above).
  op $auto : GoalList GoalList -> GoalList .
  ceq $auto(G GL, GL') = $auto(NewTask GL, GL')
   if AQuantification(VS, SelFormula) := getFormula(G)
   /\ NewTask
        := setFormula(varsToNewConstants(VS, SelFormula, AT),
                      setMod(addOpsITP(createNewConstants(VS, ""),
                                    getMod(G)),
                             G)) .
  ceq $auto(G GL, GL')
    = $auto(setFormula(getConseq(getFormula(G)),
              incHypNum(| LR |, add-rules(LR, G))) GL,
            GL')
   if ERR := extract-rules(getAllAntc(getFormula(G)))
   /\ LR := label-rules(ERR, hyp-fn(getHypNum(G)))
   /\ is-empty?(LR) = false .
  ceq $auto(G GL, GL')
    = $auto(replace-formulas(FS, G) GL, GL')
   if FS := extract-conj(getFormula(G))
   /\ | FS | > 1 .
  ceq $auto(G GL, GL') = $auto(GL, GL')
   if isAnIdentity?(getMod(G), getFormula(G)) .
  ceq $auto(G GL, GL') = $auto(GL, GL')
   if inconsistent?(getMod(G)) .
  ceq $auto(G GL, GL') = $auto(NewGoals GL ,GL')
   if NewGoals := equiv-propagate(G)
   /\ NewGoals =/= G .

  ceq $auto(G GL, GL') = $auto(GL, GL')
   if inconsistent := simpMod(getMod(G), getHypNum(G)) .

  ceq $auto(G GL, GL')
    = $auto(setMod(NewMod, setHypNum(NewHypNum, G)) GL, GL')
   if sr(NewMod, NewHypNum) := simpMod(getMod(G), getHypNum(G))
   /\ NewMod =/= getMod(G) .

  ceq $auto(G GL, GL') = $auto(setFormula(NewFormula, G) GL, GL')
   if NewFormula := applyReducePlus(getMod(G), getFormula(G))
   /\ NewFormula =/= getFormula(G) .
  eq $auto(G GL, GL') = $auto(GL, GL' G) [owise].
  eq $auto(nil, GL) = GL .

  eq exec(auto ., Atts)
   = replaceDefaultGoal(auto(getDefaultGoal(Atts)), Atts) .

  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  --- STRUCTURAL INDUCTION RULE
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  --- Returns set of horn clauses to instantiate variables with any of the
  --- given sorts with concrete sorts.
  op mbs-for-sort : Module Sort ~> MembAxSet .
  eq mbs-for-sort(Mod, S)
   = $mbs-for-sorts(Mod, S ; lesserSorts(Mod, S), none) .

  --- Implementation of mbs-for-sort (above).
  op $mbs-for-sorts : Module SortSet MembAxSet ~> MembAxSet .
  eq $mbs-for-sorts(Mod, none, Mbs) = Mbs .
  eq $mbs-for-sorts(Mod, S ; SS, Mbs)
   = if algebraic-sort?(S) then
       $mbs-for-sorts(Mod, SS,
         ctor-mbs-with-sort(S, Mod, omit-subsort-decls) Mbs)
     else
       $mbs-for-sorts(Mod, SS, Mbs (mb typeVars(S, 0) : S [none].))
     fi .

  --- Returns variables in list constrained to subtype of sort.
  --- The sort should be a concrete sort in the module.
  op varsSubsort : VariableSet Sort Module ~> ITPTermSet .
  eq varsSubsort(V ; VS, S, Mod)
   = if subtype?(Mod, getType(V), S) then
       V ; varsSubsort(VS, S, Mod)
     else
       varsSubsort(VS, S, Mod)
     fi .
  eq varsSubsort(none, S, Mod) = none .

  --- Returns terms appearing in membership in condition with subtype of
  --- sort.
  op condSubsort : EqCondition Sort Module ~> ITPTermSet .
  eq condSubsort(EqC /\ T : S /\ EqC', S', Mod)
   = if subtype?(Mod, S, S') then
       T ; condSubsort(EqC /\ EqC', S', Mod)
     else
       condSubsort(EqC /\ EqC', S', Mod)
     fi .
  eq condSubsort(EqC, S, Mod) = none .

  op makeHyp : Formula Variable ITPTermSet -> Formula .
  eq makeHyp(Alpha, V, T ; TS)
   = conjunction(substitute(Alpha, V <- T), makeHyp(Alpha, V, TS)) .
  eq makeHyp(Alpha, V, none) = trueFormula .

  -------------
  --- function: makeNewGoalList
  -------------
  op makeNewGoalList : Goal Variable Sort Formula MembAxSet ~> GoalList .
  eq makeNewGoalList(G, V, S, Alpha, none) = nil .
  ceq makeNewGoalList(G, V, S, Alpha, Mb Mbs)
    = setFormula(
          AQuantification(rhs-vars(SB),
            implication(
              conjunction(
                condToFormula(EqC),
                makeHyp(Alpha, V,
                        varsSubsort(rhs-vars(SB), S, getMod(G)) ;
                        condSubsort(EqC, S, getMod(G)))),
              substitute(Alpha, V <- substitute(term(Mb), SB)))),
          incVarNum(G))
        makeNewGoalList(makeBrotherGoal(G), V, S, Alpha, Mbs)
   if SB := newVars(vars-itp(Mb), getVarNum(G))
   /\ EqC := substitute(condition(Mb), SB) .

  -----------
  --- Command: ind on_.
  -----------
  --- --- error cases
  --- -------
  --- --- 1. the given inductive variable is not
  --- ---    a outermost quantified variable in the given goal.

  -------------
  --- function: getIndSort
  -------------
  --- --- 1. it assumes that there is a membership
  --- ---    assertion about the given variable in
  --- ---    the given formula
  op getIndSort : Variable Formula ~> Sort .
  eq getIndSort(V, implication(sortP(V, S), Beta)) = S .
  eq getIndSort(V, implication(conjunction(sortP(V, S), Alpha), Beta)) = S .
  eq getIndSort(V, Alpha) = getType(V) [owise].

  --- Remove sort constraints for variable from antecedent of formula.
  op removeSortPfromAntc : Variable Formula ~> Formula .
  eq removeSortPfromAntc(V, implication(sortP(V, S), Beta)) = Beta .
  eq removeSortPfromAntc(V,
                         implication(conjunction(sortP(V, S), Alpha), Beta))
   = implication(Alpha, Beta) .
  eq removeSortPfromAntc(V, Alpha) = Alpha [owise].

  ceq exec(ind on SelVar ., Atts) = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, SelFormula) := getFormula(SelTask)
   /\ SelSort := getIndSort(SelVar, SelFormula)
   /\ NewGoals := makeNewGoalList(makeChildGoal(SelTask),
           SelVar,
           SelSort,
           AQuantification(VS \ SelVar,
                           removeSortPfromAntc(SelVar, SelFormula)),
           mbs-for-sort(getMod(SelTask), SelSort)) .

  ceq exec(ind on SelVar ., Atts)
    = itp-error(SelVar 'is 'not 'univerally 'quantified 'in 'the 'current 'goal.)
   if SelTask := getDefaultGoal(Atts)
   /\ hasAQuantVars(SelVar, getFormula(SelTask)) = false .

  ceq exec(ind on SelVar ., Atts)
    = itp-error('The 'variable SelVar 'is 'must 'be 'of 'an 'inductively 'defined
            'sort 'in 'the 'current 'goal.)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, Alpha) := getFormula(SelTask)
   /\ getIndSort(SelVar, Alpha) :: Sort = false .

  ceq exec(ind* on SelVar ., Atts) = replaceDefaultGoal(auto(NewGoals), Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, SelFormula) := getFormula(SelTask)
   /\ SelSort := getIndSort(SelVar, SelFormula)
   /\ NewGoals := makeNewGoalList(makeChildGoal(SelTask), SelVar, SelSort,
           AQuantification(VS \ SelVar,
                           removeSortPfromAntc(SelVar, SelFormula)),
           mbs-for-sort(getMod(SelTask), SelSort)) .

  ceq exec(ind* on SelVar ., Atts)
    = itp-error(SelVar 'is 'not 'univerally 'quantified 'in 'the 'current 'goal.)
   if SelTask := getDefaultGoal(Atts)
   /\ hasAQuantVars(SelVar, getFormula(SelTask)) = false .

  ceq exec(ind* on SelVar ., Atts)
    = itp-error('The 'variable SelVar 'is 'must 'be 'of 'an 'inductively 'defined
            'sort 'in 'the 'current 'goal.)
   if SelTask := getDefaultGoal(Atts)
   /\ AQuantification(VS, Alpha) := getFormula(SelTask)
   /\ getIndSort(SelVar, Alpha) :: Sort = false .

  -----------------------------------------------------------------------
  --- SPLIT
  ------------------------------------------------------------------------
  eq exec(split on SelTerm ., Atts)
   = exec(split on (SelTerm) lbl "" ., Atts) .

  ceq exec(split on (SelTerm) lbl Label ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ SelTerm : GroundTerm
   /\ getType(metaReduce(SelMod, SelTerm)) = 'Bool
   /\ NewGoals :=
        setMod(addHypTo(equality(SelTerm, 'true.Bool), SelMod,
                        qid("case-" + Label + "-true")),
               makeChildGoal(SelTask))
        setMod(addHypTo(equality(SelTerm, 'false.Bool), SelMod,
                        qid("case-" + Label + "-false")),
               makeBrotherGoal(makeChildGoal(SelTask))) .

  ceq exec(split on (SelTerm) lbl Label ., Atts)
    = itp-error('The 'term 'we 'split 'on 'must 'be 'ground)
   if SelTask := getDefaultGoal(Atts)
   /\ (SelTerm :: GroundTerm) = false .

  ceq exec(split on (SelTerm) lbl Label ., Atts)
    = itp-error('The 'term metaPrettyPrint(SelMod, SelTerm) 'does 'not 'have
            'sort 'Bool.)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ getType(metaReduce(SelMod, SelTerm)) =/= 'Bool .

  ------------------------------------------------------------------------
  --- CTOR-SPLIT RULE
  ------------------------------------------------------------------------
  --- makeSplitNewGoalList
  op makeSplitNewGoalList : Goal Constant MembAxSet ~> GoalList .
  eq makeSplitNewGoalList(G, C, none) = nil .
  ceq makeSplitNewGoalList(G, C, Mb Mbs)
    = setFormula(
        AQuantification(rhs-vars(SB),
          implication(conjunction(equality(C, substitute(term(Mb), SB)),
                                  condToFormula(EqC)),
                      getFormula(G))),
        incVarNum(G))
      makeSplitNewGoalList(makeBrotherGoal(G), C, Mbs)
   if SB := newVars(vars-itp(Mb), getVarNum(G))
   /\ EqC := substitute(condition(Mb), SB) .

  ceq exec(ctor-split on (SelCns) SelSort ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ NewGoals := makeSplitNewGoalList(
        makeChildGoal(SelTask),
        SelCns,
        mbs-for-sort(getMod(SelTask), SelSort)) .

  ---- TODO: Figure out why ctor split must be a constant.
  ceq exec(ctor-split on (SelTerm) SelSort ., Atts)
    = itp-error('The 'term 'is 'not 'a 'constant.)
   if SelTask := getDefaultGoal(Atts)
   /\ SelTerm :: Constant = false .

  --- Returns true if the term has the integer kind in the user module.
  op hasIntKind? : Module Term -> Bool .
  --- We use the == below in case the call to sameKind fails because the sort
  --- Nat is not even declared in the module.
  eq hasIntKind?(Mod, T)
   = sameKind(Mod, getType(metaNormalize(Mod, T)), 'Nat) == true .

  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  --- COMPLETE INDUCTION
  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  --------------------------------------------------------------------------
  ---Joe: Note this code appears buggy.  The program got "stuck" with the
  --- following:
  ---X (goal ordlist-ord-insert : ORDLIST |-
  ---X      A{ X:Int? ; Y:Int? } (( X:Int? ) = (X:Int?)) .)
  ---X
  ---X (c-ind on (X:Int?) .)

  ceq exec(c-ind on (SelTerm)., Atts)
    = itp-error('The 'given 'term 'contains 'a 'variable 'that 'is 'not
            'universally 'quantified 'in 'this 'goal)
   if SelTask := getDefaultGoal(Atts)
   /\ hasIntKind?(getMod(SelTask), SelTerm)
   /\ AQuantification(VS, Alpha) := getFormula(SelTask)
   /\ vars-itp(SelTerm) subset VS = false .

  ceq exec(c-ind on (SelTerm)., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ hasIntKind?(SelMod, SelTerm)
   /\ SelFormula := getFormula(SelTask)
   /\ AQuantification(VS, Alpha) := SelFormula
   /\ vars-itp(SelTerm) subset VS
   /\ NewVar := newVar(getVarNum(SelTask), 'Nat, 0)
   /\ NewLabel := addChild(getName(SelTask))
   /\ NewMod
        := addLemTo(checkNatExp(SelFormula, SelTerm, vars-itp(SelTerm)),
                    SelMod,
                    qid("lem-" + getName(SelTask)))
   /\ NewGoals :=
        setFormula(checkNatExp(SelFormula, SelTerm, vars-itp(SelTerm)),
          setName(NewLabel, incVarNum(SelTask)))
        setFormula(AQuantification(VS,
                     implication(equality(SelTerm, '0.Zero), Alpha)),
          setMod(NewMod,
            setName(addBrother(NewLabel), incVarNum(SelTask))))
        setFormula(
          AQuantification(NewVar,
            implication(
              AQuantification(VS,
                implication(equality('_<_[SelTerm, NewVar], 'true.Bool),
                            Alpha)),
              AQuantification(VS,
                implication(equality(SelTerm, NewVar), Alpha)))),
          setMod(NewMod,
            setName(addBrother(addBrother(NewLabel)),
              incVarNum(SelTask)))) .

  -----------------------
  --- checkNatExpression
  -----------------------
  op checkNatExp : Formula Term VariableSet ~> Formula .
  eq checkNatExp(Alpha, T, VS)
   = AQuantification(VS,
        implication(getHypInfo(getAllAntc(getAQuantFormula(Alpha)), VS),
                    sortP(T, 'Nat))) .

  op getHypInfo : ConjAtomic VariableSet ~> Formula .
  eq getHypInfo(conjunction(Alpha, Beta), VS)
   = conjunction(getHypInfo(Alpha, VS), getHypInfo(Beta, VS)) .
  eq getHypInfo(equality(T1, T2), VS)
   = if VS subset vars-itp(T1) then
       equality(T1, T2)
     else
       trueFormula
     fi .
  eq getHypInfo(sortP(T, S), VS)
   = if VS subset vars-itp(T) then
       sortP(T, S)
     else
       trueFormula
     fi .
  eq getHypInfo(trueFormula, VS) = trueFormula .

  ----------------------------------------------------------
  --- CONJUNCTION RULE
  ----------------------------------------------------------
  ceq exec(cnj ., Atts)
    = if | FS | > 1 then
        replaceDefaultGoal(replace-formulas(FS, SelTask), Atts)
      else
         itp-error('The 'current 'goal 'could 'not 'be 'seen 'as 'a 'conjunctive
               'formula.)
      fi
   if SelTask := getDefaultGoal(Atts)
   /\ FS := extract-conj(getFormula(SelTask)) .

  ---------------------------------------
  --- COMMAND SEL
  --------------------------------------
  eq exec(sel NewLabel .,
          (defaultGoal : ST,
           proofState : PS, Atts))
   = if getGoal(NewLabel, PS) :: Goal 
     then next((defaultGoal : NewLabel,
                proofState : PS, Atts),
               'Selected 'goal: '\n
               meta-pretty-print-list(NewLabel, getGoal(NewLabel, PS)))
     else itp-error('There 'is 'no 'goal 'named qid(NewLabel + "."))
     fi .

  ---------------------------------------
  --- COMMAND PARSE
  --------------------------------------

  eq exec(parse (T)., Atts)
   = next(Atts, 'The 'term 'is 'well-parsed.) .

  eq exec(parse (T) in Mod ., Atts)
   = next(Atts, 'The 'term 'is 'well-parsed.) .

  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  --- CTOR-TERM-SPLIT RULE
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------
  --- makeTermSplitNewGoalList
  ---------------------------
  op makeTermSplitNewGoalList : Goal VariableSet PairSubstFormulaSet
      -> GoalList .
  eq makeTermSplitNewGoalList(G, VS, nonePairSubstFormulaSet) = nil .
  eq makeTermSplitNewGoalList(G, VS,
       pairSubstFormulaSet(pairSubstFormula(VS', SB, Alpha), PSBF))
   = setFormula(
      implication(
        conjunction(
         varsToNewConstants(VS', substituteEquality(getMod(G), SB, VS), AT),
         varsToNewConstants(VS', Alpha, AT)),
        varsToNewConstants(VS', getFormula(G), AT)),
      setMod(addOpsITP(createNewConstants(VS', ""), getMod(G)), G))
     makeTermSplitNewGoalList(incVarNum(makeBrotherGoal(G)), VS, PSBF) .

  op substituteEquality : Module Substitution VariableSet -> Formula .
  eq substituteEquality(Mod, none, VS) = trueFormula .

  eq substituteEquality(Mod, (V <- V') ; SB, VS)
   = if V in VS then
       conjunction(
         equality(qid(string(getName(V)) + "." + string(getType(V))), V'),
         substituteEquality(Mod, SB, VS))
     else
       conjunction(equality(qid(string(getName(V')) + "." +
                        string(getType(V'))), V),
                   substituteEquality(Mod, SB, VS))
     fi .

  eq substituteEquality(Mod, (V <- C) ; SB, VS)
   = if V in VS then
       conjunction(
         equality(qid(string(getName(V)) + "." + string(getType(V))), C),
         substituteEquality(Mod, SB, VS))
     else
       conjunction(equality(V, C), substituteEquality(Mod, SB, VS))
      fi .

  eq substituteEquality(Mod, ((V <- F[TL]) ; SB), VS)
   = if V in VS then
       conjunction(
         equality(qid(string(getName(V)) + "." + string(getType(V))), F[TL]),
         substituteEquality(Mod, SB, VS))
     else
       conjunction(equality(V, antiReverseVar(F[TL])),
                   substituteEquality(Mod, SB, VS))
     fi .

  -----------------------------------------------------------
  --- WARNING: This must be extended to the unification case!
  -----------------------------------------------------------
  op reverseVar : Term -> Term .
  eq reverseVar(V) = V .
  eq reverseVar(C)
   = if find(string(getName(C)), "*", 0) == notFound then
       C
     else
       qid(string(getName(C)) + ":" + string(getType(C)))
     fi .
  eq reverseVar(F[TL]) = F[reverseVarAux(TL)] .
  ---
  op reverseVarAux : TermList -> TermList .
  eq reverseVarAux((T, TL)) = (reverseVar(T), reverseVarAux(TL)) .
  eq reverseVarAux(empty) = empty .
  ---------
  --------
  op antiReverseVar : Term -> Term .
  eq antiReverseVar(V) = qid(string(getName(V)) + "." + string(getType(V))) .
  eq antiReverseVar(C) = C .
  eq antiReverseVar(F[TL]) = F[antiReverseVarAux(TL)] .
  ---
  op antiReverseVarAux : TermList -> TermList .
  eq antiReverseVarAux((T, TL))
   = (antiReverseVar(T), antiReverseVarAux(TL)) .
  eq antiReverseVarAux(empty) = empty .

  op genTermSplit : Nat Module Term MembAxSet -> PairSubstFormulaSet .
  ceq genTermSplit(N, Mod, T', Mb Mbs)
    = if SBS == emptyITPSubstitutionSet then
        genTermSplit(N, Mod, T', Mbs)
      else
        pairSubstFormulaSet(
          pairSubstFormula(rhs-vars(SB), SBS, condToFormula(EqC)),
          genTermSplit(N, Mod, T', Mbs))
      fi
   if SB := newVars(vars-itp(Mb), N)
   /\ EqC := substitute(condition(Mb), SB)
   /\ SBS := unify(Mod, substitute(term(Mb), SB), T') .
  eq genTermSplit(N, Mod, T', none) = nonePairSubstFormulaSet .

  -------------
  --- function: isAnHypothesis?
  -------------
  op isAnHypothesis? : Module Term Sort MembAxSet -> Bool .
  ceq isAnHypothesis?(Mod, T, S, mb T' : S' [AtS] . Mbs) = true
   if sameKind(Mod, S, S')
   /\ isAnIdentity?(Mod, equality(T, T')) .
  eq isAnHypothesis?(Mod, T, S, Mbs) = false [owise].

  ceq exec(ctor-term-split on (SelTerm) SelSort ., Atts)
    = itp-error('It 'is 'not 'an 'hypothesis 'that
             metaPrettyPrint(SelMod, SelTerm) 'has 'sort SelSort '.)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ isAnHypothesis?(setEqs(none, SelMod), SelTerm, SelSort, getMbs(SelMod))
        = false .

  ceq exec(ctor-term-split on (SelTerm) SelSort ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ isAnHypothesis?(setEqs(none, SelMod), SelTerm, SelSort,
                      getMbs(SelMod))
   /\ NewGoals := makeTermSplitNewGoalList(
           incVarNum(makeChildGoal(SelTask)),
           vars-itp(reverseVar(SelTerm)),
           genTermSplit(getVarNum(SelTask),
                        SelMod,
                        reverseVar(SelTerm),
                        mbs-for-sort(SelMod, SelSort))) .

  ------------------------------------------------------------------
  ---- cov
  ------------------------------------------------------------------
  --- Case where cover set induction can successfully be applied.
  ceq exec(cov using STS on T ., Atts)
    = if hasAQuantVars(vars-itp(T), getFormula(G)) then
        replaceDefaultGoal(
          replace-formulas(cov-split-scheme(STS, G, T, none), incVarNum(G)),
          Atts)
      else
        itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
              'variables 'in 'the 'outermost 'universal 'quantifier '.)
      fi
   if G := getDefaultGoal(Atts) .

  ------------------------------------------------------------------
  ---- cov*
  ------------------------------------------------------------------
  ceq exec(cov* using STS on T ., Atts)
    = if hasAQuantVars(vars-itp(T), getFormula(G)) then
        replaceDefaultGoal(
          auto(replace-formulas(cov-split-scheme(STS, G, T, none),
                                incVarNum(G))),
          Atts)
      else
        itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
              'variables 'in 'the 'outermost 'universal 'quantifier '.)
      fi
   if G := getDefaultGoal(Atts) .

  ------------------------------------------------------------------
  ---- eq-split
  ------------------------------------------------------------------
  --- Returns "induction scheme" for equation splitting.
  op eq-split-scheme : StringSet Goal Term -> FormulaSet .
  eq eq-split-scheme(STS, G, T)
   = $eq-split-scheme(getMod(G),
                      stripAQuantVars(vars-itp(T), getFormula(G)),
                      expand(STS, G, T),
                      none) .

  --- Tail recursive implementation of above function.
  op $eq-split-scheme : Module Formula CondSubstSet FormulaSet
        ~> FormulaSet .
  eq $eq-split-scheme(M, Alpha, cs(SB, EqC) ; CSS, FS)
   = $eq-split-scheme(M, Alpha, CSS, FS ;
        normalize(
          AQuantification(rhs-vars(SB),
            implication(condToFormula(EqC),
                        substitute(Alpha, SB))),
          M)) .
  eq $eq-split-scheme(M, Alpha, none, FS) = FS .

  ceq exec(eq-split using STS on T ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ hasAQuantVars(vars-itp(T), getFormula(SelTask))
   /\ NewGoals
        := replace-formulas(eq-split-scheme(STS, SelTask, T), SelTask) .

  ceq exec(eq-split using STS on T ., Atts)
    = itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
            'variables 'in 'the 'outermost 'universal 'quantifier '.)
   if hasAQuantVars(vars-itp(T), getFormula(getDefaultGoal(Atts))) = false .

  ------------------------------------------------------------------
  ---- eq-split*
  ------------------------------------------------------------------
  ceq exec(eq-split* using STS on T ., Atts)
    = replaceDefaultGoal(auto(NewGoals), Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ hasAQuantVars(vars-itp(T), getFormula(SelTask))
   /\ NewGoals
      := replace-formulas(eq-split-scheme(STS, SelTask, T), SelTask) .

  ceq exec(eq-split* using STS on T ., Atts)
    = itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
            'variables 'in 'the 'outermost 'universal 'quantifier '.)
   if hasAQuantVars(vars-itp(T), getFormula(getDefaultGoal(Atts))) = false .

  ------------------------------------------------------------------
  ---- cov-split
  ------------------------------------------------------------------
  ceq exec(cov-split using STS on T split TS ., Atts)
    = if hasAQuantVars(vars-itp(T), getFormula(G)) then
        replaceDefaultGoal(
          replace-formulas(cov-split-scheme(STS, G, T, TS), incVarNum(G)),
          Atts)
      else
        itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
              'variables 'in 'the 'outermost 'universal 'quantifier '.)
      fi
   if G := getDefaultGoal(Atts) .

  ------------------------------------------------------------------
  ---- cov-split*
  ------------------------------------------------------------------
  ceq exec(cov-split* using STS on T split TS ., Atts)
    = if hasAQuantVars(vars-itp(T), getFormula(G)) then
        replaceDefaultGoal(
          auto(replace-formulas(cov-split-scheme(STS, G, T, TS),
                                incVarNum(G))),
          Atts)
      else
        itp-error('The 'variables 'in 'the 'pattern 'must 'be 'a 'subset 'of 'the
              'variables 'in 'the 'outermost 'universal 'quantifier '.)
      fi
   if G := getDefaultGoal(Atts) .

  ------------------------------------------------------------------
  ---- ctor-def
  ------------------------------------------------------------------
  --- Generates an alternative constructor definition.
  ---TODO: Add error handling.
  ceq exec(ctor-def ST : AQuantification(V, Alpha) ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   --- Check label not already in use.
   /\ bound-ctor-set?(ST, SelTask) = false
   --- Check variable type is a sort.
   /\ getType(V) : Sort
   /\ Mbs := parse-mbs(V, Alpha)
   /\ NewGoals := setName(ST + AT + "0",
                    setFormula(AQuantification(V, Alpha), SelTask))
                  add-named-ctors(ST, getType(V), Mbs, SelTask) .

  ceq exec(ctor-def ST : Alpha ., Atts)
    = itp-error('There 'is 'already 'a 'ctor 'definition 'named qid(ST) '.)
   if SelTask := getDefaultGoal(Atts)
   --- Check label not already in use.
   /\ bound-ctor-set?(ST, SelTask) .

  ------------------------------------------------------------------
  ---- set-default-ctor
  ------------------------------------------------------------------
  ceq exec(set-default-ctor ST ., Atts)
    = replaceDefaultGoal(set-default-ctor(ST, SelTask), Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ bound-ctor-set?(ST, SelTask) .

  ceq exec(set-default-ctor ST ., Atts)
    = itp-error('There 'is 'no 'constructor 'definition 'named qid(ST) '.)
   if SelTask := getDefaultGoal(Atts)
   /\ bound-ctor-set?(ST, SelTask) = false .

  -----------------------------------------------------------------
  ---- SORT-CTOR-SPLIT
  ------------------------------------------------------------------
  ceq exec(sort-ctor-split on SelCns ., Atts)
    = replaceDefaultGoal(NewGoals, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ NewGoals := makeSplitNewGoalList(makeChildGoal(SelTask), SelCns,
          mbs-for-sort(SelMod, getType(metaReduce(SelMod, SelCns)))) .

  ceq exec(sort-ctor-split on SelTerm ., Atts)
    = itp-error('The 'term 'is 'not 'a 'constant)
   if SelTask := getDefaultGoal(Atts)
   /\ SelTerm :: Constant = false .

  ----------------------------------------------------------------------
  --- drv
  ----------------------------------------------------------------------
  --- check hypothesis numbers
  ceq exec(drv (SelTerm)., Atts)
    = replaceDefaultGoal(NewTask, Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ NewMod := addEqsITP(getInsEqs(SelTerm, getDrvEqs(getEqs(SelMod)), SelMod),
                       SelMod)
   /\ NewTask := setMod(NewMod, incHypNum(1, SelTask)) .


  op getDrvEqs : EquationSet -> EquationSet .
  ceq getDrvEqs(Eq Eqs) = Eq getDrvEqs(Eqs)
   if F[T1, T2] := lhs(Eq)
   /\ F in ('_<_ ;  '_<=_ ; '_>_ ; '_>=_ ).
  eq getDrvEqs(Eqs) = none [owise].

  --- Note: the metaReduce is key to keep the
  --- store-expression in normal-form
  op getInsEqs : Term EquationSet Module -> EquationSet .
  ceq getInsEqs(T, (ceq F[T1, T2] = T3 if EqC [AS] .) Eqs, Mod)
    = if solveCondWithReducePlus(Mod, substitute(EqC, SB)) then
        substitute(eq F[T1, T2] = T3 [AS] ., SB)
        getInsEqs(T, Eqs, Mod)
      else
        substitute(ceq F[T1, T2] = T3 if EqC [AS] ., SB)
        getInsEqs(T, Eqs, Mod)
      fi
   if MyTerm := getTerm(metaReduce(Mod, T))
   /\ SB := metaMatch(Mod, T1, MyTerm, nil, 0) .
  ceq getInsEqs(T, (ceq F[T1, T2] = T3 if EqC [AS] . Eqs), Mod)
    = if solveCondWithReducePlus(Mod, substitute(EqC, SB)) then
        (eq substitute(F[T1, T2], SB) = substitute(T3, SB) [AS] .
         getInsEqs(T, Eqs, Mod))
      else
        (ceq substitute(F[T1, T2], SB) = substitute(T3, SB)
          if substitute(EqC, SB) [AS] .
         getInsEqs(T, Eqs, Mod))
      fi
   if MyTerm := getTerm(metaReduce(Mod, T))
   /\ SB :=
         getSubstitution(metaXmatch(Mod, T2, MyTerm, nil, 0, unbounded, 0)) .
  eq getInsEqs(T, Eqs, Mod) = Eqs [owise].

  ----------------------------------------------------------------------
  --- enable
  ----------------------------------------------------------------------
  ceq exec(enable Label ., Atts)
    = if (Eqs == getEqs(SelMod)) and-then (Mbs == getMbs(SelMod)) then
        itp-error('There 'was 'no 'disabled 'equation 'or 'membership 'with 'the
              'given 'label.)
      else
        replaceDefaultGoal(setMod(setMbs(Mbs, setEqs(Eqs, SelMod)), SelTask),
                           Atts)
      fi
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ Eqs := set-enabled(true, qid(Label), getEqs(SelMod))
   /\ Mbs := set-enabled(true, qid(Label), getMbs(SelMod)) .

  ----------------------------------------------------------------------
  --- disable
  ----------------------------------------------------------------------
  ceq exec(disable Label ., Atts)
    = if (Eqs == getEqs(SelMod)) and-then (Mbs == getMbs(SelMod)) then
        itp-error('There 'was 'no 'enabled 'equation 'or 'membership 'with 'the
              'given 'label.)
      else
        replaceDefaultGoal(setMod(setMbs(Mbs, setEqs(Eqs, SelMod)), SelTask),
                           Atts)
      fi
   if SelTask := getDefaultGoal(Atts)
   /\ SelMod := getMod(SelTask)
   /\ Eqs := set-enabled(false, qid(Label), getEqs(SelMod))
   /\ Mbs := set-enabled(false, qid(Label), getMbs(SelMod)) .

  ----------------------------------------------------------------------
  --- red
  ----------------------------------------------------------------------
  --- "red T ." reduces the term T in the current goal's module and prints
  --- the result.
  ceq exec(red SelTerm ., Atts)
    = next(Atts, 'result tokenize(Tp) ': ' metaPrettyPrint(SelMod, T2))
   if SelMod := getMod(getDefaultGoal(Atts))
   /\ {T2, Tp} := metaReduce(SelMod, SelTerm) .

  ----------------------------------------------------------------------
  --- defequiv
  ----------------------------------------------------------------------
  ceq exec(defequiv F on S ., Atts)
    = replaceDefaultGoal(defequiv(SelTask, F, S), Atts)
   if SelTask := getDefaultGoal(Atts)
   /\ is-comm-rel(getMod(SelTask), F, S) .

  --- Error handling
  ceq exec(defequiv F on S ., Atts)
    = itp-error('The 'module 'does 'not 'contain 'a 'commutative 'relation 'with
            'the 'name F 'on 'sort S '.
            'Additionally '`, 'due 'to 'potential 'non-termination 'issues
            'we 'do 'not 'allow F 'to 'be 'associative 'or 'have 'an
            'identity 'axiom.)
   if SelTask := getDefaultGoal(Atts)
   /\ is-comm-rel(getMod(SelTask), F, S) = false .

  ----------------------------------------------------------------------
  --- equiv-propagate
  ----------------------------------------------------------------------
  eq exec(equiv-propagate ., Atts)
   = replaceDefaultGoal(equiv-propagate(getDefaultGoal(Atts)), Atts) .
endm

set show loop stats on .
set show loop timing on .

--- trace exclude ITP-TOOL .
trace exclude SUP-INF .
trace exclude SUP-INF-METHOD .
trace exclude EXT-SUP-INF-METHOD .
trace exclude TMP .
