set include BOOL off .

fmod NAT-FVP is
  protecting TRUTH-VALUE .
  sorts Nat NzNat .
  subsorts NzNat < Nat .
  op 0 : -> Nat [ctor metadata "0"] .
  op 1 : -> NzNat [ctor metadata "1"] .
  op _+_ : Nat Nat -> Nat [ctor assoc comm id: 0  metadata "2"] . ---- ctor added
  op _+_ : NzNat NzNat -> NzNat [ctor assoc comm id: 0 metadata "2"] .
  op _~_ : Nat Nat -> Bool [comm metadata "34"] . 
  op _>_ : Nat Nat -> Bool [metadata "35"] .
  op _or_ : Bool Bool -> Bool [assoc comm metadata "33"] .
  vars n m : Nat .  vars n' m' : NzNat .
  var B : Bool .
  eq [1]: n ~ n = true [variant] .
  eq [2]: (n + m') ~ n = false [variant] .
  eq [3]: n + m' > n = true [variant] .
  eq [4]: n > n + m = false [variant] .
  eq [5]: B or true = true [variant] .
  eq [6]: B or false = B [variant] .
  eq [7]: B or B = B [variant] .
endfm

fmod NAME is protecting NAT-FVP . 
 sort Name .
 op i : Name -> Nat [metadata "32"] .
 op j : Nat -> Name [metadata "33"] .
 op _.=._ : Name Name -> Bool [comm metadata "36"] . 
 vars n m : Nat .  vars X Y : Name .
 eq [8]: X .=. Y = i(X) ~ i(Y) .
 eq [9]: j(i(X)) = X .
 eq [10]: i(j(n)) = n .
endfm

fmod NAME-SET is protecting NAME . 
  sorts   Set NeSet .
  subsorts Name < NeSet < Set .
  op mt : -> Set [ctor metadata "4"] .                                     
  op _,_ : Set Set -> Set [ctor assoc comm id: mt metadata "5"] .        
  op _,_ : NeSet NeSet -> NeSet [ctor assoc comm id: mt metadata "5"] .  
  op _\_ : Set Name -> Set [metadata "37"] .                            
  op _in_ :  Name Set -> Bool [metadata "38"] .                           

  vars S U : Set .   vars X Y : Name .  vars P Q : NeSet . 

  eq [11]: (X,X) = X .   
  eq [12]: mt \ X = mt .
  eq [13]: X \ X = mt .
  ceq [14]: X \ Y = X if X .=. Y = false .
  eq [15] : (X,Q) \ X = (Q \ X) .
  ceq [16]: (X,Q) \ Y = X,(Q \ Y) if X .=. Y = false .
  eq [17]: X in mt = false .
  eq [18]: X in Y = (X .=. Y) .
  eq [19]: X in (Y,Q) = (X .=. Y) or (X in Q) .
endfm

fmod NEXT is protecting NAME-SET .
  op _>>_ :  Name Name -> Bool [metadata "39"] .
  op max :  NeSet -> Name [metadata "40"] .
  op inc : Name -> Name [metadata "39"] .
  op next : NeSet -> Name [metadata "41"] .
  vars S U : Set .  var Q : NeSet .  vars X Y : Name .  vars n m : Nat .

  eq [20]: X >> Y = i(X) > i(Y) .
  eq [21]: max(X) = X .
  eq [22]: max(X,X) = X .
  ceq [23]: max(X,Y) = X if X >> Y = true .
  eq [24]: max(X,X,Q) = max(X,Q) .
  ceq [25]: max(X,Y,Q) = max(X,Q) if X >> Y = true .
  eq [26]: inc(X) = j(i(X) + 1)  .
  eq [27]: next(X) = inc(X) .
  eq [28]: next(X,Q) = inc(max(X,Q)) .
endfm

fmod PI is protecting NEXT .
  sorts Pi NeSum Sum NeProc Proc . 
  subsorts Pi < NeSum < NeProc Sum <  Proc .
  
  op 0 : -> Sum [ctor metadata "6"] .                  
  
  op _|_ : Proc Proc -> Proc  [ctor assoc comm id: 0 metadata "7"] .
  op _|_ : NeProc NeProc -> NeProc [ctor assoc comm id: 0 metadata "7"] .
 
  op _+_ : Sum Sum -> Sum [frozen assoc comm id: 0 metadata "8"] .
  op _+_ : NeSum NeSum -> NeSum [ctor frozen assoc comm id: 0 metadata "8"] .
 
  op !_ : Proc -> NeProc [ctor frozen metadata "9"] . 
			   
  op new[_]{_} : Name Proc -> Proc [ctor metadata "10"] .
  op new[_]{_} : Name NeProc -> NeProc [ctor metadata "10"] .
                                     *** new-abstraction [name restriction]
  
  op in_[_]._ : Name Name Proc -> Pi [ctor frozen metadata "11"] .
                                *** synchronous reception with in-abstraction
  
  op out_<_>._ : Name Name Proc -> Pi [ctor frozen metadata "12"] .
                                 *** synchronous message send along a channel
		     
  op fn : Proc -> Set [frozen metadata "39"] .                             *** free names

   sort Ren .  *** renaming sort

  op [_:=_] : Name Name -> Ren [ctor metadata "13"] .           *** renaming
				     
  op __ : Ren Name -> Name [frozen metadata "42"] .
                                       *** renaming applied to names

  op __ : Ren Proc -> Proc [frozen metadata "42"] .
                                       *** renaming applied to processes
	     
  vars X Y Z X' Y' : Name .
  vars P Q R T : Proc .  vars P' R' Q' T' : NeProc . vars N M : Sum .
  vars N' M' : NeSum . vars n m : Nat .  vars n' m' : NzNat .

  *** free names

  eq [29] : fn(0) = mt .
  eq [30] : fn(P' | Q') = fn(P'),fn(Q') .
  eq [31] : fn(N' + M') = fn(N'),fn(M') .
  eq [32] : fn(out X < Y >. P) = X,Y,fn(P) .
  eq [33] : fn(! P) = fn(P) .
  eq [34] : fn(in X [ Y ]. P) = X,(fn(P) \ Y) .
  eq [35] : fn(new [X]{P'}) = fn(P') \ X .
  
  *** renaming application for names:

  eq [36]: [X := Y] X = Y .
  ceq [37]: [X := Y] Z = Z if X .=. Z = false .
   

  *** renaming application for non-binders

  eq [38]: [X := Y] 0 = 0 .
  eq [39]: [X := Y] (P' | R') = ([X := Y] P') | ([X := Y] R') .
  eq [40]: [X := Y] (M' + N') = ([X := Y] M') + ([X := Y] N') .  
  eq [41]: [X := Y] (out X' < Y' >. P) =
             out ([X := Y] X') < [X := Y] Y' >. ([X := Y] P) .
  eq [42]: [X := Y] (! P) = ! ([X := Y] P) .

  *** renaming application for in- and new-binders

  eq [43]: [X := Y] (in X' [ X ]. P) =
                in ([X := Y] X') [ X ]. P .

  ceq [44]: [X := Y] (in X' [ Y' ]. P) = in ([X := Y] X') [ Y' ]. ([X := Y] P)
	                               if X .=. Y' = false /\ Y .=. Y' = false .

  eq [45]: [X := Y] (new [X]{P}) = new [X]{P} .
  ceq [46]: [X := Y] (new [X']{P}) = new [X']{[X := Y] P}
                                    if X .=. X' = false /\ Y .=. X' = false .
  ceq [47]: [X := Y] (in X' [Y]. P) = 
                       in ([X := Y] X') [next(Y,fn(P))]. ([X := Y][Y := next(Y,fn(P))] P)
                          if X .=. Y = false .

  ceq [48]: [X := Y] (new [Y]{P}) = new [next(Y,fn(P))]{[X := Y][Y := next(Y,fn(P))] P}
                                           if X .=. Y = false .

*** alpha equivalences

***  ceq [alpha-in]: in X' [ X ]. P = in X' [ Y ]. ([X := Y]  P)                                          ***                               if Y in fn(P) = false [nonexec] .

***  ceq [alpha-new]: new [X]{P'} = new [Y]{[X := Y] P'}
***                    if X in fn(P') = true /\ Y in fn(P') = false [nonexec] .

  *** equality of processes is given by the ACU axioms for
  *** _|_ and  _+_, plus the following equations for
  *** new-restricted processes

  ceq [49]: new [X]{P} = P if X in fn(P) = false .
  ceq [50]: new [X]{new[Y]{P'}} = new [Y]{new[X] {P'}} 
            if Y >> X = true /\ Y in fn(P') = true /\ X in (fn(P')\ Y) = true .
endfm

mod PI-CALC is protecting PI .

  vars X Y Z X' Y' : Name .
  vars P Q R T : Proc .  vars P' R' Q' T' : NeProc . vars N M : Sum .
  vars N' M' : NeSum . vars n m : Nat .  vars n' m' : NzNat .

  rl [react] : (N + out X < Z >. P) | (M + in X [ Y ]. Q) =>  P | [Y := Z] Q .
  rl [repl] : ! P' => P' | ! P' .
  rl [repl-inv] : P' | ! P' => ! P' .    
  crl [extrude] : new [X]{P' | R'} => new [X]{P'} | R' 
                                   if X in fn(R') = false /\ X in fn(P') = true .
  crl [intrude] : new [X]{P'} | R' => new [X]{P' | R'} 
                                   if X in fn(R') = false /\ X in fn(P') = true .
endm



