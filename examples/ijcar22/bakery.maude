mod BAKERY is
sorts Nat LNat Nat? State WProcs Procs .
subsorts Nat LNat < Nat? . subsort WProcs < Procs .
op 0 : -> Nat .
op s : Nat -> Nat .
op [_] : Nat -> LNat . *** number-locking operator
op < wait,_> : Nat -> WProcs .
op < crit,_> : Nat -> Procs .
op mt : -> WProcs . *** empty multiset
op __ : Procs Procs -> Procs [assoc comm id: mt] . *** union
op __ : WProcs WProcs -> WProcs [assoc comm id: mt] . *** union
op _|_|_ : Nat Nat? Procs -> State .
vars n m i j k : Nat . var x? : Nat? . var PS : Procs . var WPS : WProcs .
rl [new] : m | n | PS => s(m) | n | < wait, m > PS [narrowing] .
rl [enter] : m | n | < wait, n > PS => m | [n] | < crit, n > PS [narrowing] .
rl [leave] : m | [n] | < crit, n > PS => m | s(n) | PS [narrowing] .
endm

{fold} vu-narrow {filter}
m | n | WPS =>* i | x? | < crit, j > < crit, k > PS .
---(
No solution.
rewrites: 3 in 1ms cpu (2ms real) (1694 rewrites/second)
---)

----
---- MAUDE DOES NOT HANDLE MEMBERSHIPS WHEN NARROWING, JUST DISCARD THEM
----

mod BAKERY is
sorts Nat State Proc VProcs Procs .
subsort Proc VProcs < Procs .
op 0 : -> Nat .
op s : Nat -> Nat .
op < wait,_> : Nat -> Proc .
op < crit,_> : Nat -> Proc .
op mt : -> Procs . *** empty multiset
op __ : Procs Procs ~> Procs [assoc comm id: mt] . *** union
mb mt : VProcs .
cmb < wait, n > WPS : VProcs if not n in WPS .
op _in_ : Nat VProcs -> Bool .
eq n in < wait, n > WPS = true .
eq n in WPS = false [owise] .
op _|_|_ : Nat Nat Procs -> State .
vars n m i j k l : Nat . var PS : Procs . var WPS : VProcs .
rl [new] : m | n | PS => s(m) | n | < wait, m > PS [narrowing] .
rl [enter] : m | n | < wait, n > PS => m | n | < crit, n > PS [narrowing] .
rl [leave] : m | n | < crit, n > PS => m | s(n) | PS [narrowing] .
endm

{fold} vu-narrow {filter} m | n | WPS =>* i | l | < crit, j > < crit, k > PS .
---(
{fold} vu-narrow {filter} in BAKERY : m | n | WPS =>* i | x? | < crit,j > < crit,k > PS .
New state s(@1:Nat) | @2:Nat | @3:VProcs < wait,@1:Nat > subsumed by #1:Nat | #2:Nat | #3:VProcs
Total number of states seen = 2
Of which 1 were considered for further narrowing.

No solution.
rewrites: 5 in 0ms cpu (0ms real) (7473 rewrites/second)
---)

---- DON'T KNOW WHAT I'M DOING
---- I DON'T KNOW WHETHER THE ABSTRACTION EQUATIONS CAN BE MARKED AS VARIANT

mod BAKERY is
sorts NzNat Nat State WProc CProc SProc SProcs Procs .
subsort NzNat < Nat .
subsort SProc < SProcs .
subsort WProc CProc SProcs < Procs .
op 0 : -> Nat .
op s : Nat -> NzNat .
op < sleep,_> : Nat -> SProc .
op < wait,_> : NzNat -> WProc .
op < crit,_> : NzNat -> CProc .
op mt : -> SProcs . *** empty multiset
op __ : Procs Procs -> Procs [assoc comm id: mt] . *** union
op __ : SProcs SProcs -> SProcs [assoc comm id: mt] . *** union
op _|_|_ : Nat Nat Procs -> State .
vars n m i j k x : Nat . var PS : Procs . var SPS : SProcs .
rl [wait] : m | n | < sleep, 0 > PS => s(m) | n | < wait, m > PS [narrowing] .
rl [enter] : m | n | < wait, n > PS => m | n | < crit, n > PS [narrowing] .
rl [leave] : m | n | < crit, n > PS => m | s(n) | < sleep, 0 > PS [narrowing] .
eq s(m) | s(n) | < wait, n > PS = m | n dec(< wait, n > PS) [variant] .
eq s(m) | s(n) | < crit, n > PS = m | n dec(< crit, n > PS) [variant] .
op dec : Procs -> Procs .
eq dec(< wait, s(n) > PS) = < wait, n > dec(PS) [variant] .
eq dec(< crit, s(n) > PS) = < crit, n > dec(PS) [variant] .
eq dec(< sleep, 0 > PS) = < sleep, 0 > dec(PS) [variant] .
eq dec(mt) = mt [variant] .
endm

set verbose on .
{fold} vu-narrow {filter}
m | n | SPS =>* i | x | < crit, j > < crit, k > PS .
